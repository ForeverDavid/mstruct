<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>ObjCryst++: ObjCryst::ScatteringPowerSphere Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">ObjCryst++
   &#160;<span id="projectnumber">1.5CVS</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="a00171.html">ObjCryst</a>      </li>
      <li class="navelem"><a class="el" href="a00092.html">ScatteringPowerSphere</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a>  </div>
  <div class="headertitle">
<div class="title">ObjCryst::ScatteringPowerSphere Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="ObjCryst::ScatteringPowerSphere" --><!-- doxytag: inherits="ObjCryst::ScatteringPower" -->
<p>\ brief <a class="el" href="a00090.html" title="Abstract Base Class to describe the scattering power of any Scatterer component in a crystal...">ScatteringPower</a> for a spherical particule  
 <a href="a00092.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for ObjCryst::ScatteringPowerSphere:</div>
<div class="dyncontent">
 <div class="center">
  <img src="a00092.png" usemap="#ObjCryst::ScatteringPowerSphere_map" alt=""/>
  <map id="ObjCryst::ScatteringPowerSphere_map" name="ObjCryst::ScatteringPowerSphere_map">
<area href="a00090.html" title="Abstract Base Class to describe the scattering power of any Scatterer component in a crystal..." alt="ObjCryst::ScatteringPower" shape="rect" coords="0,56,202,80"/>
<area href="a00071.html" title="Generic Refinable Object." alt="ObjCryst::RefinableObj" shape="rect" coords="0,0,202,24"/>
</map>
 </div></div>

<p><a href="a00301.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2d28cd4a75be9b4f9f784329ed2401d6"></a><!-- doxytag: member="ObjCryst::ScatteringPowerSphere::ScatteringPowerSphere" ref="a2d28cd4a75be9b4f9f784329ed2401d6" args="()" -->
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00092.html#a2d28cd4a75be9b4f9f784329ed2401d6">ScatteringPowerSphere</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00092.html#a2d50cba1b4405f52f1dd4148907a88c5">ScatteringPowerSphere</a> (const string &amp;name, const REAL radius, const REAL bIso=1.0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor  <a href="#a2d50cba1b4405f52f1dd4148907a88c5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad5b2d4703250ae10fb27f8929a904d47"></a><!-- doxytag: member="ObjCryst::ScatteringPowerSphere::ScatteringPowerSphere" ref="ad5b2d4703250ae10fb27f8929a904d47" args="(const ScatteringPowerSphere &amp;old)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>ScatteringPowerSphere</b> (const <a class="el" href="a00092.html">ScatteringPowerSphere</a> &amp;old)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa6795f9a244597425863c410e40153f5"></a><!-- doxytag: member="ObjCryst::ScatteringPowerSphere::Init" ref="aa6795f9a244597425863c410e40153f5" args="(const string &amp;name, const REAL radius, const REAL bIso=1.0)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>Init</b> (const string &amp;name, const REAL radius, const REAL bIso=1.0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00092.html#a57e85d29926fe93da66041a43583e893">GetClassName</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Name for this class ("RefinableObj", "Crystal",...).  <a href="#a57e85d29926fe93da66041a43583e893"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual CrystVector_REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00092.html#a073f08b17ba89e0ac5ed8e1a61cb04fe">GetScatteringFactor</a> (const <a class="el" href="a00089.html">ScatteringData</a> &amp;data, const int spgSymPosIndex=0) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Scattering factor for all reflections of a given <a class="el" href="a00089.html" title="Class to compute structure factors for a set of reflections and a Crystal.">ScatteringData</a> object.  <a href="#a073f08b17ba89e0ac5ed8e1a61cb04fe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00092.html#a9bd142cc8112495d41393b4faffc4fcd">GetForwardScatteringFactor</a> (const <a class="el" href="a00171.html#a48fe50a094c607f8897378934d3d73ef">RadiationType</a>) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the scattering factor at (0,0,0).  <a href="#a9bd142cc8112495d41393b4faffc4fcd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual CrystVector_REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00092.html#a3927291a20f5807c2ec6a9ae3627005d">GetTemperatureFactor</a> (const <a class="el" href="a00089.html">ScatteringData</a> &amp;data, const int spgSymPosIndex=0) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the temperature factor for all reflections of a given <a class="el" href="a00089.html" title="Class to compute structure factors for a set of reflections and a Crystal.">ScatteringData</a> object.  <a href="#a3927291a20f5807c2ec6a9ae3627005d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual CrystMatrix_REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00092.html#a064671bfd711ef108be7a1528e52cd46">GetResonantScattFactReal</a> (const <a class="el" href="a00089.html">ScatteringData</a> &amp;data, const int spgSymPosIndex=0) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the real part of the resonant scattering factor.  <a href="#a064671bfd711ef108be7a1528e52cd46"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual CrystMatrix_REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00092.html#aee221744487a1c29023399b71e855c06">GetResonantScattFactImag</a> (const <a class="el" href="a00089.html">ScatteringData</a> &amp;data, const int spgSymPosIndex=0) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the imaginary part of the resonant scattering factor.  <a href="#aee221744487a1c29023399b71e855c06"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00092.html#a1f4b091f0990b959acb0645fd575a080">GetRadius</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the physical radius of this type of scatterer (for 3D display purposes).  <a href="#a1f4b091f0990b959acb0645fd575a080"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7e57e15bff5886955532dcacae65cf6c"></a><!-- doxytag: member="ObjCryst::ScatteringPowerSphere::Print" ref="a7e57e15bff5886955532dcacae65cf6c" args="() const " -->
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>Print</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00092.html#a050e8e8b21857ec0593bbb41fd123e39">XMLOutput</a> (ostream &amp;os, int indent=0) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Output to stream in well-formed XML.  <a href="#a050e8e8b21857ec0593bbb41fd123e39"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00092.html#aaaf687a105e65c6522521a0f01a98acf">XMLInput</a> (istream &amp;is, const <a class="el" href="a00151.html">XMLCrystTag</a> &amp;tag)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Input From stream.  <a href="#aaaf687a105e65c6522521a0f01a98acf"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab586ccb9566d5bc1d2d952eded4e1979"></a><!-- doxytag: member="ObjCryst::ScatteringPowerSphere::InitRefParList" ref="ab586ccb9566d5bc1d2d952eded4e1979" args="()" -->
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>InitRefParList</b> ()</td></tr>
<tr><td colspan="2"><h2><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a258a4384486392c2019a1e0ee83c1408"></a><!-- doxytag: member="ObjCryst::ScatteringPowerSphere::mBiso" ref="a258a4384486392c2019a1e0ee83c1408" args="" -->
REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00092.html#a258a4384486392c2019a1e0ee83c1408">mBiso</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Isotropic temperature B-factor. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a21d5b0449cb5c76b90f224cdacf3dc0d"></a><!-- doxytag: member="ObjCryst::ScatteringPowerSphere::mRadius" ref="a21d5b0449cb5c76b90f224cdacf3dc0d" args="" -->
REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00092.html#a21d5b0449cb5c76b90f224cdacf3dc0d">mRadius</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Radius of the sphere. <br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>\ brief <a class="el" href="a00090.html" title="Abstract Base Class to describe the scattering power of any Scatterer component in a crystal...">ScatteringPower</a> for a spherical particule </p>
<p>This can be used to modelize the form factor of disordered (or low-resolution) of fullerene-type compounds, where all atoms are located on a sphere.</p>
<p>This actually modelizes a spherical distribution of a <em>single</em> electron, so to modelize C60 the occupancy must be set to 60*6. </p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a2d50cba1b4405f52f1dd4148907a88c5"></a><!-- doxytag: member="ObjCryst::ScatteringPowerSphere::ScatteringPowerSphere" ref="a2d50cba1b4405f52f1dd4148907a88c5" args="(const string &amp;name, const REAL radius, const REAL bIso=1.0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00092.html#a2d28cd4a75be9b4f9f784329ed2401d6">ObjCryst::ScatteringPowerSphere::ScatteringPowerSphere</a> </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>bIso</em> = <code>1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>constructor </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>: name of the <a class="el" href="a00090.html" title="Abstract Base Class to describe the scattering power of any Scatterer component in a crystal...">ScatteringPower</a> ('C60','France 98'...). The name can have <em>any</em> format </td></tr>
    <tr><td class="paramname">nbAtom,:</td><td>the number of atoms </td></tr>
    <tr><td class="paramname">biso</td><td>: Isotropic thermic coefficient </td></tr>
    <tr><td class="paramname">AxisLengthX,AxisLengthY,AxisLengthZ,:</td><td>length of the different main axis of the ellipsoid </td></tr>
    <tr><td class="paramname">symbol,:</td><td>the symbol of the element associated to this fullerene. By default it is assumed to be carbon </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a57e85d29926fe93da66041a43583e893"></a><!-- doxytag: member="ObjCryst::ScatteringPowerSphere::GetClassName" ref="a57e85d29926fe93da66041a43583e893" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const string&amp; <a class="el" href="a00092.html#a57e85d29926fe93da66041a43583e893">ObjCryst::ScatteringPowerSphere::GetClassName</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Name for this class ("RefinableObj", "Crystal",...). </p>
<p>This is only useful to distinguish different classes when picking up objects from the <a class="el" href="a00071.html" title="Generic Refinable Object.">RefinableObj</a> Global Registry </p>

<p>Reimplemented from <a class="el" href="a00090.html#ac31cc4135011046f93d49f4173aee3ee">ObjCryst::ScatteringPower</a>.</p>

</div>
</div>
<a class="anchor" id="a9bd142cc8112495d41393b4faffc4fcd"></a><!-- doxytag: member="ObjCryst::ScatteringPowerSphere::GetForwardScatteringFactor" ref="a9bd142cc8112495d41393b4faffc4fcd" args="(const RadiationType) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual REAL <a class="el" href="a00092.html#a9bd142cc8112495d41393b4faffc4fcd">ObjCryst::ScatteringPowerSphere::GetForwardScatteringFactor</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00171.html#a48fe50a094c607f8897378934d3d73ef">RadiationType</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the scattering factor at (0,0,0). </p>
<p>Used for scatterer (electron, nucleus) density generation. </p>

<p>Implements <a class="el" href="a00090.html#a854b51b9b08e96af0fe7986fe372c50c">ObjCryst::ScatteringPower</a>.</p>

</div>
</div>
<a class="anchor" id="a1f4b091f0990b959acb0645fd575a080"></a><!-- doxytag: member="ObjCryst::ScatteringPowerSphere::GetRadius" ref="a1f4b091f0990b959acb0645fd575a080" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">REAL <a class="el" href="a00092.html#a1f4b091f0990b959acb0645fd575a080">ObjCryst::ScatteringPowerSphere::GetRadius</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the physical radius of this type of scatterer (for 3D display purposes). </p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>this may be removed later. </dd></dl>

<p>Implements <a class="el" href="a00090.html#ac44860aca21734844379ddec87622f7b">ObjCryst::ScatteringPower</a>.</p>

</div>
</div>
<a class="anchor" id="aee221744487a1c29023399b71e855c06"></a><!-- doxytag: member="ObjCryst::ScatteringPowerSphere::GetResonantScattFactImag" ref="aee221744487a1c29023399b71e855c06" args="(const ScatteringData &amp;data, const int spgSymPosIndex=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual CrystMatrix_REAL <a class="el" href="a00092.html#aee221744487a1c29023399b71e855c06">ObjCryst::ScatteringPowerSphere::GetResonantScattFactImag</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00089.html">ScatteringData</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>spgSymPosIndex</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the imaginary part of the resonant scattering factor. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a matrix where each row corresponds to each wavelength (currently only monochromatic experiments are made so there is only one row), and each column corresponds to each reflection <em>only</em> if the scattering term is anisotropic, which is not the case so far... </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data,:</td><td>the <a class="el" href="a00089.html" title="Class to compute structure factors for a set of reflections and a Crystal.">ScatteringData</a> object, giving access to all the reflections, and a list of wavelengths. </td></tr>
    <tr><td class="paramname">spgSymPosIndex,:</td><td>if the <a class="el" href="a00090.html" title="Abstract Base Class to describe the scattering power of any Scatterer component in a crystal...">ScatteringPower</a> is anisotropic, then the different symmetrics will not have the same scattering power for all reflections. This parameter is the index of the symmetric position in the Spacegroup. If spgSymPosIndex=-1, the isotropic values are returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>There is no anisotropic code yet, so spgSymPosIndex is simply ignored so far , but the design of this function is general for any anisotropic scattering. </dd></dl>

<p>Implements <a class="el" href="a00090.html#a9bc5d86bf76116f645b43d46f2a9771c">ObjCryst::ScatteringPower</a>.</p>

</div>
</div>
<a class="anchor" id="a064671bfd711ef108be7a1528e52cd46"></a><!-- doxytag: member="ObjCryst::ScatteringPowerSphere::GetResonantScattFactReal" ref="a064671bfd711ef108be7a1528e52cd46" args="(const ScatteringData &amp;data, const int spgSymPosIndex=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual CrystMatrix_REAL <a class="el" href="a00092.html#a064671bfd711ef108be7a1528e52cd46">ObjCryst::ScatteringPowerSphere::GetResonantScattFactReal</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00089.html">ScatteringData</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>spgSymPosIndex</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the real part of the resonant scattering factor. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a matrix where each row corresponds to each wavelength (currently only monochromatic experiments are made so there is only one row), and each column corresponds to each reflection <em>only</em> if the scattering term is anisotropic, which is not the case so far... </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data,:</td><td>the <a class="el" href="a00089.html" title="Class to compute structure factors for a set of reflections and a Crystal.">ScatteringData</a> object, giving access to all the reflections and a list of wavelengths). </td></tr>
    <tr><td class="paramname">spgSymPosIndex,:</td><td>if the <a class="el" href="a00090.html" title="Abstract Base Class to describe the scattering power of any Scatterer component in a crystal...">ScatteringPower</a> is anisotropic, then the different symmetrics will not have the same scattering power for all reflections. This parameter is the index of the symmetric position in the Spacegroup. If spgSymPosIndex=-1, the isotropic values are returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>There is no anisotropic code yet, so spgSymPosIndex is simply ignored so far , but the design of this function is general for any anisotropic scattering. </dd></dl>

<p>Implements <a class="el" href="a00090.html#a42c1302254787d13b9e0f2210315291a">ObjCryst::ScatteringPower</a>.</p>

</div>
</div>
<a class="anchor" id="a073f08b17ba89e0ac5ed8e1a61cb04fe"></a><!-- doxytag: member="ObjCryst::ScatteringPowerSphere::GetScatteringFactor" ref="a073f08b17ba89e0ac5ed8e1a61cb04fe" args="(const ScatteringData &amp;data, const int spgSymPosIndex=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual CrystVector_REAL <a class="el" href="a00092.html#a073f08b17ba89e0ac5ed8e1a61cb04fe">ObjCryst::ScatteringPowerSphere::GetScatteringFactor</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00089.html">ScatteringData</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>spgSymPosIndex</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the Scattering factor for all reflections of a given <a class="el" href="a00089.html" title="Class to compute structure factors for a set of reflections and a Crystal.">ScatteringData</a> object. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a vector with the scattering factor for all reflections, in the same order as in the <a class="el" href="a00089.html" title="Class to compute structure factors for a set of reflections and a Crystal.">ScatteringData</a> object. This format is independent of the radiation type (X-Ray, neutron..). </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data,:</td><td>the <a class="el" href="a00089.html" title="Class to compute structure factors for a set of reflections and a Crystal.">ScatteringData</a> object, giving access to all the reflections. </td></tr>
    <tr><td class="paramname">spgSymPosIndex,:</td><td>if the <a class="el" href="a00090.html" title="Abstract Base Class to describe the scattering power of any Scatterer component in a crystal...">ScatteringPower</a> is anisotropic, then the different symmetrics will not have the same scattering power for all reflections. This parameter is the index of the symmetric position in the Spacegroup. If spgSymPosIndex=-1, the isotropic values are returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>There is no anisotropic code yet, so spgSymPosIndex is simply ignored so far , but the design of this function is general for any anisotropic scattering. </dd></dl>

<p>Implements <a class="el" href="a00090.html#af18f3eaaf45af87bc3a2a0ff21bc34b6">ObjCryst::ScatteringPower</a>.</p>

</div>
</div>
<a class="anchor" id="a3927291a20f5807c2ec6a9ae3627005d"></a><!-- doxytag: member="ObjCryst::ScatteringPowerSphere::GetTemperatureFactor" ref="a3927291a20f5807c2ec6a9ae3627005d" args="(const ScatteringData &amp;data, const int spgSymPosIndex=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual CrystVector_REAL <a class="el" href="a00092.html#a3927291a20f5807c2ec6a9ae3627005d">ObjCryst::ScatteringPowerSphere::GetTemperatureFactor</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00089.html">ScatteringData</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>spgSymPosIndex</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the temperature factor for all reflections of a given <a class="el" href="a00089.html" title="Class to compute structure factors for a set of reflections and a Crystal.">ScatteringData</a> object. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a vector with the temperature factor for all reflections, in the same order as in the <a class="el" href="a00089.html" title="Class to compute structure factors for a set of reflections and a Crystal.">ScatteringData</a> object. </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data,:</td><td>the <a class="el" href="a00089.html" title="Class to compute structure factors for a set of reflections and a Crystal.">ScatteringData</a> object, giving access to all the reflections. </td></tr>
    <tr><td class="paramname">spgSymPosIndex,:</td><td>if the <a class="el" href="a00090.html" title="Abstract Base Class to describe the scattering power of any Scatterer component in a crystal...">ScatteringPower</a> is anisotropic, then the different symmetrics will not have the same scattering power for all reflections. This parameter is the index of the symmetric position in the Spacegroup. If spgSymPosIndex=-1, the isotropic values are returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>There is no anisotropic code yet, so spgSymPosIndex is simply ignored so far , but the design of this function is general for any anisotropic scattering. </dd></dl>

<p>Implements <a class="el" href="a00090.html#a3df723db77380c82ecff5f7050490255">ObjCryst::ScatteringPower</a>.</p>

</div>
</div>
<a class="anchor" id="aaaf687a105e65c6522521a0f01a98acf"></a><!-- doxytag: member="ObjCryst::ScatteringPowerSphere::XMLInput" ref="aaaf687a105e65c6522521a0f01a98acf" args="(istream &amp;is, const XMLCrystTag &amp;tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="a00092.html#aaaf687a105e65c6522521a0f01a98acf">ObjCryst::ScatteringPowerSphere::XMLInput</a> </td>
          <td>(</td>
          <td class="paramtype">istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00151.html">XMLCrystTag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Input From stream. </p>
<dl class="todo"><dt><b><a class="el" href="a00222.html#_todo000027">Todo:</a></b></dt><dd>Add an bool XMLInputTag(is,tag) function to recognize all the tags from the stream. So that each inherited class can use the XMLInputTag function from its parent (ie take advantage of inheritance). The children class would first try to interpret the tag, then if unsuccessful would pass it to its parent (thus allowing overloading), etc... </dd></dl>

<p>Reimplemented from <a class="el" href="a00071.html#ac13a4045c3f187879443c8615c38d623">ObjCryst::RefinableObj</a>.</p>

</div>
</div>
<a class="anchor" id="a050e8e8b21857ec0593bbb41fd123e39"></a><!-- doxytag: member="ObjCryst::ScatteringPowerSphere::XMLOutput" ref="a050e8e8b21857ec0593bbb41fd123e39" args="(ostream &amp;os, int indent=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="a00092.html#a050e8e8b21857ec0593bbb41fd123e39">ObjCryst::ScatteringPowerSphere::XMLOutput</a> </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>indent</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Output to stream in well-formed XML. </p>
<dl class="todo"><dt><b><a class="el" href="a00222.html#_todo000026">Todo:</a></b></dt><dd>Use inheritance.. as for XMLInputTag()... </dd></dl>

<p>Reimplemented from <a class="el" href="a00071.html#a7b9b6ed0f8dcf753d398c35e073de973">ObjCryst::RefinableObj</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>ScatteringPowerSphere.h</li>
</ul>
</div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Tue Apr 3 2012 18:20:01 for ObjCryst++ by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
