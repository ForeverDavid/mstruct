<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>ObjCryst++: ObjCryst::Molecule Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">ObjCryst++
   &#160;<span id="projectnumber">1.5CVS</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="a00171.html">ObjCryst</a></li><li class="navelem"><a class="el" href="a00047.html">Molecule</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="a00270.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ObjCryst::Molecule Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="a00047.html" title="Molecule : class for complex scatterer descriptions using cartesian coordinates with bond length/angl...">Molecule</a> : class for complex scatterer descriptions using cartesian coordinates with bond length/angle restraints, and moves either of individual atoms or using torsion bonds.  
 <a href="a00047.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for ObjCryst::Molecule:</div>
<div class="dyncontent">
 <div class="center">
  <img src="a00047.png" usemap="#ObjCryst::Molecule_map" alt=""/>
  <map id="ObjCryst::Molecule_map" name="ObjCryst::Molecule_map">
<area href="a00085.html" title="Generic type of scatterer: can be an atom, or a more complex assembly of atoms." alt="ObjCryst::Scatterer" shape="rect" coords="0,56,141,80"/>
<area href="a00071.html" title="Generic Refinable Object." alt="ObjCryst::RefinableObj" shape="rect" coords="0,0,141,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00027.html">FlipGroup</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">When 3(A1..1n) or more atoms are connected to a same atom A, it defines a 'flip' group, where it is possible to rotate bonds to their symmetric with respect to one plane defined by atoms Ai-A-Aj.  <a href="a00027.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00083.html">RotorGroup</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a group of atoms which can be rotated around an axis defined by two other atoms.  <a href="a00083.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00100.html">StretchModeGroup</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Group of concurrent StretchModes (affecting common restraints) A given stretch mode can only belong to one group.  <a href="a00100.html#details">More...</a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad4132a293e7f253c730676ed3720f961"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#ad4132a293e7f253c730676ed3720f961">Molecule</a> (<a class="el" href="a00020.html">Crystal</a> &amp;cryst, const string &amp;name=&quot;&quot;)</td></tr>
<tr class="memdesc:ad4132a293e7f253c730676ed3720f961"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#ad4132a293e7f253c730676ed3720f961"></a><br/></td></tr>
<tr class="memitem:a896c80a621aa990de3d36e214965cd49"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a896c80a621aa990de3d36e214965cd49">Molecule</a> (const <a class="el" href="a00047.html">Molecule</a> &amp;old)</td></tr>
<tr class="memdesc:a896c80a621aa990de3d36e214965cd49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#a896c80a621aa990de3d36e214965cd49"></a><br/></td></tr>
<tr class="memitem:ae61d3a9a72c73cd087e330b3c4cdf0be"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#ae61d3a9a72c73cd087e330b3c4cdf0be">~Molecule</a> ()</td></tr>
<tr class="memdesc:ae61d3a9a72c73cd087e330b3c4cdf0be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#ae61d3a9a72c73cd087e330b3c4cdf0be"></a><br/></td></tr>
<tr class="memitem:a96728865d25881151b7010d3eaf4ec0f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="a00047.html">Molecule</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a96728865d25881151b7010d3eaf4ec0f">CreateCopy</a> () const </td></tr>
<tr class="memitem:a7f0f1ae6670032f5afc9ccf65d45f8c4"><td class="memItemLeft" align="right" valign="top">virtual const string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a7f0f1ae6670032f5afc9ccf65d45f8c4">GetClassName</a> () const </td></tr>
<tr class="memdesc:a7f0f1ae6670032f5afc9ccf65d45f8c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name for this class ("RefinableObj", "Crystal",...).  <a href="#a7f0f1ae6670032f5afc9ccf65d45f8c4"></a><br/></td></tr>
<tr class="memitem:a5c4fde55689b7e76705d1f04005802c6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5c4fde55689b7e76705d1f04005802c6"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a5c4fde55689b7e76705d1f04005802c6">Print</a> () const </td></tr>
<tr class="memdesc:a5c4fde55689b7e76705d1f04005802c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print some info about the scatterer (ideally this should be one line...). <br/></td></tr>
<tr class="memitem:a47762abe37f3e8f7378b7210916e71ea"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a47762abe37f3e8f7378b7210916e71ea">XMLOutput</a> (ostream &amp;os, int indent=0) const </td></tr>
<tr class="memdesc:a47762abe37f3e8f7378b7210916e71ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output to stream in well-formed XML.  <a href="#a47762abe37f3e8f7378b7210916e71ea"></a><br/></td></tr>
<tr class="memitem:a701f78d93d495d1102d0bd26700c4a3d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a701f78d93d495d1102d0bd26700c4a3d">XMLInput</a> (istream &amp;is, const <a class="el" href="a00151.html">XMLCrystTag</a> &amp;tag)</td></tr>
<tr class="memdesc:a701f78d93d495d1102d0bd26700c4a3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Input From stream.  <a href="#a701f78d93d495d1102d0bd26700c4a3d"></a><br/></td></tr>
<tr class="memitem:af1ae2c4f9febbe16019987f807271b58"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#af1ae2c4f9febbe16019987f807271b58">UpdateDisplay</a> () const </td></tr>
<tr class="memdesc:af1ae2c4f9febbe16019987f807271b58"><td class="mdescLeft">&#160;</td><td class="mdescRight">If there is an interface, this should be automatically be called each time there is a 'new, significant' configuration to report.  <a href="#af1ae2c4f9febbe16019987f807271b58"></a><br/></td></tr>
<tr class="memitem:a5fbdadb37966f382a6e33150285819dc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a5fbdadb37966f382a6e33150285819dc">BeginOptimization</a> (const bool allowApproximations=false, const bool enableRestraints=false)</td></tr>
<tr class="memdesc:a5fbdadb37966f382a6e33150285819dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This should be called by any optimization class at the begining of an optimization.  <a href="#a5fbdadb37966f382a6e33150285819dc"></a><br/></td></tr>
<tr class="memitem:aec0a3ba0d08fdfed38cc757efb635ffb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#aec0a3ba0d08fdfed38cc757efb635ffb">EndOptimization</a> ()</td></tr>
<tr class="memdesc:aec0a3ba0d08fdfed38cc757efb635ffb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This should be called by any optimization class at the end of an optimization.  <a href="#aec0a3ba0d08fdfed38cc757efb635ffb"></a><br/></td></tr>
<tr class="memitem:aaa76da93619174b17db73de9d2374ac7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#aaa76da93619174b17db73de9d2374ac7">RandomizeConfiguration</a> ()</td></tr>
<tr class="memdesc:aaa76da93619174b17db73de9d2374ac7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Randomize Configuration (before a global optimization).  <a href="#aaa76da93619174b17db73de9d2374ac7"></a><br/></td></tr>
<tr class="memitem:a11e623f6482b468f6dd05fc0ab2bbb24"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a11e623f6482b468f6dd05fc0ab2bbb24">GlobalOptRandomMove</a> (const REAL mutationAmplitude, const <a class="el" href="a00080.html">RefParType</a> *type)</td></tr>
<tr class="memdesc:a11e623f6482b468f6dd05fc0ab2bbb24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a random move of the current configuration.  <a href="#a11e623f6482b468f6dd05fc0ab2bbb24"></a><br/></td></tr>
<tr class="memitem:a1c0e8ad2410035c07c4be88315554f3f"><td class="memItemLeft" align="right" valign="top">virtual REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a1c0e8ad2410035c07c4be88315554f3f">GetLogLikelihood</a> () const </td></tr>
<tr class="memdesc:a1c0e8ad2410035c07c4be88315554f3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get -log(likelihood) of the current configuration for the object.  <a href="#a1c0e8ad2410035c07c4be88315554f3f"></a><br/></td></tr>
<tr class="memitem:a1496167f3d3eae46a1f1eb49110808ce"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1496167f3d3eae46a1f1eb49110808ce"></a>
virtual unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a1496167f3d3eae46a1f1eb49110808ce">GetNbLSQFunction</a> () const </td></tr>
<tr class="memdesc:a1496167f3d3eae46a1f1eb49110808ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of LSQ functions. <br/></td></tr>
<tr class="memitem:ab9b0b6172128e4aae0aa4a26e9024550"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab9b0b6172128e4aae0aa4a26e9024550"></a>
virtual const CrystVector_REAL &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#ab9b0b6172128e4aae0aa4a26e9024550">GetLSQCalc</a> (const unsigned int) const </td></tr>
<tr class="memdesc:ab9b0b6172128e4aae0aa4a26e9024550"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current calculated value for the LSQ function. <br/></td></tr>
<tr class="memitem:a044e12d7bd85fc13552ce3ef24776af5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a044e12d7bd85fc13552ce3ef24776af5"></a>
virtual const CrystVector_REAL &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a044e12d7bd85fc13552ce3ef24776af5">GetLSQObs</a> (const unsigned int) const </td></tr>
<tr class="memdesc:a044e12d7bd85fc13552ce3ef24776af5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the observed values for the LSQ function. <br/></td></tr>
<tr class="memitem:ac4c7e12b5f9ed0ddfeddd68e85291a17"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac4c7e12b5f9ed0ddfeddd68e85291a17"></a>
virtual const CrystVector_REAL &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#ac4c7e12b5f9ed0ddfeddd68e85291a17">GetLSQWeight</a> (const unsigned int) const </td></tr>
<tr class="memdesc:ac4c7e12b5f9ed0ddfeddd68e85291a17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the weight values for the LSQ function. <br/></td></tr>
<tr class="memitem:adef00ca72bec0e4553bbfba0852e1ba1"><td class="memItemLeft" align="right" valign="top">virtual const CrystVector_REAL &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#adef00ca72bec0e4553bbfba0852e1ba1">GetLSQDeriv</a> (const unsigned int n, <a class="el" href="a00073.html">RefinablePar</a> &amp;par)</td></tr>
<tr class="memdesc:adef00ca72bec0e4553bbfba0852e1ba1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the first derivative values for the LSQ function, for a given parameter.  <a href="#adef00ca72bec0e4553bbfba0852e1ba1"></a><br/></td></tr>
<tr class="memitem:a91e2f80f1e4526fbb6cd99f5b229db9e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a91e2f80f1e4526fbb6cd99f5b229db9e">TagNewBestConfig</a> () const </td></tr>
<tr class="memdesc:a91e2f80f1e4526fbb6cd99f5b229db9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">During a global optimization, tells the object that the current config is the latest "best" config.  <a href="#a91e2f80f1e4526fbb6cd99f5b229db9e"></a><br/></td></tr>
<tr class="memitem:a8787cb87d65117d40a595162cdab141e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8787cb87d65117d40a595162cdab141e"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a8787cb87d65117d40a595162cdab141e">GetNbComponent</a> () const </td></tr>
<tr class="memdesc:a8787cb87d65117d40a595162cdab141e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of components in the scatterer (eg number of point scatterers) <br/></td></tr>
<tr class="memitem:a3ac17bd45a709c82d9a4d304fde09b88"><td class="memItemLeft" align="right" valign="top">virtual const <br class="typebreak"/>
<a class="el" href="a00087.html">ScatteringComponentList</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a3ac17bd45a709c82d9a4d304fde09b88">GetScatteringComponentList</a> () const </td></tr>
<tr class="memdesc:a3ac17bd45a709c82d9a4d304fde09b88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the list of all scattering components for this scatterer.  <a href="#a3ac17bd45a709c82d9a4d304fde09b88"></a><br/></td></tr>
<tr class="memitem:a8dae19447740afaa1780e39a61f625c9"><td class="memItemLeft" align="right" valign="top">virtual string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a8dae19447740afaa1780e39a61f625c9">GetComponentName</a> (const int i) const </td></tr>
<tr class="memdesc:a8dae19447740afaa1780e39a61f625c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name for the i-th component of this scatterer.  <a href="#a8dae19447740afaa1780e39a61f625c9"></a><br/></td></tr>
<tr class="memitem:a98bd83a14b359c994be9ab1bf4b8453b"><td class="memItemLeft" align="right" valign="top">virtual ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a98bd83a14b359c994be9ab1bf4b8453b">POVRayDescription</a> (ostream &amp;os, const <a class="el" href="a00021.html">CrystalPOVRayOptions</a> &amp;options) const </td></tr>
<tr class="memitem:a00aa7620326d8663b1f4e1bd9237ffb8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a00aa7620326d8663b1f4e1bd9237ffb8">GLInitDisplayList</a> (const bool onlyIndependentAtoms=false, const REAL xMin=-.1, const REAL xMax=1.1, const REAL yMin=-.1, const REAL yMax=1.1, const REAL zMin=-.1, const REAL zMax=1.1, const bool displayEnantiomer=false, const bool displayNames=false) const </td></tr>
<tr class="memitem:a7b193eac062233b758887cba671706f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a7b193eac062233b758887cba671706f7">AddAtom</a> (const REAL x, const REAL y, const REAL z, const <a class="el" href="a00090.html">ScatteringPower</a> *pPow, const string &amp;name, const bool updateDisplay=true)</td></tr>
<tr class="memdesc:a7b193eac062233b758887cba671706f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an atom.  <a href="#a7b193eac062233b758887cba671706f7"></a><br/></td></tr>
<tr class="memitem:a7d3d1e583bc7d4beb1a8a6c7f74b4811"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="a00043.html">MolAtom</a> * &gt;::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a7d3d1e583bc7d4beb1a8a6c7f74b4811">RemoveAtom</a> (<a class="el" href="a00043.html">MolAtom</a> &amp;, const bool del=true)</td></tr>
<tr class="memdesc:a7d3d1e583bc7d4beb1a8a6c7f74b4811"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove an atom.  <a href="#a7d3d1e583bc7d4beb1a8a6c7f74b4811"></a><br/></td></tr>
<tr class="memitem:aa37feb3abde7ca0ff6453b97d910800f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#aa37feb3abde7ca0ff6453b97d910800f">AddBond</a> (<a class="el" href="a00043.html">MolAtom</a> &amp;atom1, <a class="el" href="a00043.html">MolAtom</a> &amp;atom2, const REAL length, const REAL sigma, const REAL delta, const REAL bondOrder=1., const bool updateDisplay=true)</td></tr>
<tr class="memdesc:aa37feb3abde7ca0ff6453b97d910800f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a bond.  <a href="#aa37feb3abde7ca0ff6453b97d910800f"></a><br/></td></tr>
<tr class="memitem:ad7cc4b6b9eec26f396fc30c517f37e24"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="a00044.html">MolBond</a> * &gt;::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#ad7cc4b6b9eec26f396fc30c517f37e24">RemoveBond</a> (const <a class="el" href="a00044.html">MolBond</a> &amp;, const bool del=true)</td></tr>
<tr class="memdesc:ad7cc4b6b9eec26f396fc30c517f37e24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a bond.  <a href="#ad7cc4b6b9eec26f396fc30c517f37e24"></a><br/></td></tr>
<tr class="memitem:ac121a84c148439786581a103eef4d958"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="a00044.html">MolBond</a> * &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#ac121a84c148439786581a103eef4d958">FindBond</a> (const <a class="el" href="a00043.html">MolAtom</a> &amp;, const <a class="el" href="a00043.html">MolAtom</a> &amp;) const </td></tr>
<tr class="memdesc:ac121a84c148439786581a103eef4d958"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches whether a bond between two atoms already exists.  <a href="#ac121a84c148439786581a103eef4d958"></a><br/></td></tr>
<tr class="memitem:a099aadd8edb91f148a174333b1636fb5"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="a00044.html">MolBond</a> * &gt;::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a099aadd8edb91f148a174333b1636fb5">FindBond</a> (const <a class="el" href="a00043.html">MolAtom</a> &amp;, const <a class="el" href="a00043.html">MolAtom</a> &amp;)</td></tr>
<tr class="memdesc:a099aadd8edb91f148a174333b1636fb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches whether a bond between two atoms already exists.  <a href="#a099aadd8edb91f148a174333b1636fb5"></a><br/></td></tr>
<tr class="memitem:a25132c259da4d0bd739ff0ffc008575e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a25132c259da4d0bd739ff0ffc008575e">AddBondAngle</a> (<a class="el" href="a00043.html">MolAtom</a> &amp;atom1, <a class="el" href="a00043.html">MolAtom</a> &amp;atom2, <a class="el" href="a00043.html">MolAtom</a> &amp;atom3, const REAL angle, const REAL sigma, const REAL delta, const bool updateDisplay=true)</td></tr>
<tr class="memdesc:a25132c259da4d0bd739ff0ffc008575e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a bond angle restraint.  <a href="#a25132c259da4d0bd739ff0ffc008575e"></a><br/></td></tr>
<tr class="memitem:a113af00d52a1cc225803865a82f35512"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="a00045.html">MolBondAngle</a> * &gt;::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a113af00d52a1cc225803865a82f35512">RemoveBondAngle</a> (const <a class="el" href="a00045.html">MolBondAngle</a> &amp;, const bool del=true)</td></tr>
<tr class="memdesc:a113af00d52a1cc225803865a82f35512"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a BondAngle.  <a href="#a113af00d52a1cc225803865a82f35512"></a><br/></td></tr>
<tr class="memitem:aa94113e3d0ca15f5a3acbc573198fd59"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="a00045.html">MolBondAngle</a> * &gt;<br class="typebreak"/>
::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#aa94113e3d0ca15f5a3acbc573198fd59">FindBondAngle</a> (const <a class="el" href="a00043.html">MolAtom</a> &amp;at1, const <a class="el" href="a00043.html">MolAtom</a> &amp;at0, const <a class="el" href="a00043.html">MolAtom</a> &amp;at2) const </td></tr>
<tr class="memdesc:aa94113e3d0ca15f5a3acbc573198fd59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches whether a bond between three atoms already exists, searching for either (at1,at2,at3) and (at3,at2,at1), as these are equivalent.  <a href="#aa94113e3d0ca15f5a3acbc573198fd59"></a><br/></td></tr>
<tr class="memitem:aae30adce9fdd16e42cab4f8e434f01cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#aae30adce9fdd16e42cab4f8e434f01cf">AddDihedralAngle</a> (<a class="el" href="a00043.html">MolAtom</a> &amp;atom1, <a class="el" href="a00043.html">MolAtom</a> &amp;atom2, <a class="el" href="a00043.html">MolAtom</a> &amp;atom3, <a class="el" href="a00043.html">MolAtom</a> &amp;atom4, const REAL angle, const REAL sigma, const REAL delta, const bool updateDisplay=true)</td></tr>
<tr class="memdesc:aae30adce9fdd16e42cab4f8e434f01cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a dihedral angle restraint.  <a href="#aae30adce9fdd16e42cab4f8e434f01cf"></a><br/></td></tr>
<tr class="memitem:a3f95dc9df0a1547b07854773179d28be"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="a00046.html">MolDihedralAngle</a> * &gt;<br class="typebreak"/>
::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a3f95dc9df0a1547b07854773179d28be">RemoveDihedralAngle</a> (const <a class="el" href="a00046.html">MolDihedralAngle</a> &amp;, const bool del=true)</td></tr>
<tr class="memdesc:a3f95dc9df0a1547b07854773179d28be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a dihedral angle.  <a href="#a3f95dc9df0a1547b07854773179d28be"></a><br/></td></tr>
<tr class="memitem:adb251aaa9a4f9e4e1b7e949e2fab73e4"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="a00046.html">MolDihedralAngle</a> * &gt;<br class="typebreak"/>
::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#adb251aaa9a4f9e4e1b7e949e2fab73e4">FindDihedralAngle</a> (const <a class="el" href="a00043.html">MolAtom</a> &amp;at1, const <a class="el" href="a00043.html">MolAtom</a> &amp;at2, const <a class="el" href="a00043.html">MolAtom</a> &amp;at3, const <a class="el" href="a00043.html">MolAtom</a> &amp;at4) const </td></tr>
<tr class="memdesc:adb251aaa9a4f9e4e1b7e949e2fab73e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches whether a dihedral between four atoms already exists, searching for either (at1,at2,at3,at4) and (at4,at3,at2,at1), as these are equivalent.  <a href="#adb251aaa9a4f9e4e1b7e949e2fab73e4"></a><br/></td></tr>
<tr class="memitem:a8c61827ad3303aca5c0db6698a5f9e06"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a8c61827ad3303aca5c0db6698a5f9e06">AddRigidGroup</a> (const <a class="el" href="a00082.html">RigidGroup</a> &amp;, const bool updateDisplay=true)</td></tr>
<tr class="memdesc:a8c61827ad3303aca5c0db6698a5f9e06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a rigid group of atoms.  <a href="#a8c61827ad3303aca5c0db6698a5f9e06"></a><br/></td></tr>
<tr class="memitem:a0a2c86a36111f22e07356cac6364632a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="a00082.html">RigidGroup</a> * &gt;<br class="typebreak"/>
::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a0a2c86a36111f22e07356cac6364632a">RemoveRigidGroup</a> (const <a class="el" href="a00082.html">RigidGroup</a> &amp;group, const bool updateDisplay=true, const bool del=true)</td></tr>
<tr class="memdesc:a0a2c86a36111f22e07356cac6364632a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a rigid group of atoms.  <a href="#a0a2c86a36111f22e07356cac6364632a"></a><br/></td></tr>
<tr class="memitem:a0fc6f489b5ca70ec72f0968068c409d7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0fc6f489b5ca70ec72f0968068c409d7"></a>
<a class="el" href="a00043.html">MolAtom</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>GetAtom</b> (unsigned int i)</td></tr>
<tr class="memitem:a73cd31a5e84043b21878c8e6131f528a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a73cd31a5e84043b21878c8e6131f528a"></a>
const <a class="el" href="a00043.html">MolAtom</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>GetAtom</b> (unsigned int i) const </td></tr>
<tr class="memitem:a7532113b6b8d93659e319883bd709cbc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7532113b6b8d93659e319883bd709cbc"></a>
<a class="el" href="a00043.html">MolAtom</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>GetAtom</b> (const string &amp;name)</td></tr>
<tr class="memitem:ace9ed3d2234a31be6f44d560e99edd14"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ace9ed3d2234a31be6f44d560e99edd14"></a>
const <a class="el" href="a00043.html">MolAtom</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>GetAtom</b> (const string &amp;name) const </td></tr>
<tr class="memitem:a20b6239624acf37e771e29c002f63618"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="a00043.html">MolAtom</a> * &gt;<br class="typebreak"/>
::reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a20b6239624acf37e771e29c002f63618">FindAtom</a> (const string &amp;name)</td></tr>
<tr class="memdesc:a20b6239624acf37e771e29c002f63618"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search a <a class="el" href="a00043.html" title="MolAtom : atom inside a Molecule.">MolAtom</a> from its name.  <a href="#a20b6239624acf37e771e29c002f63618"></a><br/></td></tr>
<tr class="memitem:a10cb2cff89dd623e288cfa3376acfcfa"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="a00043.html">MolAtom</a> * &gt;<br class="typebreak"/>
::const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a10cb2cff89dd623e288cfa3376acfcfa">FindAtom</a> (const string &amp;name) const </td></tr>
<tr class="memdesc:a10cb2cff89dd623e288cfa3376acfcfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search a <a class="el" href="a00043.html" title="MolAtom : atom inside a Molecule.">MolAtom</a> from its name.  <a href="#a10cb2cff89dd623e288cfa3376acfcfa"></a><br/></td></tr>
<tr class="memitem:a8e070563a06e9c375b3b26d2e5828c54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a8e070563a06e9c375b3b26d2e5828c54">OptimizeConformation</a> (const long nbTrial=10000, const REAL stopCost=0.)</td></tr>
<tr class="memdesc:a8e070563a06e9c375b3b26d2e5828c54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimize configuration from internal restraints (bond lengths, angles and dihedral angles).  <a href="#a8e070563a06e9c375b3b26d2e5828c54"></a><br/></td></tr>
<tr class="memitem:ac275665ed11daea220ef37154b39bf0d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#ac275665ed11daea220ef37154b39bf0d">OptimizeConformationSteepestDescent</a> (const REAL maxStep=0.1, const unsigned nbStep=1)</td></tr>
<tr class="memdesc:ac275665ed11daea220ef37154b39bf0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optimize the conformation from internal restraints (bond lengths, angles and dihedral angles), using a steepest descent algorithm.  <a href="#ac275665ed11daea220ef37154b39bf0d"></a><br/></td></tr>
<tr class="memitem:a9a43c803d62dc4f5f3b7852bbd75c939"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a9a43c803d62dc4f5f3b7852bbd75c939">MolecularDynamicsEvolve</a> (std::map&lt; <a class="el" href="a00043.html">MolAtom</a> *, <a class="el" href="a00152.html">XYZ</a> &gt; &amp;v0, const unsigned nbStep, const REAL dt, const std::vector&lt; <a class="el" href="a00044.html">MolBond</a> * &gt; &amp;vb, const std::vector&lt; <a class="el" href="a00045.html">MolBondAngle</a> * &gt; &amp;va, const std::vector&lt; <a class="el" href="a00046.html">MolDihedralAngle</a> * &gt; &amp;vd, std::map&lt; <a class="el" href="a00082.html">RigidGroup</a> *, std::pair&lt; <a class="el" href="a00152.html">XYZ</a>, <a class="el" href="a00152.html">XYZ</a> &gt; &gt; &amp;vr, REAL nrj0=0)</td></tr>
<tr class="memdesc:a9a43c803d62dc4f5f3b7852bbd75c939"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the conformation of the molecule using molecular dynamics principles.  <a href="#a9a43c803d62dc4f5f3b7852bbd75c939"></a><br/></td></tr>
<tr class="memitem:a61a315fb7ee03b2a96864342fe4600c5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a61a315fb7ee03b2a96864342fe4600c5"></a>
const std::vector&lt; <a class="el" href="a00043.html">MolAtom</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>GetAtomList</b> () const </td></tr>
<tr class="memitem:a275e909fe6ba8357e29b979f6840005c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a275e909fe6ba8357e29b979f6840005c"></a>
const std::vector&lt; <a class="el" href="a00044.html">MolBond</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>GetBondList</b> () const </td></tr>
<tr class="memitem:a3282f5961beef5a6369f4aa70d6272b7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3282f5961beef5a6369f4aa70d6272b7"></a>
const std::vector<br class="typebreak"/>
&lt; <a class="el" href="a00045.html">MolBondAngle</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>GetBondAngleList</b> () const </td></tr>
<tr class="memitem:a95389aeb48405b4b4772c69e5edd9499"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a95389aeb48405b4b4772c69e5edd9499"></a>
const std::vector<br class="typebreak"/>
&lt; <a class="el" href="a00046.html">MolDihedralAngle</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>GetDihedralAngleList</b> () const </td></tr>
<tr class="memitem:af437a692e431372f8bdb37d23baf97f4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af437a692e431372f8bdb37d23baf97f4"></a>
std::vector&lt; <a class="el" href="a00043.html">MolAtom</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>GetAtomList</b> ()</td></tr>
<tr class="memitem:a900e3d7d54b7d8481f5c24665a3dda3b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a900e3d7d54b7d8481f5c24665a3dda3b"></a>
std::vector&lt; <a class="el" href="a00044.html">MolBond</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>GetBondList</b> ()</td></tr>
<tr class="memitem:a66bce84293ff7457a68878281dea862a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a66bce84293ff7457a68878281dea862a"></a>
std::vector&lt; <a class="el" href="a00045.html">MolBondAngle</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>GetBondAngleList</b> ()</td></tr>
<tr class="memitem:a145da462c88c4859e3656872427dbdd4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a145da462c88c4859e3656872427dbdd4"></a>
std::vector&lt; <a class="el" href="a00046.html">MolDihedralAngle</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>GetDihedralAngleList</b> ()</td></tr>
<tr class="memitem:a2bde766df8213037d92110e1d61404e5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2bde766df8213037d92110e1d61404e5"></a>
std::list<br class="typebreak"/>
&lt; <a class="el" href="a00099.html">StretchModeBondLength</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>GetStretchModeBondLengthList</b> ()</td></tr>
<tr class="memitem:a3c84c2ee25cd4207b3b0033421382d5d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3c84c2ee25cd4207b3b0033421382d5d"></a>
std::list&lt; <a class="el" href="a00098.html">StretchModeBondAngle</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>GetStretchModeBondAngleList</b> ()</td></tr>
<tr class="memitem:aef5aa02c67aef3248c36c86719dd0f75"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aef5aa02c67aef3248c36c86719dd0f75"></a>
std::list&lt; <a class="el" href="a00101.html">StretchModeTorsion</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>GetStretchModeTorsionList</b> ()</td></tr>
<tr class="memitem:a07fa91c73992177983dc99bab7acd61c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a07fa91c73992177983dc99bab7acd61c"></a>
const std::list<br class="typebreak"/>
&lt; <a class="el" href="a00099.html">StretchModeBondLength</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>GetStretchModeBondLengthList</b> () const </td></tr>
<tr class="memitem:a60e4c6791d3f45cb18e9895ac272a673"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a60e4c6791d3f45cb18e9895ac272a673"></a>
const std::list<br class="typebreak"/>
&lt; <a class="el" href="a00098.html">StretchModeBondAngle</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>GetStretchModeBondAngleList</b> () const </td></tr>
<tr class="memitem:a5b08fa7fb5aff3a909e9c836cce6e8ad"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5b08fa7fb5aff3a909e9c836cce6e8ad"></a>
const std::list<br class="typebreak"/>
&lt; <a class="el" href="a00101.html">StretchModeTorsion</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>GetStretchModeTorsionList</b> () const </td></tr>
<tr class="memitem:aa0e2192321dc993ba78fb84d7502e2eb"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="a00082.html">RigidGroup</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#aa0e2192321dc993ba78fb84d7502e2eb">GetRigidGroupList</a> () const </td></tr>
<tr class="memdesc:aa0e2192321dc993ba78fb84d7502e2eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of rigid group of atoms.  <a href="#aa0e2192321dc993ba78fb84d7502e2eb"></a><br/></td></tr>
<tr class="memitem:afab17b6b5416c25a1a89b492017a590c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="a00082.html">RigidGroup</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#afab17b6b5416c25a1a89b492017a590c">GetRigidGroupList</a> ()</td></tr>
<tr class="memdesc:afab17b6b5416c25a1a89b492017a590c"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of rigid group of atoms.  <a href="#afab17b6b5416c25a1a89b492017a590c"></a><br/></td></tr>
<tr class="memitem:a9bd595a0ad88d6832718f3bffb452866"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a9bd595a0ad88d6832718f3bffb452866">RotateAtomGroup</a> (const <a class="el" href="a00043.html">MolAtom</a> &amp;at1, const <a class="el" href="a00043.html">MolAtom</a> &amp;at2, const set&lt; <a class="el" href="a00043.html">MolAtom</a> * &gt; &amp;atoms, const REAL angle, const bool keepCenter=true)</td></tr>
<tr class="memdesc:a9bd595a0ad88d6832718f3bffb452866"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate a group of atoms around an axis defined by two atoms.  <a href="#a9bd595a0ad88d6832718f3bffb452866"></a><br/></td></tr>
<tr class="memitem:a84e93db5b81b90fd5befa22caaf8691c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a84e93db5b81b90fd5befa22caaf8691c">RotateAtomGroup</a> (const <a class="el" href="a00043.html">MolAtom</a> &amp;at, const REAL vx, const REAL vy, const REAL vz, const set&lt; <a class="el" href="a00043.html">MolAtom</a> * &gt; &amp;atoms, const REAL angle, const bool keepCenter=true)</td></tr>
<tr class="memdesc:a84e93db5b81b90fd5befa22caaf8691c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate a group of atoms around an axis defined by one atom and a vector.  <a href="#a84e93db5b81b90fd5befa22caaf8691c"></a><br/></td></tr>
<tr class="memitem:a0d3122b53dd81aa23d2aaa2427e6291e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a0d3122b53dd81aa23d2aaa2427e6291e">TranslateAtomGroup</a> (const set&lt; <a class="el" href="a00043.html">MolAtom</a> * &gt; &amp;atoms, const REAL dx, const REAL dy, const REAL dz, const bool keepCenter=true)</td></tr>
<tr class="memdesc:a0d3122b53dd81aa23d2aaa2427e6291e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate a group of atoms in a given direction.  <a href="#a0d3122b53dd81aa23d2aaa2427e6291e"></a><br/></td></tr>
<tr class="memitem:ae7311bdcb3ce15284228bfa2ab140e86"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae7311bdcb3ce15284228bfa2ab140e86"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#ae7311bdcb3ce15284228bfa2ab140e86">RestraintStatus</a> (ostream &amp;os) const </td></tr>
<tr class="memdesc:ae7311bdcb3ce15284228bfa2ab140e86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the status of all restraints (bond length, angles...) <br/></td></tr>
<tr class="memitem:ac558aa9940aec9e33ae710fb45b3d156"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac558aa9940aec9e33ae710fb45b3d156"></a>
const map&lt; <a class="el" href="a00043.html">MolAtom</a> *, set<br class="typebreak"/>
&lt; <a class="el" href="a00043.html">MolAtom</a> * &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#ac558aa9940aec9e33ae710fb45b3d156">GetConnectivityTable</a> ()</td></tr>
<tr class="memdesc:ac558aa9940aec9e33ae710fb45b3d156"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the connectivity table. <br/></td></tr>
<tr class="memitem:a5ab539b95ffd60978ae7545ec10cc85b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5ab539b95ffd60978ae7545ec10cc85b"></a>
<a class="el" href="a00072.html">RefinableObjClock</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a5ab539b95ffd60978ae7545ec10cc85b">GetBondListClock</a> ()</td></tr>
<tr class="memdesc:a5ab539b95ffd60978ae7545ec10cc85b"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the clock associated to the list of bonds <br/></td></tr>
<tr class="memitem:ac754cabe98638a6f9efd0bf63a667c03"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac754cabe98638a6f9efd0bf63a667c03"></a>
const <a class="el" href="a00072.html">RefinableObjClock</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#ac754cabe98638a6f9efd0bf63a667c03">GetBondListClock</a> () const </td></tr>
<tr class="memdesc:ac754cabe98638a6f9efd0bf63a667c03"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the clock associated to the list of bonds <br/></td></tr>
<tr class="memitem:a46f35ddb18b731cfbb104d45ed96cdc7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a46f35ddb18b731cfbb104d45ed96cdc7"></a>
<a class="el" href="a00072.html">RefinableObjClock</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a46f35ddb18b731cfbb104d45ed96cdc7">GetAtomPositionClock</a> ()</td></tr>
<tr class="memdesc:a46f35ddb18b731cfbb104d45ed96cdc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the clock associated to the atomic positions. <br/></td></tr>
<tr class="memitem:a8c0a4e5e8fbdd2190c2838be9d4ea42e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8c0a4e5e8fbdd2190c2838be9d4ea42e"></a>
const <a class="el" href="a00072.html">RefinableObjClock</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a8c0a4e5e8fbdd2190c2838be9d4ea42e">GetAtomPositionClock</a> () const </td></tr>
<tr class="memdesc:a8c0a4e5e8fbdd2190c2838be9d4ea42e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the clock associated to the atomic positions. <br/></td></tr>
<tr class="memitem:a5d5be56a81d49a3e067957b6e959b477"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5d5be56a81d49a3e067957b6e959b477"></a>
<a class="el" href="a00072.html">RefinableObjClock</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a5d5be56a81d49a3e067957b6e959b477">GetRigidGroupClock</a> ()</td></tr>
<tr class="memdesc:a5d5be56a81d49a3e067957b6e959b477"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the clock associated to the list of rigid groups (clicked also whenever a rigid group is modified) <br/></td></tr>
<tr class="memitem:ae6b950305c66f518df22e52eb6e1661a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae6b950305c66f518df22e52eb6e1661a"></a>
const <a class="el" href="a00072.html">RefinableObjClock</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#ae6b950305c66f518df22e52eb6e1661a">GetRigidGroupClock</a> () const </td></tr>
<tr class="memdesc:ae6b950305c66f518df22e52eb6e1661a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the clock associated to the list of rigid groups (clicked also whenever a rigid group is modified) <br/></td></tr>
<tr class="memitem:a560c9ffc36d4874b99eb26c198ee485f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a560c9ffc36d4874b99eb26c198ee485f">RigidifyWithDihedralAngles</a> ()</td></tr>
<tr class="memdesc:a560c9ffc36d4874b99eb26c198ee485f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add dihedral angles so as to rigidify the <a class="el" href="a00047.html" title="Molecule : class for complex scatterer descriptions using cartesian coordinates with bond length/angl...">Molecule</a>.  <a href="#a560c9ffc36d4874b99eb26c198ee485f"></a><br/></td></tr>
<tr class="memitem:ad7bfddcdf21c1214c5a70c84fc54cdb0"><td class="memItemLeft" align="right" valign="top">REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#ad7bfddcdf21c1214c5a70c84fc54cdb0">BondLengthRandomChange</a> (const <a class="el" href="a00099.html">StretchModeBondLength</a> &amp;mode, const REAL amplitude, const bool respectRestraint=true)</td></tr>
<tr class="memdesc:ad7bfddcdf21c1214c5a70c84fc54cdb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stretch a bond, while respecting the <a class="el" href="a00081.html" title="Restraint: generic class for a restraint of a given model.">Restraint</a> (if any).  <a href="#ad7bfddcdf21c1214c5a70c84fc54cdb0"></a><br/></td></tr>
<tr class="memitem:ad6e27c1557962b32355eeadf1bf155d3"><td class="memItemLeft" align="right" valign="top">REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#ad6e27c1557962b32355eeadf1bf155d3">BondAngleRandomChange</a> (const <a class="el" href="a00098.html">StretchModeBondAngle</a> &amp;mode, const REAL amplitude, const bool respectRestraint=true)</td></tr>
<tr class="memdesc:ad6e27c1557962b32355eeadf1bf155d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">change a bond angle, while respecting the <a class="el" href="a00081.html" title="Restraint: generic class for a restraint of a given model.">Restraint</a> (if any).  <a href="#ad6e27c1557962b32355eeadf1bf155d3"></a><br/></td></tr>
<tr class="memitem:afd88ae76ab528b5dc37f9d2527353904"><td class="memItemLeft" align="right" valign="top">REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#afd88ae76ab528b5dc37f9d2527353904">DihedralAngleRandomChange</a> (const <a class="el" href="a00101.html">StretchModeTorsion</a> &amp;mode, const REAL amplitude, const bool respectRestraint=true)</td></tr>
<tr class="memdesc:afd88ae76ab528b5dc37f9d2527353904"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change a dihedral angle, while respecting the <a class="el" href="a00081.html" title="Restraint: generic class for a restraint of a given model.">Restraint</a> (if any).  <a href="#afd88ae76ab528b5dc37f9d2527353904"></a><br/></td></tr>
<tr class="memitem:a58e298d1cefcf677748b9c6807956f4a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00043.html">MolAtom</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a58e298d1cefcf677748b9c6807956f4a">GetCenterAtom</a> () const </td></tr>
<tr class="memdesc:a58e298d1cefcf677748b9c6807956f4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the atom defining the origin of the <a class="el" href="a00047.html" title="Molecule : class for complex scatterer descriptions using cartesian coordinates with bond length/angl...">Molecule</a> Equal to 0 if no atom as been set.  <a href="#a58e298d1cefcf677748b9c6807956f4a"></a><br/></td></tr>
<tr class="memitem:a24043736cd4323a31b7bc0fa6fa166da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a24043736cd4323a31b7bc0fa6fa166da">SetCenterAtom</a> (const <a class="el" href="a00043.html">MolAtom</a> &amp;at)</td></tr>
<tr class="memdesc:a24043736cd4323a31b7bc0fa6fa166da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the atom defining the origin of the <a class="el" href="a00047.html" title="Molecule : class for complex scatterer descriptions using cartesian coordinates with bond length/angl...">Molecule</a> Equal to 0 if no atom as been set.  <a href="#a24043736cd4323a31b7bc0fa6fa166da"></a><br/></td></tr>
<tr class="memitem:a3ce93bef9ea4da4d5e0cd47e62418a97"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="a00049.html">MolZAtom</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a3ce93bef9ea4da4d5e0cd47e62418a97">AsZMatrix</a> (const bool keeporder) const </td></tr>
<tr class="memdesc:a3ce93bef9ea4da4d5e0cd47e62418a97"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a00047.html" title="Molecule : class for complex scatterer descriptions using cartesian coordinates with bond length/angl...">Molecule</a> as Z-matrix.  <a href="#a3ce93bef9ea4da4d5e0cd47e62418a97"></a><br/></td></tr>
<tr class="memitem:a19afb1f15773fed7a2d9dff35820bafd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a19afb1f15773fed7a2d9dff35820bafd">SetDeleteSubObjInDestructor</a> (const bool b)</td></tr>
<tr class="memdesc:a19afb1f15773fed7a2d9dff35820bafd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set whether to delete the MolAtoms, MolBonds, MolBondAngles and MolDihedralAngles in the destructor.  <a href="#a19afb1f15773fed7a2d9dff35820bafd"></a><br/></td></tr>
<tr class="memitem:ad96fe78688ce898dc9aeffcc23523967"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#ad96fe78688ce898dc9aeffcc23523967">InitRefParList</a> ()</td></tr>
<tr class="memitem:a9623bff2259d45c162ed28af73974f5a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a9623bff2259d45c162ed28af73974f5a">BuildRingList</a> ()</td></tr>
<tr class="memdesc:a9623bff2259d45c162ed28af73974f5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build the list of rings in the molecule.  <a href="#a9623bff2259d45c162ed28af73974f5a"></a><br/></td></tr>
<tr class="memitem:ac52190dc78f14df37e9bc5b3c9d713c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#ac52190dc78f14df37e9bc5b3c9d713c2">BuildConnectivityTable</a> () const </td></tr>
<tr class="memdesc:ac52190dc78f14df37e9bc5b3c9d713c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build the Connectivity table.  <a href="#ac52190dc78f14df37e9bc5b3c9d713c2"></a><br/></td></tr>
<tr class="memitem:a3642fa8104faa1ce84a977600f9d1aeb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a3642fa8104faa1ce84a977600f9d1aeb">BuildRotorGroup</a> ()</td></tr>
<tr class="memdesc:a3642fa8104faa1ce84a977600f9d1aeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build the groups of atoms that will be rotated during global optimization.  <a href="#a3642fa8104faa1ce84a977600f9d1aeb"></a><br/></td></tr>
<tr class="memitem:a9cc198b9cb896d28c7bd90a775db4ec2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a9cc198b9cb896d28c7bd90a775db4ec2">TuneGlobalOptimRotationAmplitude</a> ()</td></tr>
<tr class="memdesc:a9cc198b9cb896d28c7bd90a775db4ec2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tune the rotation amplitude for free torsions and for the overall <a class="el" href="a00047.html" title="Molecule : class for complex scatterer descriptions using cartesian coordinates with bond length/angl...">Molecule</a> Rotation.  <a href="#a9cc198b9cb896d28c7bd90a775db4ec2"></a><br/></td></tr>
<tr class="memitem:aca2ed46d26209807d587722d131c6315"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#aca2ed46d26209807d587722d131c6315">BuildFlipGroup</a> ()</td></tr>
<tr class="memdesc:aca2ed46d26209807d587722d131c6315"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build the groups of atoms that can be flipped.  <a href="#aca2ed46d26209807d587722d131c6315"></a><br/></td></tr>
<tr class="memitem:abb51819a0eae8b612fb4007ffa16d2b7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abb51819a0eae8b612fb4007ffa16d2b7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#abb51819a0eae8b612fb4007ffa16d2b7">BuildStretchModeBondLength</a> ()</td></tr>
<tr class="memdesc:abb51819a0eae8b612fb4007ffa16d2b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build the groups of atoms moved when stretching a bond length, while respecting the <a class="el" href="a00047.html" title="Molecule : class for complex scatterer descriptions using cartesian coordinates with bond length/angl...">Molecule</a> restraints. <br/></td></tr>
<tr class="memitem:a3d507a4e25612a7412cbcc84b5a831ae"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3d507a4e25612a7412cbcc84b5a831ae"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a3d507a4e25612a7412cbcc84b5a831ae">BuildStretchModeBondAngle</a> ()</td></tr>
<tr class="memdesc:a3d507a4e25612a7412cbcc84b5a831ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build the groups of atoms moved when changing a bond angle, while respecting the <a class="el" href="a00047.html" title="Molecule : class for complex scatterer descriptions using cartesian coordinates with bond length/angl...">Molecule</a> restraints. <br/></td></tr>
<tr class="memitem:a18d44782b4141dfab334250967d202ad"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a18d44782b4141dfab334250967d202ad"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a18d44782b4141dfab334250967d202ad">BuildStretchModeTorsion</a> ()</td></tr>
<tr class="memdesc:a18d44782b4141dfab334250967d202ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build the groups of atoms moved when changing a dihedral angle, while respecting the <a class="el" href="a00047.html" title="Molecule : class for complex scatterer descriptions using cartesian coordinates with bond length/angl...">Molecule</a> restraints. <br/></td></tr>
<tr class="memitem:a7f4c6bf6e5be59780cb7844e53711fb3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a7f4c6bf6e5be59780cb7844e53711fb3">BuildStretchModeTwist</a> ()</td></tr>
<tr class="memdesc:a7f4c6bf6e5be59780cb7844e53711fb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build the groups of atoms used to twist internally the <a class="el" href="a00047.html" title="Molecule : class for complex scatterer descriptions using cartesian coordinates with bond length/angl...">Molecule</a>, e.g.  <a href="#a7f4c6bf6e5be59780cb7844e53711fb3"></a><br/></td></tr>
<tr class="memitem:a83b7b9bac2ce9fe7b310b5267232b1ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a83b7b9bac2ce9fe7b310b5267232b1ca">BuildStretchModeGroups</a> ()</td></tr>
<tr class="memdesc:a83b7b9bac2ce9fe7b310b5267232b1ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Separate <a class="el" href="a00097.html" title="Abstract base Stretch Mode for Molecule objects.">StretchMode</a> that break more than their assigned restraint from others.  <a href="#a83b7b9bac2ce9fe7b310b5267232b1ca"></a><br/></td></tr>
<tr class="memitem:a0944a68727d85bee4ec0cce453cb451c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a0944a68727d85bee4ec0cce453cb451c">BuildMDAtomGroups</a> ()</td></tr>
<tr class="memdesc:a0944a68727d85bee4ec0cce453cb451c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find groups of atoms that cannot be moved relatively to each other using the free or non-free stretch modes.  <a href="#a0944a68727d85bee4ec0cce453cb451c"></a><br/></td></tr>
<tr class="memitem:a2807a35e4746ca9762c009bedb9d02ef"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2807a35e4746ca9762c009bedb9d02ef"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a2807a35e4746ca9762c009bedb9d02ef">UpdateScattCompList</a> () const </td></tr>
<tr class="memdesc:a2807a35e4746ca9762c009bedb9d02ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the <a class="el" href="a00047.html#ae681f50b04c32c7139727c675dc04b67" title="The list of scattering components.">Molecule::mScattCompList</a> from the cartesian coordinates of all atoms, and the orientation parameters. <br/></td></tr>
<tr class="memitem:a15f72c789ad6e4cdae3a667d3d81e7eb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a15f72c789ad6e4cdae3a667d3d81e7eb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a15f72c789ad6e4cdae3a667d3d81e7eb">InitOptions</a> ()</td></tr>
<tr class="memdesc:a15f72c789ad6e4cdae3a667d3d81e7eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build options for this object. <br/></td></tr>
<tr class="memitem:a9daa98a9b4a992d56e0dba41b104b291"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a9daa98a9b4a992d56e0dba41b104b291">ResetRigidGroupsPar</a> () const </td></tr>
<tr class="memdesc:a9daa98a9b4a992d56e0dba41b104b291"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the orientation &amp; translation parameters of all rigid groups to 0, after correcting the atomic positions.  <a href="#a9daa98a9b4a992d56e0dba41b104b291"></a><br/></td></tr>
<tr class="memitem:a69fa14ccb89d13905370e0a75b1e83ff"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a69fa14ccb89d13905370e0a75b1e83ff"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a69fa14ccb89d13905370e0a75b1e83ff">FlipAtomGroup</a> (const <a class="el" href="a00027.html">FlipGroup</a> &amp;)</td></tr>
<tr class="memdesc:a69fa14ccb89d13905370e0a75b1e83ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flip a group of atom. See <a class="el" href="a00027.html" title="When 3(A1..1n) or more atoms are connected to a same atom A, it defines a &#39;flip&#39; group, where it is possible to rotate bonds to their symmetric with respect to one plane defined by atoms Ai-A-Aj.">Molecule::FlipGroup</a>. <br/></td></tr>
<tr class="inherit_header pub_methods_a00085"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_a00085')"><img src="closed.png" alt="-"/>&nbsp;Public Member Functions inherited from <a class="el" href="a00085.html">ObjCryst::Scatterer</a></td></tr>
<tr class="memitem:a5367833f94dd2daeed41ffe3836c1c64 inherit pub_methods_a00085"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5367833f94dd2daeed41ffe3836c1c64"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00085.html#a5367833f94dd2daeed41ffe3836c1c64">Scatterer</a> ()</td></tr>
<tr class="memdesc:a5367833f94dd2daeed41ffe3836c1c64 inherit pub_methods_a00085"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br/></td></tr>
<tr class="memitem:a0d568f50de46100c0faff213dde8544f inherit pub_methods_a00085"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0d568f50de46100c0faff213dde8544f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00085.html#a0d568f50de46100c0faff213dde8544f">Scatterer</a> (const <a class="el" href="a00085.html">Scatterer</a> &amp;old)</td></tr>
<tr class="memdesc:a0d568f50de46100c0faff213dde8544f inherit pub_methods_a00085"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy Constructor. <br/></td></tr>
<tr class="memitem:a5e28b2aa0b7f8e82b533bb8aec288b21 inherit pub_methods_a00085"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5e28b2aa0b7f8e82b533bb8aec288b21"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00085.html#a5e28b2aa0b7f8e82b533bb8aec288b21">~Scatterer</a> ()</td></tr>
<tr class="memdesc:a5e28b2aa0b7f8e82b533bb8aec288b21 inherit pub_methods_a00085"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br/></td></tr>
<tr class="memitem:a36051907538dc50c4989fcbff5b9d4e6 inherit pub_methods_a00085"><td class="memItemLeft" align="right" valign="top">REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00085.html#a36051907538dc50c4989fcbff5b9d4e6">GetX</a> () const </td></tr>
<tr class="memdesc:a36051907538dc50c4989fcbff5b9d4e6 inherit pub_methods_a00085"><td class="mdescLeft">&#160;</td><td class="mdescRight">X coordinate (fractionnal) of the scatterer (for complex scatterers, this corresponds to the position of one atom of the <a class="el" href="a00085.html" title="Generic type of scatterer: can be an atom, or a more complex assembly of atoms.">Scatterer</a>, ideally it should be near the center of the <a class="el" href="a00085.html" title="Generic type of scatterer: can be an atom, or a more complex assembly of atoms.">Scatterer</a>.  <a href="#a36051907538dc50c4989fcbff5b9d4e6"></a><br/></td></tr>
<tr class="memitem:afd11a010b62690b84dacea7e47176ec1 inherit pub_methods_a00085"><td class="memItemLeft" align="right" valign="top">REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00085.html#afd11a010b62690b84dacea7e47176ec1">GetY</a> () const </td></tr>
<tr class="memdesc:afd11a010b62690b84dacea7e47176ec1 inherit pub_methods_a00085"><td class="mdescLeft">&#160;</td><td class="mdescRight">Y coordinate (fractionnal) of the scatterer (for complex scatterers, this corresponds to the position of one atom of the <a class="el" href="a00085.html" title="Generic type of scatterer: can be an atom, or a more complex assembly of atoms.">Scatterer</a>, ideally it should be near the center of the <a class="el" href="a00085.html" title="Generic type of scatterer: can be an atom, or a more complex assembly of atoms.">Scatterer</a>.  <a href="#afd11a010b62690b84dacea7e47176ec1"></a><br/></td></tr>
<tr class="memitem:a667e97f3e177bc74dfc3cbd582afaad5 inherit pub_methods_a00085"><td class="memItemLeft" align="right" valign="top">REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00085.html#a667e97f3e177bc74dfc3cbd582afaad5">GetZ</a> () const </td></tr>
<tr class="memdesc:a667e97f3e177bc74dfc3cbd582afaad5 inherit pub_methods_a00085"><td class="mdescLeft">&#160;</td><td class="mdescRight">Z coordinate (fractionnal) of the scatterer (for complex scatterers, this corresponds to the position of one atom of the <a class="el" href="a00085.html" title="Generic type of scatterer: can be an atom, or a more complex assembly of atoms.">Scatterer</a>, ideally it should be near the center of the <a class="el" href="a00085.html" title="Generic type of scatterer: can be an atom, or a more complex assembly of atoms.">Scatterer</a>.  <a href="#a667e97f3e177bc74dfc3cbd582afaad5"></a><br/></td></tr>
<tr class="memitem:a11c4a95b3299bf8cbdc29ceea5815aad inherit pub_methods_a00085"><td class="memItemLeft" align="right" valign="top">REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00085.html#a11c4a95b3299bf8cbdc29ceea5815aad">GetOccupancy</a> () const </td></tr>
<tr class="memdesc:a11c4a95b3299bf8cbdc29ceea5815aad inherit pub_methods_a00085"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the occupancy of the scatterer (0.  <a href="#a11c4a95b3299bf8cbdc29ceea5815aad"></a><br/></td></tr>
<tr class="memitem:aaefba31ab4187b0f826436929f3c0456 inherit pub_methods_a00085"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00085.html#aaefba31ab4187b0f826436929f3c0456">SetX</a> (const REAL x)</td></tr>
<tr class="memdesc:aaefba31ab4187b0f826436929f3c0456 inherit pub_methods_a00085"><td class="mdescLeft">&#160;</td><td class="mdescRight">X coordinate (fractionnal) of the scatterer (for complex scatterers, this corresponds to the position of one atom of the <a class="el" href="a00085.html" title="Generic type of scatterer: can be an atom, or a more complex assembly of atoms.">Scatterer</a>, ideally it should be near the center of the <a class="el" href="a00085.html" title="Generic type of scatterer: can be an atom, or a more complex assembly of atoms.">Scatterer</a>.  <a href="#aaefba31ab4187b0f826436929f3c0456"></a><br/></td></tr>
<tr class="memitem:afeaa60aaa33907fb6d974f626d91a390 inherit pub_methods_a00085"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00085.html#afeaa60aaa33907fb6d974f626d91a390">SetY</a> (const REAL y)</td></tr>
<tr class="memdesc:afeaa60aaa33907fb6d974f626d91a390 inherit pub_methods_a00085"><td class="mdescLeft">&#160;</td><td class="mdescRight">Y coordinate (fractionnal) of the scatterer (for complex scatterers, this corresponds to the position of one atom of the <a class="el" href="a00085.html" title="Generic type of scatterer: can be an atom, or a more complex assembly of atoms.">Scatterer</a>, ideally it should be near the center of the <a class="el" href="a00085.html" title="Generic type of scatterer: can be an atom, or a more complex assembly of atoms.">Scatterer</a>.  <a href="#afeaa60aaa33907fb6d974f626d91a390"></a><br/></td></tr>
<tr class="memitem:ab7bd1b921a51b476ee776624425ac46c inherit pub_methods_a00085"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00085.html#ab7bd1b921a51b476ee776624425ac46c">SetZ</a> (const REAL z)</td></tr>
<tr class="memdesc:ab7bd1b921a51b476ee776624425ac46c inherit pub_methods_a00085"><td class="mdescLeft">&#160;</td><td class="mdescRight">Z coordinate (fractionnal) of the scatterer (for complex scatterers, this corresponds to the position of one atom of the <a class="el" href="a00085.html" title="Generic type of scatterer: can be an atom, or a more complex assembly of atoms.">Scatterer</a>, ideally it should be near the center of the <a class="el" href="a00085.html" title="Generic type of scatterer: can be an atom, or a more complex assembly of atoms.">Scatterer</a>.  <a href="#ab7bd1b921a51b476ee776624425ac46c"></a><br/></td></tr>
<tr class="memitem:a43c371cd475f921e94c6a13b7c1d89a0 inherit pub_methods_a00085"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00085.html#a43c371cd475f921e94c6a13b7c1d89a0">SetOccupancy</a> (const REAL occupancy)</td></tr>
<tr class="memdesc:a43c371cd475f921e94c6a13b7c1d89a0 inherit pub_methods_a00085"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the occupancy of the scatterer (0.  <a href="#a43c371cd475f921e94c6a13b7c1d89a0"></a><br/></td></tr>
<tr class="memitem:a121e6e739f9b740564afc32c8c74a664 inherit pub_methods_a00085"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00085.html#a121e6e739f9b740564afc32c8c74a664">operator string</a> () const </td></tr>
<tr class="memdesc:a121e6e739f9b740564afc32c8c74a664 inherit pub_methods_a00085"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion function.  <a href="#a121e6e739f9b740564afc32c8c74a664"></a><br/></td></tr>
<tr class="memitem:a2db9df8f429181af0e478ba74c16cb27 inherit pub_methods_a00085"><td class="memItemLeft" align="right" valign="top">virtual const string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00085.html#a2db9df8f429181af0e478ba74c16cb27">GetColour</a> () const </td></tr>
<tr class="memdesc:a2db9df8f429181af0e478ba74c16cb27 inherit pub_methods_a00085"><td class="mdescLeft">&#160;</td><td class="mdescRight">Colour associated to this scatterer (using POVRay names)  <a href="#a2db9df8f429181af0e478ba74c16cb27"></a><br/></td></tr>
<tr class="memitem:ae79467fc8546f90dc51a42037a8d193e inherit pub_methods_a00085"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae79467fc8546f90dc51a42037a8d193e"></a>
virtual const float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00085.html#ae79467fc8546f90dc51a42037a8d193e">GetColourRGB</a> () const </td></tr>
<tr class="memdesc:ae79467fc8546f90dc51a42037a8d193e inherit pub_methods_a00085"><td class="mdescLeft">&#160;</td><td class="mdescRight">Colour associated to this scatterer, 3 RGB Coordinates. <br/></td></tr>
<tr class="memitem:a9f72e14ca11568fc85bb808b720883fc inherit pub_methods_a00085"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9f72e14ca11568fc85bb808b720883fc"></a>
const <a class="el" href="a00072.html">RefinableObjClock</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00085.html#a9f72e14ca11568fc85bb808b720883fc">GetClockScatterer</a> () const </td></tr>
<tr class="memdesc:a9f72e14ca11568fc85bb808b720883fc inherit pub_methods_a00085"><td class="mdescLeft">&#160;</td><td class="mdescRight">Last time anything in the scatterer was changed (atoms, positions, scattering power) <br/></td></tr>
<tr class="memitem:a02f9ce5c724e92ca8eb7c6e4322f8c85 inherit pub_methods_a00085"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a02f9ce5c724e92ca8eb7c6e4322f8c85"></a>
<a class="el" href="a00072.html">RefinableObjClock</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00085.html#a02f9ce5c724e92ca8eb7c6e4322f8c85">GetClockScatterer</a> ()</td></tr>
<tr class="memdesc:a02f9ce5c724e92ca8eb7c6e4322f8c85 inherit pub_methods_a00085"><td class="mdescLeft">&#160;</td><td class="mdescRight">Last time anything in the scatterer was changed (atoms, positions, scattering power) <br/></td></tr>
<tr class="memitem:ace072c5113b5328a7145d33779582621 inherit pub_methods_a00085"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ace072c5113b5328a7145d33779582621"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00085.html#ace072c5113b5328a7145d33779582621">SetCrystal</a> (<a class="el" href="a00020.html">Crystal</a> &amp;)</td></tr>
<tr class="memdesc:ace072c5113b5328a7145d33779582621 inherit pub_methods_a00085"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the crystal in which is included this <a class="el" href="a00085.html" title="Generic type of scatterer: can be an atom, or a more complex assembly of atoms.">Scatterer</a>. <br/></td></tr>
<tr class="memitem:a89eed8d88f9e3f31957353254b9bbc81 inherit pub_methods_a00085"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a89eed8d88f9e3f31957353254b9bbc81"></a>
const <a class="el" href="a00020.html">Crystal</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00085.html#a89eed8d88f9e3f31957353254b9bbc81">GetCrystal</a> () const </td></tr>
<tr class="memdesc:a89eed8d88f9e3f31957353254b9bbc81 inherit pub_methods_a00085"><td class="mdescLeft">&#160;</td><td class="mdescRight">In which crystal is this <a class="el" href="a00085.html" title="Generic type of scatterer: can be an atom, or a more complex assembly of atoms.">Scatterer</a> included ? <br/></td></tr>
<tr class="memitem:acc71fa0e4198adc72c64480628e5e49c inherit pub_methods_a00085"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acc71fa0e4198adc72c64480628e5e49c"></a>
<a class="el" href="a00020.html">Crystal</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00085.html#acc71fa0e4198adc72c64480628e5e49c">GetCrystal</a> ()</td></tr>
<tr class="memdesc:acc71fa0e4198adc72c64480628e5e49c inherit pub_methods_a00085"><td class="mdescLeft">&#160;</td><td class="mdescRight">In which crystal is this <a class="el" href="a00085.html" title="Generic type of scatterer: can be an atom, or a more complex assembly of atoms.">Scatterer</a> included ? <br/></td></tr>
<tr class="inherit_header pub_methods_a00071"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_a00071')"><img src="closed.png" alt="-"/>&nbsp;Public Member Functions inherited from <a class="el" href="a00071.html">ObjCryst::RefinableObj</a></td></tr>
<tr class="memitem:a081d2bfc2065c2adaa2bfdf292900235 inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a081d2bfc2065c2adaa2bfdf292900235"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a081d2bfc2065c2adaa2bfdf292900235">RefinableObj</a> ()</td></tr>
<tr class="memdesc:a081d2bfc2065c2adaa2bfdf292900235 inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br/></td></tr>
<tr class="memitem:aa0eaf0982686476cbec02a8afeebc92d inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#aa0eaf0982686476cbec02a8afeebc92d">RefinableObj</a> (const bool internalUseOnly)</td></tr>
<tr class="memdesc:aa0eaf0982686476cbec02a8afeebc92d inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#aa0eaf0982686476cbec02a8afeebc92d"></a><br/></td></tr>
<tr class="memitem:a5f77dcf037cc8d2ea1fd84bfda6ddbc0 inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a5f77dcf037cc8d2ea1fd84bfda6ddbc0">RefinableObj</a> (const <a class="el" href="a00071.html">RefinableObj</a> &amp;old)</td></tr>
<tr class="memdesc:a5f77dcf037cc8d2ea1fd84bfda6ddbc0 inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defined not implemented...  <a href="#a5f77dcf037cc8d2ea1fd84bfda6ddbc0"></a><br/></td></tr>
<tr class="memitem:a5cd8d41a828153e2585077a9fbd334ce inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5cd8d41a828153e2585077a9fbd334ce"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a5cd8d41a828153e2585077a9fbd334ce">~RefinableObj</a> ()</td></tr>
<tr class="memdesc:a5cd8d41a828153e2585077a9fbd334ce inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br/></td></tr>
<tr class="memitem:a61f51d3364e13a542e8c32df454c88aa inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a61f51d3364e13a542e8c32df454c88aa"></a>
virtual const string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a61f51d3364e13a542e8c32df454c88aa">GetName</a> () const </td></tr>
<tr class="memdesc:a61f51d3364e13a542e8c32df454c88aa inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name of the object. <br/></td></tr>
<tr class="memitem:a464caf574804fc21bd896f823131a1d7 inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a464caf574804fc21bd896f823131a1d7"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a464caf574804fc21bd896f823131a1d7">SetName</a> (const string &amp;name)</td></tr>
<tr class="memdesc:a464caf574804fc21bd896f823131a1d7 inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name of the object. <br/></td></tr>
<tr class="memitem:ab9b15adff1092f15e8f06cfeecc314f8 inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#ab9b15adff1092f15e8f06cfeecc314f8">operator=</a> (const <a class="el" href="a00071.html">RefinableObj</a> &amp;old)</td></tr>
<tr class="memdesc:ab9b15adff1092f15e8f06cfeecc314f8 inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defined not implemented...  <a href="#ab9b15adff1092f15e8f06cfeecc314f8"></a><br/></td></tr>
<tr class="memitem:a0e9b816ad753f633ef6d9650ec6b4ca6 inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a0e9b816ad753f633ef6d9650ec6b4ca6">PrepareForRefinement</a> () const </td></tr>
<tr class="memdesc:a0e9b816ad753f633ef6d9650ec6b4ca6 inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find which parameters are used and <b>not</b> fixed, for a refinement /optimization.  <a href="#a0e9b816ad753f633ef6d9650ec6b4ca6"></a><br/></td></tr>
<tr class="memitem:ac1a65da1f7563472badaf699002b8b8b inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac1a65da1f7563472badaf699002b8b8b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#ac1a65da1f7563472badaf699002b8b8b">FixAllPar</a> ()</td></tr>
<tr class="memdesc:ac1a65da1f7563472badaf699002b8b8b inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fix All parameters. <br/></td></tr>
<tr class="memitem:ab75dcf763d7f96063dcb4d85e6e78007 inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab75dcf763d7f96063dcb4d85e6e78007"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#ab75dcf763d7f96063dcb4d85e6e78007">UnFixAllPar</a> ()</td></tr>
<tr class="memdesc:ab75dcf763d7f96063dcb4d85e6e78007 inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">UnFix All parameters. <br/></td></tr>
<tr class="memitem:ad6284ca6b92364e1ebd02bbef81d7e7e inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad6284ca6b92364e1ebd02bbef81d7e7e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#ad6284ca6b92364e1ebd02bbef81d7e7e">SetParIsFixed</a> (const long parIndex, const bool fix)</td></tr>
<tr class="memdesc:ad6284ca6b92364e1ebd02bbef81d7e7e inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fix/un-fix one parameter from its #. <br/></td></tr>
<tr class="memitem:a8dc4cb100f839e12a9e0ae01facc5c9c inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8dc4cb100f839e12a9e0ae01facc5c9c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a8dc4cb100f839e12a9e0ae01facc5c9c">SetParIsFixed</a> (const string &amp;parName, const bool fix)</td></tr>
<tr class="memdesc:a8dc4cb100f839e12a9e0ae01facc5c9c inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fix/un-fix one parameter from its name. <br/></td></tr>
<tr class="memitem:acc7f25893d4dc4cec08fd04a84aa008d inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acc7f25893d4dc4cec08fd04a84aa008d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#acc7f25893d4dc4cec08fd04a84aa008d">SetParIsFixed</a> (const <a class="el" href="a00080.html">RefParType</a> *type, const bool fix)</td></tr>
<tr class="memdesc:acc7f25893d4dc4cec08fd04a84aa008d inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fix/un-fix one family of parameters. <br/></td></tr>
<tr class="memitem:a1d0737a4ecb7cb1339f3138cd792ba7c inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1d0737a4ecb7cb1339f3138cd792ba7c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a1d0737a4ecb7cb1339f3138cd792ba7c">SetParIsUsed</a> (const string &amp;parName, const bool use)</td></tr>
<tr class="memdesc:a1d0737a4ecb7cb1339f3138cd792ba7c inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set whether a parameter is used. <br/></td></tr>
<tr class="memitem:a40eba4b59117dd18831286e05b5b982c inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a40eba4b59117dd18831286e05b5b982c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a40eba4b59117dd18831286e05b5b982c">SetParIsUsed</a> (const <a class="el" href="a00080.html">RefParType</a> *type, const bool use)</td></tr>
<tr class="memdesc:a40eba4b59117dd18831286e05b5b982c inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set whether a family of parameters is used. <br/></td></tr>
<tr class="memitem:a945800fc9c72fb9a538e384a7831b37f inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a945800fc9c72fb9a538e384a7831b37f">GetNbPar</a> () const </td></tr>
<tr class="memdesc:a945800fc9c72fb9a538e384a7831b37f inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total number of refinable parameter in the object.  <a href="#a945800fc9c72fb9a538e384a7831b37f"></a><br/></td></tr>
<tr class="memitem:a6ead9da8785dbaa3dc4fb5f93cb455a3 inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6ead9da8785dbaa3dc4fb5f93cb455a3"></a>
long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a6ead9da8785dbaa3dc4fb5f93cb455a3">GetNbParNotFixed</a> () const </td></tr>
<tr class="memdesc:a6ead9da8785dbaa3dc4fb5f93cb455a3 inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total number of non-fixed parameters. Is initialized by <a class="el" href="a00071.html#a0e9b816ad753f633ef6d9650ec6b4ca6" title="Find which parameters are used and not fixed, for a refinement /optimization.">PrepareForRefinement()</a> <br/></td></tr>
<tr class="memitem:ae5c543d3b0fb010afa37b5f12620405b inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae5c543d3b0fb010afa37b5f12620405b"></a>
<a class="el" href="a00073.html">RefinablePar</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#ae5c543d3b0fb010afa37b5f12620405b">GetPar</a> (const long i)</td></tr>
<tr class="memdesc:ae5c543d3b0fb010afa37b5f12620405b inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access all parameters in the order they were inputted. <br/></td></tr>
<tr class="memitem:a5686cc39b27bc719be33aad0700438a1 inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5686cc39b27bc719be33aad0700438a1"></a>
const <a class="el" href="a00073.html">RefinablePar</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a5686cc39b27bc719be33aad0700438a1">GetPar</a> (const long i) const </td></tr>
<tr class="memdesc:a5686cc39b27bc719be33aad0700438a1 inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access all parameters in the order they were inputted. <br/></td></tr>
<tr class="memitem:aea1c3b652c3f1eb5444bd47456e04392 inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aea1c3b652c3f1eb5444bd47456e04392"></a>
<a class="el" href="a00073.html">RefinablePar</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#aea1c3b652c3f1eb5444bd47456e04392">GetPar</a> (const string &amp;name)</td></tr>
<tr class="memdesc:aea1c3b652c3f1eb5444bd47456e04392 inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access all parameters from their name. <br/></td></tr>
<tr class="memitem:a519b443c48cc463ed6b0682a6f557074 inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a519b443c48cc463ed6b0682a6f557074"></a>
const <a class="el" href="a00073.html">RefinablePar</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a519b443c48cc463ed6b0682a6f557074">GetPar</a> (const string &amp;name) const </td></tr>
<tr class="memdesc:a519b443c48cc463ed6b0682a6f557074 inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access all parameters from their name. <br/></td></tr>
<tr class="memitem:a07ea375ae64f69559e0b595e8c111087 inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a07ea375ae64f69559e0b595e8c111087"></a>
<a class="el" href="a00073.html">RefinablePar</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a07ea375ae64f69559e0b595e8c111087">GetPar</a> (const REAL *)</td></tr>
<tr class="memdesc:a07ea375ae64f69559e0b595e8c111087 inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access parameter from its adress. <br/></td></tr>
<tr class="memitem:a82b9eeedc157f76f17e9f9461c3a11d7 inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a82b9eeedc157f76f17e9f9461c3a11d7"></a>
const <a class="el" href="a00073.html">RefinablePar</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a82b9eeedc157f76f17e9f9461c3a11d7">GetPar</a> (const REAL *) const </td></tr>
<tr class="memdesc:a82b9eeedc157f76f17e9f9461c3a11d7 inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access parameter from its adress. <br/></td></tr>
<tr class="memitem:ac226ae69247c59e1d22b5be5010534c9 inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac226ae69247c59e1d22b5be5010534c9"></a>
long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#ac226ae69247c59e1d22b5be5010534c9">GetParIndex</a> (const string &amp;name, const bool nothrow=false) const </td></tr>
<tr class="memdesc:ac226ae69247c59e1d22b5be5010534c9 inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a parameter index (the order it was inputted) from its name. <br/></td></tr>
<tr class="memitem:a86afd7f55aafa42dd0a65a04c3eaf192 inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a86afd7f55aafa42dd0a65a04c3eaf192"></a>
long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a86afd7f55aafa42dd0a65a04c3eaf192">GetParIndex</a> (const REAL *, const bool nothrow=false) const </td></tr>
<tr class="memdesc:a86afd7f55aafa42dd0a65a04c3eaf192 inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a parameter index (the order it was inputted) from its adress. <br/></td></tr>
<tr class="memitem:ae06ade6e11e2de4d041d07612a7d802c inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00073.html">RefinablePar</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#ae06ade6e11e2de4d041d07612a7d802c">GetParNotFixed</a> (const long i)</td></tr>
<tr class="memdesc:ae06ade6e11e2de4d041d07612a7d802c inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access all parameters in the order they were inputted, skipping fixed parameters.  <a href="#ae06ade6e11e2de4d041d07612a7d802c"></a><br/></td></tr>
<tr class="memitem:a91112351e072c2448c4af8be3ad2da12 inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00073.html">RefinablePar</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a91112351e072c2448c4af8be3ad2da12">GetParNotFixed</a> (const long i) const </td></tr>
<tr class="memdesc:a91112351e072c2448c4af8be3ad2da12 inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access all parameters in the order they were inputed, skipping fixed parameters.  <a href="#a91112351e072c2448c4af8be3ad2da12"></a><br/></td></tr>
<tr class="memitem:a0c0050a3d3141ca34eb8f4b559ad2f8d inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a0c0050a3d3141ca34eb8f4b559ad2f8d">AddPar</a> (const <a class="el" href="a00073.html">RefinablePar</a> &amp;newRefPar)</td></tr>
<tr class="memdesc:a0c0050a3d3141ca34eb8f4b559ad2f8d inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a refinable parameter.  <a href="#a0c0050a3d3141ca34eb8f4b559ad2f8d"></a><br/></td></tr>
<tr class="memitem:a4a792c84f7d35e71b3e89aae5a87bffa inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a4a792c84f7d35e71b3e89aae5a87bffa">AddPar</a> (<a class="el" href="a00073.html">RefinablePar</a> *newRefPar)</td></tr>
<tr class="memdesc:a4a792c84f7d35e71b3e89aae5a87bffa inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a refinable parameter.  <a href="#a4a792c84f7d35e71b3e89aae5a87bffa"></a><br/></td></tr>
<tr class="memitem:a6a28259e473fadd53fbc9b9bf7930813 inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a6a28259e473fadd53fbc9b9bf7930813">AddPar</a> (<a class="el" href="a00071.html">RefinableObj</a> &amp;newRefParList, const bool copyParam=false)</td></tr>
<tr class="memdesc:a6a28259e473fadd53fbc9b9bf7930813 inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add all the parameters in another <a class="el" href="a00071.html" title="Generic Refinable Object.">RefinableObj</a>.  <a href="#a6a28259e473fadd53fbc9b9bf7930813"></a><br/></td></tr>
<tr class="memitem:a33a10888dfa13b40a5989d6b9af52174 inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="a00073.html">RefinablePar</a> * &gt;::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a33a10888dfa13b40a5989d6b9af52174">RemovePar</a> (<a class="el" href="a00073.html">RefinablePar</a> *refPar)</td></tr>
<tr class="memdesc:a33a10888dfa13b40a5989d6b9af52174 inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a refinable parameter.  <a href="#a33a10888dfa13b40a5989d6b9af52174"></a><br/></td></tr>
<tr class="memitem:abd5b0aa78ff6ec95838e78e2d3685b56 inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#abd5b0aa78ff6ec95838e78e2d3685b56">CreateParamSet</a> (const string name=&quot;&quot;) const </td></tr>
<tr class="memdesc:abd5b0aa78ff6ec95838e78e2d3685b56 inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save the current set of refined values in a new set.  <a href="#abd5b0aa78ff6ec95838e78e2d3685b56"></a><br/></td></tr>
<tr class="memitem:ae9a2401becfcd7dda785c0931d3f31f3 inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae9a2401becfcd7dda785c0931d3f31f3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#ae9a2401becfcd7dda785c0931d3f31f3">ClearParamSet</a> (const unsigned long id) const </td></tr>
<tr class="memdesc:ae9a2401becfcd7dda785c0931d3f31f3 inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase the param set with the given id, releasing memory. <br/></td></tr>
<tr class="memitem:afdcabf808440aa0d566e56f145de235d inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#afdcabf808440aa0d566e56f145de235d">SaveParamSet</a> (const unsigned long id) const </td></tr>
<tr class="memdesc:afdcabf808440aa0d566e56f145de235d inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight"><pre class="fragment">Save the current set of refined values over a previously-created set
</pre><p> *of saved values.  <a href="#afdcabf808440aa0d566e56f145de235d"></a><br/></td></tr>
<tr class="memitem:a057437fe6759b589906d8a16f9732e22 inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a057437fe6759b589906d8a16f9732e22">RestoreParamSet</a> (const unsigned long id)</td></tr>
<tr class="memdesc:a057437fe6759b589906d8a16f9732e22 inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore a saved set of values.  <a href="#a057437fe6759b589906d8a16f9732e22"></a><br/></td></tr>
<tr class="memitem:aa5ebd29814d5ed1a18a669ea0f3417f3 inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top">const CrystVector_REAL &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#aa5ebd29814d5ed1a18a669ea0f3417f3">GetParamSet</a> (const unsigned long setId) const </td></tr>
<tr class="memdesc:aa5ebd29814d5ed1a18a669ea0f3417f3 inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access one save refpar set.  <a href="#aa5ebd29814d5ed1a18a669ea0f3417f3"></a><br/></td></tr>
<tr class="memitem:a33290cd0d3d90620cb7465dacb675085 inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top">CrystVector_REAL &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a33290cd0d3d90620cb7465dacb675085">GetParamSet</a> (const unsigned long setId)</td></tr>
<tr class="memdesc:a33290cd0d3d90620cb7465dacb675085 inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access one save refpar set.  <a href="#a33290cd0d3d90620cb7465dacb675085"></a><br/></td></tr>
<tr class="memitem:ab17775f3f007ae6edd2de6fd2433c6ce inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top">REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#ab17775f3f007ae6edd2de6fd2433c6ce">GetParamSet_ParNotFixedHumanValue</a> (const unsigned long setId, const long parNumber) const </td></tr>
<tr class="memdesc:ab17775f3f007ae6edd2de6fd2433c6ce inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the (human) value of one refined parameter in a saved set of parameters.  <a href="#ab17775f3f007ae6edd2de6fd2433c6ce"></a><br/></td></tr>
<tr class="memitem:ac269ad4ad4ca8b4e9f13f5466475d959 inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top">const void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#ac269ad4ad4ca8b4e9f13f5466475d959">EraseAllParamSet</a> ()</td></tr>
<tr class="memdesc:ac269ad4ad4ca8b4e9f13f5466475d959 inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase all saved refpar sets.  <a href="#ac269ad4ad4ca8b4e9f13f5466475d959"></a><br/></td></tr>
<tr class="memitem:a1426f90c9b580a4854917ab7db876c3e inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top">const string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a1426f90c9b580a4854917ab7db876c3e">GetParamSetName</a> (const unsigned long setId) const </td></tr>
<tr class="memdesc:a1426f90c9b580a4854917ab7db876c3e inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name associated to a refpar set.  <a href="#a1426f90c9b580a4854917ab7db876c3e"></a><br/></td></tr>
<tr class="memitem:a2f24a7b834f5588e32aac9c6e33a1020 inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2f24a7b834f5588e32aac9c6e33a1020"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a2f24a7b834f5588e32aac9c6e33a1020">SetLimitsAbsolute</a> (const string &amp;parName, const REAL min, const REAL max)</td></tr>
<tr class="memdesc:a2f24a7b834f5588e32aac9c6e33a1020 inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the limits for a given parameter, giving absolute new limits. <br/></td></tr>
<tr class="memitem:a371f137ad14a77ee3b545520d05fe4d6 inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a371f137ad14a77ee3b545520d05fe4d6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a371f137ad14a77ee3b545520d05fe4d6">SetLimitsAbsolute</a> (const <a class="el" href="a00080.html">RefParType</a> *type, const REAL min, const REAL max)</td></tr>
<tr class="memdesc:a371f137ad14a77ee3b545520d05fe4d6 inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the limits for a category of parameters, giving absolute new limits. <br/></td></tr>
<tr class="memitem:acacf469614253239fdeebb21e50f0c1c inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#acacf469614253239fdeebb21e50f0c1c">SetLimitsRelative</a> (const string &amp;parName, const REAL min, const REAL max)</td></tr>
<tr class="memdesc:acacf469614253239fdeebb21e50f0c1c inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the limits for a given parameter, giving relative new limits (eg giving -.1 and +.1 will set new limits at the current value + min and current value + max) Thus min should logically be &lt;0 and max &gt;0.  <a href="#acacf469614253239fdeebb21e50f0c1c"></a><br/></td></tr>
<tr class="memitem:ae8d497fc43ac3f166a21781a62dfa25d inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#ae8d497fc43ac3f166a21781a62dfa25d">SetLimitsRelative</a> (const <a class="el" href="a00080.html">RefParType</a> *type, const REAL min, const REAL max)</td></tr>
<tr class="memdesc:ae8d497fc43ac3f166a21781a62dfa25d inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the limits for a category of parameters, giving relative new limits (eg giving -.1 and +.1 will set new limits at the current value + min and current value + max).  <a href="#ae8d497fc43ac3f166a21781a62dfa25d"></a><br/></td></tr>
<tr class="memitem:adc6b05a95d524d600910a47861190e84 inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#adc6b05a95d524d600910a47861190e84">SetLimitsProportional</a> (const string &amp;parName, const REAL min, const REAL max)</td></tr>
<tr class="memdesc:adc6b05a95d524d600910a47861190e84 inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the limits for a given parameter, proportionnaly to the current value.  <a href="#adc6b05a95d524d600910a47861190e84"></a><br/></td></tr>
<tr class="memitem:a75741a3e7f7f1740243901b60f406e93 inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a75741a3e7f7f1740243901b60f406e93">SetLimitsProportional</a> (const <a class="el" href="a00080.html">RefParType</a> *type, const REAL min, const REAL max)</td></tr>
<tr class="memdesc:a75741a3e7f7f1740243901b60f406e93 inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the limits for a category of parameters, proportionnaly to their current value.  <a href="#a75741a3e7f7f1740243901b60f406e93"></a><br/></td></tr>
<tr class="memitem:ae4f0b5b0038ff3b49dcdc8adbf98bc58 inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae4f0b5b0038ff3b49dcdc8adbf98bc58"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#ae4f0b5b0038ff3b49dcdc8adbf98bc58">SetGlobalOptimStep</a> (const <a class="el" href="a00080.html">RefParType</a> *type, const REAL step)</td></tr>
<tr class="memdesc:ae4f0b5b0038ff3b49dcdc8adbf98bc58 inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the maximum step to use during Global Optimization algorithms. <br/></td></tr>
<tr class="memitem:a30e81164b0176ca00e90d994ca0a0827 inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a30e81164b0176ca00e90d994ca0a0827"></a>
<a class="el" href="a00054.html">ObjRegistry</a>&lt; <a class="el" href="a00071.html">RefinableObj</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a30e81164b0176ca00e90d994ca0a0827">GetSubObjRegistry</a> ()</td></tr>
<tr class="memdesc:a30e81164b0176ca00e90d994ca0a0827 inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to the registry of <a class="el" href="a00071.html" title="Generic Refinable Object.">RefinableObj</a> used by this object. <br/></td></tr>
<tr class="memitem:a23999d5fb06661cddc9bfa294c48624e inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a23999d5fb06661cddc9bfa294c48624e"></a>
const <a class="el" href="a00054.html">ObjRegistry</a>&lt; <a class="el" href="a00071.html">RefinableObj</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a23999d5fb06661cddc9bfa294c48624e">GetSubObjRegistry</a> () const </td></tr>
<tr class="memdesc:a23999d5fb06661cddc9bfa294c48624e inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to the registry of <a class="el" href="a00071.html" title="Generic Refinable Object.">RefinableObj</a> used by this object. <br/></td></tr>
<tr class="memitem:a8afc65925b0e4d1894d72c457ad38bc9 inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a8afc65925b0e4d1894d72c457ad38bc9">RegisterClient</a> (<a class="el" href="a00071.html">RefinableObj</a> &amp;) const </td></tr>
<tr class="memdesc:a8afc65925b0e4d1894d72c457ad38bc9 inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a new object using this object.  <a href="#a8afc65925b0e4d1894d72c457ad38bc9"></a><br/></td></tr>
<tr class="memitem:ae37091ca0b7091eaf87bf630433ad91d inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae37091ca0b7091eaf87bf630433ad91d"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#ae37091ca0b7091eaf87bf630433ad91d">DeRegisterClient</a> (<a class="el" href="a00071.html">RefinableObj</a> &amp;) const </td></tr>
<tr class="memdesc:ae37091ca0b7091eaf87bf630433ad91d inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deregister an object (which not any more) using this object. <br/></td></tr>
<tr class="memitem:abb63797f2ffc7e8317f66ce9749f105f inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abb63797f2ffc7e8317f66ce9749f105f"></a>
virtual const <a class="el" href="a00054.html">ObjRegistry</a><br class="typebreak"/>
&lt; <a class="el" href="a00071.html">RefinableObj</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#abb63797f2ffc7e8317f66ce9749f105f">GetClientRegistry</a> () const </td></tr>
<tr class="memdesc:abb63797f2ffc7e8317f66ce9749f105f inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the list of clients. <br/></td></tr>
<tr class="memitem:aaf7fdd5c8d015285639fe24138e31b6b inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaf7fdd5c8d015285639fe24138e31b6b"></a>
virtual <a class="el" href="a00054.html">ObjRegistry</a><br class="typebreak"/>
&lt; <a class="el" href="a00071.html">RefinableObj</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#aaf7fdd5c8d015285639fe24138e31b6b">GetClientRegistry</a> ()</td></tr>
<tr class="memdesc:aaf7fdd5c8d015285639fe24138e31b6b inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the list of clients. <br/></td></tr>
<tr class="memitem:addbd91121eaf715f67080d95cfdc857c inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="addbd91121eaf715f67080d95cfdc857c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#addbd91121eaf715f67080d95cfdc857c">IsBeingRefined</a> () const </td></tr>
<tr class="memdesc:addbd91121eaf715f67080d95cfdc857c inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the object being refined ? (Can be refined by one algorithm at a time only.) <br/></td></tr>
<tr class="memitem:a565c41c23c04f5945512374ae671e2e3 inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a565c41c23c04f5945512374ae671e2e3">SetApproximationFlag</a> (const bool allow)</td></tr>
<tr class="memdesc:a565c41c23c04f5945512374ae671e2e3 inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable numerical approximations.  <a href="#a565c41c23c04f5945512374ae671e2e3"></a><br/></td></tr>
<tr class="memitem:a47fc5a85493671a3590ed7e3971b18fe inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a47fc5a85493671a3590ed7e3971b18fe">BeginGlobalOptRandomMove</a> ()</td></tr>
<tr class="memdesc:a47fc5a85493671a3590ed7e3971b18fe inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raise a flag, to be sure not to make a random change more than once in each <a class="el" href="a00071.html" title="Generic Refinable Object.">RefinableObj</a>.  <a href="#a47fc5a85493671a3590ed7e3971b18fe"></a><br/></td></tr>
<tr class="memitem:a3b6228c6fbd154441d935af2d511fe82 inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a3b6228c6fbd154441d935af2d511fe82">ResetParList</a> ()</td></tr>
<tr class="memdesc:a3b6228c6fbd154441d935af2d511fe82 inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Re-init the list of refinable parameters, removing all parameters.  <a href="#a3b6228c6fbd154441d935af2d511fe82"></a><br/></td></tr>
<tr class="memitem:a389c9d9ed7e8c700abfa4dfb72a32792 inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a389c9d9ed7e8c700abfa4dfb72a32792"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a389c9d9ed7e8c700abfa4dfb72a32792">GetNbOption</a> () const </td></tr>
<tr class="memdesc:a389c9d9ed7e8c700abfa4dfb72a32792 inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of Options for this object. <br/></td></tr>
<tr class="memitem:a2dcb69d78e55dc75a7377e5a772536de inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2dcb69d78e55dc75a7377e5a772536de"></a>
<a class="el" href="a00078.html">RefObjOpt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a2dcb69d78e55dc75a7377e5a772536de">GetOption</a> (const unsigned int i)</td></tr>
<tr class="memdesc:a2dcb69d78e55dc75a7377e5a772536de inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to the options. <br/></td></tr>
<tr class="memitem:a77b66fd9c4e752e9b58ecd9e5ec2a218 inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a77b66fd9c4e752e9b58ecd9e5ec2a218"></a>
const <a class="el" href="a00078.html">RefObjOpt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a77b66fd9c4e752e9b58ecd9e5ec2a218">GetOption</a> (const unsigned int i) const </td></tr>
<tr class="memdesc:a77b66fd9c4e752e9b58ecd9e5ec2a218 inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">const access to the options <br/></td></tr>
<tr class="memitem:ad59c8ad2b0d7ee59fa3f399a54f05e54 inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#ad59c8ad2b0d7ee59fa3f399a54f05e54">GetGeneGroup</a> (const <a class="el" href="a00071.html">RefinableObj</a> &amp;obj, CrystVector_uint &amp;groupIndex, unsigned int &amp;firstGroup) const </td></tr>
<tr class="memdesc:ad59c8ad2b0d7ee59fa3f399a54f05e54 inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the gene group assigned to each parameter.  <a href="#ad59c8ad2b0d7ee59fa3f399a54f05e54"></a><br/></td></tr>
<tr class="memitem:a33f94e9c9c0717ea77c8b9427e9e137e inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a33f94e9c9c0717ea77c8b9427e9e137e">SetDeleteRefParInDestructor</a> (const bool b)</td></tr>
<tr class="memdesc:a33f94e9c9c0717ea77c8b9427e9e137e inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set this object not to delete its list of parameters when destroyed.  <a href="#a33f94e9c9c0717ea77c8b9427e9e137e"></a><br/></td></tr>
<tr class="memitem:a52422a72840cdb07ac5274eced2d2152 inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00072.html">RefinableObjClock</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a52422a72840cdb07ac5274eced2d2152">GetRefParListClock</a> () const </td></tr>
<tr class="memdesc:a52422a72840cdb07ac5274eced2d2152 inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">What was the last time a <a class="el" href="a00073.html" title="Generic class for parameters of refinable objects.">RefinablePar</a> was added/removed ?  <a href="#a52422a72840cdb07ac5274eced2d2152"></a><br/></td></tr>
<tr class="memitem:a92288a2ec22c405bbb9985bdc1a0b633 inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top">virtual REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a92288a2ec22c405bbb9985bdc1a0b633">GetRestraintCost</a> () const </td></tr>
<tr class="memdesc:a92288a2ec22c405bbb9985bdc1a0b633 inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the restraint cost (overall penalty of all restraints)  <a href="#a92288a2ec22c405bbb9985bdc1a0b633"></a><br/></td></tr>
<tr class="memitem:a0eec1ccf5ba9769e5c6a82a85ecf451d inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a0eec1ccf5ba9769e5c6a82a85ecf451d">AddRestraint</a> (<a class="el" href="a00081.html">Restraint</a> *pNewRestraint)</td></tr>
<tr class="memdesc:a0eec1ccf5ba9769e5c6a82a85ecf451d inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new restraint.  <a href="#a0eec1ccf5ba9769e5c6a82a85ecf451d"></a><br/></td></tr>
<tr class="memitem:a0e738f16d06bed8a50985a97deb48e7d inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="a00081.html">Restraint</a> * &gt;::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a0e738f16d06bed8a50985a97deb48e7d">RemoveRestraint</a> (<a class="el" href="a00081.html">Restraint</a> *pRestraint)</td></tr>
<tr class="memdesc:a0e738f16d06bed8a50985a97deb48e7d inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a restraint from the list of known restraints.  <a href="#a0e738f16d06bed8a50985a97deb48e7d"></a><br/></td></tr>
<tr class="memitem:a5910fb213a6b51da18d5f65badceb029 inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5910fb213a6b51da18d5f65badceb029"></a>
const <a class="el" href="a00072.html">RefinableObjClock</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a5910fb213a6b51da18d5f65badceb029">GetClockMaster</a> () const </td></tr>
<tr class="memdesc:a5910fb213a6b51da18d5f65badceb029 inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">This clocks records <em>any</em> change in the object. See refinableObj::mClockMaster. <br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ae681f50b04c32c7139727c675dc04b67"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00087.html">ScatteringComponentList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#ae681f50b04c32c7139727c675dc04b67">mScattCompList</a></td></tr>
<tr class="memdesc:ae681f50b04c32c7139727c675dc04b67"><td class="mdescLeft">&#160;</td><td class="mdescRight">The list of scattering components.  <a href="#ae681f50b04c32c7139727c675dc04b67"></a><br/></td></tr>
<tr class="memitem:ad498c51ecf4ee0b4482e5fe41cd52be7"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="a00043.html">MolAtom</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#ad498c51ecf4ee0b4482e5fe41cd52be7">mvpAtom</a></td></tr>
<tr class="memdesc:ad498c51ecf4ee0b4482e5fe41cd52be7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The list of atoms.  <a href="#ad498c51ecf4ee0b4482e5fe41cd52be7"></a><br/></td></tr>
<tr class="memitem:aabf6e0daf6f90f4052a44888f2bc3d7b"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="a00044.html">MolBond</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#aabf6e0daf6f90f4052a44888f2bc3d7b">mvpBond</a></td></tr>
<tr class="memdesc:aabf6e0daf6f90f4052a44888f2bc3d7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The list of bonds.  <a href="#aabf6e0daf6f90f4052a44888f2bc3d7b"></a><br/></td></tr>
<tr class="memitem:a9c195054308e17604a24a3127e0cb307"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="a00045.html">MolBondAngle</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a9c195054308e17604a24a3127e0cb307">mvpBondAngle</a></td></tr>
<tr class="memdesc:a9c195054308e17604a24a3127e0cb307"><td class="mdescLeft">&#160;</td><td class="mdescRight">The list of bond angles.  <a href="#a9c195054308e17604a24a3127e0cb307"></a><br/></td></tr>
<tr class="memitem:a21384a0b8be7bf3fc539c57d90d5c9a2"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="a00046.html">MolDihedralAngle</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a21384a0b8be7bf3fc539c57d90d5c9a2">mvpDihedralAngle</a></td></tr>
<tr class="memdesc:a21384a0b8be7bf3fc539c57d90d5c9a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The list of dihedral angles.  <a href="#a21384a0b8be7bf3fc539c57d90d5c9a2"></a><br/></td></tr>
<tr class="memitem:ad67f767fe62aeef49aef1c5760d69294"><td class="memItemLeft" align="right" valign="top">map&lt; <a class="el" href="a00043.html">MolAtom</a> *, std::vector<br class="typebreak"/>
&lt; <a class="el" href="a00044.html">MolBond</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#ad67f767fe62aeef49aef1c5760d69294">mvAtomBond</a></td></tr>
<tr class="memdesc:ad67f767fe62aeef49aef1c5760d69294"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of Bonds for each atom.  <a href="#ad67f767fe62aeef49aef1c5760d69294"></a><br/></td></tr>
<tr class="memitem:a43939b3e3ad83065cf7ccb6065a53a12"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="a00082.html">RigidGroup</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a43939b3e3ad83065cf7ccb6065a53a12">mvRigidGroup</a></td></tr>
<tr class="memdesc:a43939b3e3ad83065cf7ccb6065a53a12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rigid groups of atoms.  <a href="#a43939b3e3ad83065cf7ccb6065a53a12"></a><br/></td></tr>
<tr class="memitem:a35cb61305129b6bbda4a0bb014b2c90e"><td class="memItemLeft" align="right" valign="top">list&lt; <a class="el" href="a00048.html">MolRing</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a35cb61305129b6bbda4a0bb014b2c90e">mvRing</a></td></tr>
<tr class="memdesc:a35cb61305129b6bbda4a0bb014b2c90e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The list of rings.  <a href="#a35cb61305129b6bbda4a0bb014b2c90e"></a><br/></td></tr>
<tr class="memitem:a61b83701b288c4fdbcda97b14608af7d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00068.html">Quaternion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a61b83701b288c4fdbcda97b14608af7d">mQuat</a></td></tr>
<tr class="memdesc:a61b83701b288c4fdbcda97b14608af7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The unit quaternion defining the orientation.  <a href="#a61b83701b288c4fdbcda97b14608af7d"></a><br/></td></tr>
<tr class="memitem:a5b35796cbf31728b39b82c36badaa97b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a5b35796cbf31728b39b82c36badaa97b">mDeleteSubObjInDestructor</a></td></tr>
<tr class="memdesc:a5b35796cbf31728b39b82c36badaa97b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base Rotation amplitude (in radians) for the <a class="el" href="a00047.html" title="Molecule : class for complex scatterer descriptions using cartesian coordinates with bond length/angl...">Molecule</a>, so that the average atomic displacement is equal to 0.1 A.  <a href="#a5b35796cbf31728b39b82c36badaa97b"></a><br/></td></tr>
<tr class="memitem:a1c0fdb65e11dc8c46c525b18826e013c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1c0fdb65e11dc8c46c525b18826e013c"></a>
REAL&#160;</td><td class="memItemRight" valign="bottom"><b>mBaseRotationAmplitude</b></td></tr>
<tr class="memitem:a813452a36a4706a6590ec8be5e50d691"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a813452a36a4706a6590ec8be5e50d691"></a>
<a class="el" href="a00072.html">RefinableObjClock</a>&#160;</td><td class="memItemRight" valign="bottom"><b>mClockAtomList</b></td></tr>
<tr class="memitem:a4276d3c873b3b0a0c86fbaef9f362403"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4276d3c873b3b0a0c86fbaef9f362403"></a>
<a class="el" href="a00072.html">RefinableObjClock</a>&#160;</td><td class="memItemRight" valign="bottom"><b>mClockBondList</b></td></tr>
<tr class="memitem:a89305fe20d24689db9cef6165300cb3c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a89305fe20d24689db9cef6165300cb3c"></a>
<a class="el" href="a00072.html">RefinableObjClock</a>&#160;</td><td class="memItemRight" valign="bottom"><b>mClockBondAngleList</b></td></tr>
<tr class="memitem:a52cdc04f8a7e0b60f86c1ec6e1dd9c00"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a52cdc04f8a7e0b60f86c1ec6e1dd9c00"></a>
<a class="el" href="a00072.html">RefinableObjClock</a>&#160;</td><td class="memItemRight" valign="bottom"><b>mClockDihedralAngleList</b></td></tr>
<tr class="memitem:a031fb163482a63573aa2c0abb721a40c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a031fb163482a63573aa2c0abb721a40c"></a>
<a class="el" href="a00072.html">RefinableObjClock</a>&#160;</td><td class="memItemRight" valign="bottom"><b>mClockRigidGroup</b></td></tr>
<tr class="memitem:a779328aa75fbd492d25d8f1e78ba3120"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a779328aa75fbd492d25d8f1e78ba3120"></a>
<a class="el" href="a00072.html">RefinableObjClock</a>&#160;</td><td class="memItemRight" valign="bottom"><b>mClockAtomPosition</b></td></tr>
<tr class="memitem:aaa968c9d6b66e7f43784b6373333939d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaa968c9d6b66e7f43784b6373333939d"></a>
<a class="el" href="a00072.html">RefinableObjClock</a>&#160;</td><td class="memItemRight" valign="bottom"><b>mClockAtomScattPow</b></td></tr>
<tr class="memitem:a9bd4e0dabed314962e489a29ed20a33c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9bd4e0dabed314962e489a29ed20a33c"></a>
<a class="el" href="a00072.html">RefinableObjClock</a>&#160;</td><td class="memItemRight" valign="bottom"><b>mClockOrientation</b></td></tr>
<tr class="memitem:a853e81d1fd9916d2a8e6cfee07415f7a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a853e81d1fd9916d2a8e6cfee07415f7a"></a>
<a class="el" href="a00072.html">RefinableObjClock</a>&#160;</td><td class="memItemRight" valign="bottom"><b>mClockLogLikelihood</b></td></tr>
<tr class="memitem:a5ab45bcd6837946dde8ef134874ae02b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5ab45bcd6837946dde8ef134874ae02b"></a>
<a class="el" href="a00072.html">RefinableObjClock</a>&#160;</td><td class="memItemRight" valign="bottom"><b>mClockConnectivityTable</b></td></tr>
<tr class="memitem:ab19b748ec7e4ead2947027b2f38b60e2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab19b748ec7e4ead2947027b2f38b60e2"></a>
<a class="el" href="a00072.html">RefinableObjClock</a>&#160;</td><td class="memItemRight" valign="bottom"><b>mClockRingList</b></td></tr>
<tr class="memitem:abdfb80e948dc91137f5c568c99b1554a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abdfb80e948dc91137f5c568c99b1554a"></a>
<a class="el" href="a00072.html">RefinableObjClock</a>&#160;</td><td class="memItemRight" valign="bottom"><b>mClockRotorGroup</b></td></tr>
<tr class="memitem:a9654156a7376a5265c6555c23fa7316c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9654156a7376a5265c6555c23fa7316c"></a>
<a class="el" href="a00072.html">RefinableObjClock</a>&#160;</td><td class="memItemRight" valign="bottom"><b>mClockFlipGroup</b></td></tr>
<tr class="memitem:a0320d6fc63fdd2d3454f6c93e21fb82d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0320d6fc63fdd2d3454f6c93e21fb82d"></a>
<a class="el" href="a00072.html">RefinableObjClock</a>&#160;</td><td class="memItemRight" valign="bottom"><b>mClockStretchModeBondLength</b></td></tr>
<tr class="memitem:ae641b2ae58267ce842c21e9e2c631a7e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae641b2ae58267ce842c21e9e2c631a7e"></a>
<a class="el" href="a00072.html">RefinableObjClock</a>&#160;</td><td class="memItemRight" valign="bottom"><b>mClockStretchModeBondAngle</b></td></tr>
<tr class="memitem:ae932e4a8a69c7fb3422b703854478fc2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae932e4a8a69c7fb3422b703854478fc2"></a>
<a class="el" href="a00072.html">RefinableObjClock</a>&#160;</td><td class="memItemRight" valign="bottom"><b>mClockStretchModeTorsion</b></td></tr>
<tr class="memitem:a83e297fa4cd4f1bebe17b9cf26838b7f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a83e297fa4cd4f1bebe17b9cf26838b7f"></a>
<a class="el" href="a00072.html">RefinableObjClock</a>&#160;</td><td class="memItemRight" valign="bottom"><b>mClockStretchModeTwist</b></td></tr>
<tr class="memitem:acaeac88a7cea8c699fecb137337e9f2d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acaeac88a7cea8c699fecb137337e9f2d"></a>
<a class="el" href="a00072.html">RefinableObjClock</a>&#160;</td><td class="memItemRight" valign="bottom"><b>mClockMDAtomGroup</b></td></tr>
<tr class="memitem:ad176581e146e508869e67776f0e2e3d2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad176581e146e508869e67776f0e2e3d2"></a>
unsigned long&#160;</td><td class="memItemRight" valign="bottom"><b>mLocalParamSet</b></td></tr>
<tr class="memitem:a6fe920696fe0d0f811e35fe677c7b664"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6fe920696fe0d0f811e35fe677c7b664"></a>
unsigned long&#160;</td><td class="memItemRight" valign="bottom"><b>mRandomConformChangeNbTest</b></td></tr>
<tr class="memitem:a3a52a7e8ab51acbe58c21e5f2fac2f21"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3a52a7e8ab51acbe58c21e5f2fac2f21"></a>
unsigned long&#160;</td><td class="memItemRight" valign="bottom"><b>mRandomConformChangeNbAccept</b></td></tr>
<tr class="memitem:a78242220a03384972970306eab3c84cc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a78242220a03384972970306eab3c84cc"></a>
REAL&#160;</td><td class="memItemRight" valign="bottom"><b>mRandomConformChangeTemp</b></td></tr>
<tr class="memitem:ae424310a32f3ed915c33524e9c325549"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae424310a32f3ed915c33524e9c325549"></a>
REAL&#160;</td><td class="memItemRight" valign="bottom"><b>mLastLogLike</b></td></tr>
<tr class="memitem:a3a266d6dc8d55ee94717b0f2137f20ad"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3a266d6dc8d55ee94717b0f2137f20ad"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>mIsSelfOptimizing</b></td></tr>
<tr class="memitem:a35881bfb20092d0dcc424553f5671245"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00078.html">RefObjOpt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a35881bfb20092d0dcc424553f5671245">mFlexModel</a></td></tr>
<tr class="memdesc:a35881bfb20092d0dcc424553f5671245"><td class="mdescLeft">&#160;</td><td class="mdescRight">OPtion for the different types of flexibility possible for this molecule: rigid body, free atoms + restraints, torsion angles...  <a href="#a35881bfb20092d0dcc424553f5671245"></a><br/></td></tr>
<tr class="memitem:ae8459b9f767b0d8bc27b05140c604e0c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00078.html">RefObjOpt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#ae8459b9f767b0d8bc27b05140c604e0c">mAutoOptimizeConformation</a></td></tr>
<tr class="memdesc:ae8459b9f767b0d8bc27b05140c604e0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Option to automatically optimize the starting conformation, if the total restraint cost is too high.  <a href="#ae8459b9f767b0d8bc27b05140c604e0c"></a><br/></td></tr>
<tr class="memitem:a8c82ea548f4c0f29e868776c88c5eab8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00078.html">RefObjOpt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a8c82ea548f4c0f29e868776c88c5eab8">mOptimizeOrientation</a></td></tr>
<tr class="memdesc:a8c82ea548f4c0f29e868776c88c5eab8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Option to optimize the <a class="el" href="a00047.html" title="Molecule : class for complex scatterer descriptions using cartesian coordinates with bond length/angl...">Molecule</a>'s orientation.  <a href="#a8c82ea548f4c0f29e868776c88c5eab8"></a><br/></td></tr>
<tr class="memitem:a4ac986f017f968e59af58297b4a50d7f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4ac986f017f968e59af58297b4a50d7f"></a>
<a class="el" href="a00078.html">RefObjOpt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a4ac986f017f968e59af58297b4a50d7f">mMoleculeCenter</a></td></tr>
<tr class="memdesc:a4ac986f017f968e59af58297b4a50d7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Option to choose the center of rotation of the <a class="el" href="a00047.html" title="Molecule : class for complex scatterer descriptions using cartesian coordinates with bond length/angl...">Molecule</a> for the global orientation either as the geometrical center, or as a given atom. <br/></td></tr>
<tr class="memitem:a924f7062c1e35790e152a35166121266"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a924f7062c1e35790e152a35166121266"></a>
const <a class="el" href="a00043.html">MolAtom</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a924f7062c1e35790e152a35166121266">mpCenterAtom</a></td></tr>
<tr class="memdesc:a924f7062c1e35790e152a35166121266"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a00008.html" title="The basic atom scatterer, in a crystal.">Atom</a> chosen as center of rotation, if mRotationCenter is set to use an atom rather than the geometrical center. <br/></td></tr>
<tr class="memitem:a13cffa530711a868859cfcfc17bce069"><td class="memItemLeft" align="right" valign="top">map&lt; <a class="el" href="a00043.html">MolAtom</a> *, set&lt; <a class="el" href="a00043.html">MolAtom</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a13cffa530711a868859cfcfc17bce069">mConnectivityTable</a></td></tr>
<tr class="memdesc:a13cffa530711a868859cfcfc17bce069"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connectivity table: for each atom, keep the list of atoms bonded to it.  <a href="#a13cffa530711a868859cfcfc17bce069"></a><br/></td></tr>
<tr class="memitem:afc51d36109a8d96a626f3c2251345c13"><td class="memItemLeft" align="right" valign="top">list&lt; <a class="el" href="a00083.html">RotorGroup</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#afc51d36109a8d96a626f3c2251345c13">mvRotorGroupTorsion</a></td></tr>
<tr class="memdesc:afc51d36109a8d96a626f3c2251345c13"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of RotorGroups corresponding to free torsion bonds.  <a href="#afc51d36109a8d96a626f3c2251345c13"></a><br/></td></tr>
<tr class="memitem:a22a07ddc2dbfeb90238b29bcca1e915d"><td class="memItemLeft" align="right" valign="top">list&lt; <a class="el" href="a00083.html">RotorGroup</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a22a07ddc2dbfeb90238b29bcca1e915d">mvRotorGroupTorsionSingleChain</a></td></tr>
<tr class="memdesc:a22a07ddc2dbfeb90238b29bcca1e915d"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of RotorGroups corresponding to free torsion bonds, but with only one chain of atoms listed.  <a href="#a22a07ddc2dbfeb90238b29bcca1e915d"></a><br/></td></tr>
<tr class="memitem:ac54d8a074549f7710a1823b0ecefcde8"><td class="memItemLeft" align="right" valign="top">list&lt; <a class="el" href="a00083.html">RotorGroup</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#ac54d8a074549f7710a1823b0ecefcde8">mvRotorGroupInternal</a></td></tr>
<tr class="memdesc:ac54d8a074549f7710a1823b0ecefcde8"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of RotorGroups for internal rotations.  <a href="#ac54d8a074549f7710a1823b0ecefcde8"></a><br/></td></tr>
<tr class="memitem:a79ffe8ba3222a5f4a56fd9f2447c8fd7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a79ffe8ba3222a5f4a56fd9f2447c8fd7"></a>
list&lt; <a class="el" href="a00027.html">FlipGroup</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a79ffe8ba3222a5f4a56fd9f2447c8fd7">mvFlipGroup</a></td></tr>
<tr class="memdesc:a79ffe8ba3222a5f4a56fd9f2447c8fd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The list of FlipGroups. <br/></td></tr>
<tr class="memitem:aa3e38a39a6a392456c03f320e1bdaffa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa3e38a39a6a392456c03f320e1bdaffa"></a>
list&lt; <a class="el" href="a00099.html">StretchModeBondLength</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#aa3e38a39a6a392456c03f320e1bdaffa">mvStretchModeBondLength</a></td></tr>
<tr class="memdesc:aa3e38a39a6a392456c03f320e1bdaffa"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of <a class="el" href="a00099.html" title="Group of atoms for random moves changing a bond length.">StretchModeBondLength</a>. <br/></td></tr>
<tr class="memitem:a5673efb9ae9ffc238f25c62805825c63"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5673efb9ae9ffc238f25c62805825c63"></a>
list&lt; <a class="el" href="a00098.html">StretchModeBondAngle</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a5673efb9ae9ffc238f25c62805825c63">mvStretchModeBondAngle</a></td></tr>
<tr class="memdesc:a5673efb9ae9ffc238f25c62805825c63"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of <a class="el" href="a00099.html" title="Group of atoms for random moves changing a bond length.">StretchModeBondLength</a>. <br/></td></tr>
<tr class="memitem:a878336f175d85a68d55804ad43a453dc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a878336f175d85a68d55804ad43a453dc"></a>
list&lt; <a class="el" href="a00101.html">StretchModeTorsion</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a878336f175d85a68d55804ad43a453dc">mvStretchModeTorsion</a></td></tr>
<tr class="memdesc:a878336f175d85a68d55804ad43a453dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of <a class="el" href="a00099.html" title="Group of atoms for random moves changing a bond length.">StretchModeBondLength</a>. <br/></td></tr>
<tr class="memitem:a53def8e47e265fc3dd62af4b07997bd1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a53def8e47e265fc3dd62af4b07997bd1"></a>
list&lt; <a class="el" href="a00102.html">StretchModeTwist</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a53def8e47e265fc3dd62af4b07997bd1">mvStretchModeTwist</a></td></tr>
<tr class="memdesc:a53def8e47e265fc3dd62af4b07997bd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of <a class="el" href="a00102.html" title="Atoms moved *between* two other atoms, using a &quot;twist&quot;  *of their positions - only small twists of th...">StretchModeTwist</a>. <br/></td></tr>
<tr class="memitem:a215591f48317322bb1b9203ebad4a011"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a215591f48317322bb1b9203ebad4a011"></a>
std::list&lt; <a class="el" href="a00097.html">StretchMode</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a215591f48317322bb1b9203ebad4a011">mvpStretchModeFree</a></td></tr>
<tr class="memdesc:a215591f48317322bb1b9203ebad4a011"><td class="mdescLeft">&#160;</td><td class="mdescRight">Groups of <a class="el" href="a00097.html" title="Abstract base Stretch Mode for Molecule objects.">StretchMode</a> not breaking any restraint (unless the one they are associated to) <br/></td></tr>
<tr class="memitem:ae87a1cece989dc3d433eb7fad925c5de"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae87a1cece989dc3d433eb7fad925c5de"></a>
std::list&lt; <a class="el" href="a00097.html">StretchMode</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#ae87a1cece989dc3d433eb7fad925c5de">mvpStretchModeNotFree</a></td></tr>
<tr class="memdesc:ae87a1cece989dc3d433eb7fad925c5de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Groups of <a class="el" href="a00097.html" title="Abstract base Stretch Mode for Molecule objects.">StretchMode</a> breaking restraints (beyond the one they are associated to) <br/></td></tr>
<tr class="memitem:a4a3a91c91753e90de67341701df7e081"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4a3a91c91753e90de67341701df7e081"></a>
list&lt; <a class="el" href="a00042.html">MDAtomGroup</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a4a3a91c91753e90de67341701df7e081">mvMDAtomGroup</a></td></tr>
<tr class="memdesc:a4a3a91c91753e90de67341701df7e081"><td class="mdescLeft">&#160;</td><td class="mdescRight">Groups of atoms that should be moved according to molecular dynamics principles. <br/></td></tr>
<tr class="memitem:af3e1420d9c1c4cc3be0e58c5834130e7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af3e1420d9c1c4cc3be0e58c5834130e7"></a>
std::set&lt; <a class="el" href="a00043.html">MolAtom</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#af3e1420d9c1c4cc3be0e58c5834130e7">mvMDFullAtomGroup</a></td></tr>
<tr class="memdesc:af3e1420d9c1c4cc3be0e58c5834130e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Full list of atoms that can be moved using molecular dynamics This excludes any atom part of a rigid group. <br/></td></tr>
<tr class="memitem:aee36f14d21f12d10581eaaf689136304"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aee36f14d21f12d10581eaaf689136304"></a>
REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#aee36f14d21f12d10581eaaf689136304">mMDMoveFreq</a></td></tr>
<tr class="memdesc:aee36f14d21f12d10581eaaf689136304"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frequency of using molecular dynamics move during <a class="el" href="a00047.html#a11e623f6482b468f6dd05fc0ab2bbb24" title="Make a random move of the current configuration.">GlobalOptRandomMove()</a> <br/></td></tr>
<tr class="memitem:a600a62199c1e9297d39a53848a155310"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a600a62199c1e9297d39a53848a155310"></a>
REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a600a62199c1e9297d39a53848a155310">mMDMoveEnergy</a></td></tr>
<tr class="memdesc:a600a62199c1e9297d39a53848a155310"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relative energy of molecule during molecular dynamics move Default: 40, 10 (slow conformation change), 200 (large changes) <br/></td></tr>
<tr class="memitem:a45e0d1e1d54f4474158f270571957d4a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a45e0d1e1d54f4474158f270571957d4a"></a>
std::vector&lt; <a class="el" href="a00049.html">MolZAtom</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a45e0d1e1d54f4474158f270571957d4a">mAsZMatrix</a></td></tr>
<tr class="memdesc:a45e0d1e1d54f4474158f270571957d4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="a00047.html" title="Molecule : class for complex scatterer descriptions using cartesian coordinates with bond length/angl...">Molecule</a>, as a lightweight ZMatrix, for export purposes. <br/></td></tr>
<tr class="memitem:aca5a25791960a8aa011c1cfa902c589a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aca5a25791960a8aa011c1cfa902c589a"></a>
REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#aca5a25791960a8aa011c1cfa902c589a">mLogLikelihood</a></td></tr>
<tr class="memdesc:aca5a25791960a8aa011c1cfa902c589a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The current log(likelihood) <br/></td></tr>
<tr class="memitem:a7e69eecc5aa10a9908c3a6450cc2540b"><td class="memItemLeft" align="right" valign="top">REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a7e69eecc5aa10a9908c3a6450cc2540b">mLogLikelihoodScale</a></td></tr>
<tr class="memdesc:a7e69eecc5aa10a9908c3a6450cc2540b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scale (multiplier) for the log(likelihood)  <a href="#a7e69eecc5aa10a9908c3a6450cc2540b"></a><br/></td></tr>
<tr class="memitem:a9e9be5fe3d3037cdf690df16235e370d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9e9be5fe3d3037cdf690df16235e370d"></a>
CrystVector_REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a9e9be5fe3d3037cdf690df16235e370d">mLSQCalc</a></td></tr>
<tr class="memdesc:a9e9be5fe3d3037cdf690df16235e370d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current LSQ Calc - one value for each restraint (bond distance, angle or dihedral angle) <br/></td></tr>
<tr class="memitem:a6202acc4d02c90999f008c089bf1b21e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6202acc4d02c90999f008c089bf1b21e"></a>
CrystVector_REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a6202acc4d02c90999f008c089bf1b21e">mLSQObs</a></td></tr>
<tr class="memdesc:a6202acc4d02c90999f008c089bf1b21e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current LSQ Calc - one value for each restraint (bond distance, angle or dihedral angle ideal values) <br/></td></tr>
<tr class="memitem:a7305a71a61c7ceedaf09b28a0d1ed64d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7305a71a61c7ceedaf09b28a0d1ed64d"></a>
CrystVector_REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a7305a71a61c7ceedaf09b28a0d1ed64d">mLSQWeight</a></td></tr>
<tr class="memdesc:a7305a71a61c7ceedaf09b28a0d1ed64d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current LSQ Calc - one value for each restraint(bond distance, angle or dihedral angle sigmas) <br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_a00085"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_a00085')"><img src="closed.png" alt="-"/>&nbsp;Protected Member Functions inherited from <a class="el" href="a00085.html">ObjCryst::Scatterer</a></td></tr>
<tr class="memitem:a0142f5a84db948319c3ff310315c8599 inherit pro_methods_a00085"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00085.html#a0142f5a84db948319c3ff310315c8599">InitRGBColour</a> ()</td></tr>
<tr class="memdesc:a0142f5a84db948319c3ff310315c8599 inherit pro_methods_a00085"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get RGB Colour coordinates from Colour Name.  <a href="#a0142f5a84db948319c3ff310315c8599"></a><br/></td></tr>
<tr class="memitem:a204e5b5ba54b967074c6de965940b00e inherit pro_methods_a00085"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a204e5b5ba54b967074c6de965940b00e"></a>
const <a class="el" href="a00072.html">RefinableObjClock</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00085.html#a204e5b5ba54b967074c6de965940b00e">GetClockScattCompList</a> () const </td></tr>
<tr class="memdesc:a204e5b5ba54b967074c6de965940b00e inherit pro_methods_a00085"><td class="mdescLeft">&#160;</td><td class="mdescRight">Last time the <a class="el" href="a00087.html" title="list of scattering positions in a crystal, associated with the corresponding occupancy and a pointer ...">ScatteringComponentList</a> was generated. <br/></td></tr>
<tr class="inherit_header pro_attribs_a00085"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_a00085')"><img src="closed.png" alt="-"/>&nbsp;Protected Attributes inherited from <a class="el" href="a00085.html">ObjCryst::Scatterer</a></td></tr>
<tr class="memitem:a9cc523b07c82846bf0ddc3ce0e74bcc6 inherit pro_attribs_a00085"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9cc523b07c82846bf0ddc3ce0e74bcc6"></a>
CrystVector_REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00085.html#a9cc523b07c82846bf0ddc3ce0e74bcc6">mXYZ</a></td></tr>
<tr class="memdesc:a9cc523b07c82846bf0ddc3ce0e74bcc6 inherit pro_attribs_a00085"><td class="mdescLeft">&#160;</td><td class="mdescRight">coordinates of the scatterer (or of its center..) <br/></td></tr>
<tr class="memitem:ae51b357e1cf9f523994f0e08c70bb489 inherit pro_attribs_a00085"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae51b357e1cf9f523994f0e08c70bb489"></a>
REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00085.html#ae51b357e1cf9f523994f0e08c70bb489">mOccupancy</a></td></tr>
<tr class="memdesc:ae51b357e1cf9f523994f0e08c70bb489 inherit pro_attribs_a00085"><td class="mdescLeft">&#160;</td><td class="mdescRight">Occupancy : 0 &lt;= occ &lt;= 1 For a multi-atom scatterer (polyhedron,..), this is the <b>overall</b> occupancy of the scatterer (affects all components of the scatterer). <br/></td></tr>
<tr class="memitem:a1d1166aabc3a811ca70e37d2ad03ba05 inherit pro_attribs_a00085"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1d1166aabc3a811ca70e37d2ad03ba05"></a>
string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00085.html#a1d1166aabc3a811ca70e37d2ad03ba05">mColourName</a></td></tr>
<tr class="memdesc:a1d1166aabc3a811ca70e37d2ad03ba05 inherit pro_attribs_a00085"><td class="mdescLeft">&#160;</td><td class="mdescRight">Colour for this scatterer (from POVRay) <br/></td></tr>
<tr class="memitem:ab62464d3d132a8e70f283648ae9ea020 inherit pro_attribs_a00085"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab62464d3d132a8e70f283648ae9ea020"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00085.html#ab62464d3d132a8e70f283648ae9ea020">mColourRGB</a> [3]</td></tr>
<tr class="memdesc:ab62464d3d132a8e70f283648ae9ea020 inherit pro_attribs_a00085"><td class="mdescLeft">&#160;</td><td class="mdescRight">Colour for this scatterer using RGB. <br/></td></tr>
<tr class="memitem:ace0238cbbd28dd0adb9e6102bc2b8cae inherit pro_attribs_a00085"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ace0238cbbd28dd0adb9e6102bc2b8cae"></a>
<a class="el" href="a00072.html">RefinableObjClock</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00085.html#ace0238cbbd28dd0adb9e6102bc2b8cae">mClockScatterer</a></td></tr>
<tr class="memdesc:ace0238cbbd28dd0adb9e6102bc2b8cae inherit pro_attribs_a00085"><td class="mdescLeft">&#160;</td><td class="mdescRight">Last time anything (number of atoms, positions, scattering power) was changed. <br/></td></tr>
<tr class="memitem:a807f373561fbd1c460b0dfc40924e542 inherit pro_attribs_a00085"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00072.html">RefinableObjClock</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00085.html#a807f373561fbd1c460b0dfc40924e542">mClockScattCompList</a></td></tr>
<tr class="memitem:a359e6115a710c44bf340f439a17cb073 inherit pro_attribs_a00085"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00020.html">Crystal</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00085.html#a359e6115a710c44bf340f439a17cb073">mpCryst</a></td></tr>
<tr class="memdesc:a359e6115a710c44bf340f439a17cb073 inherit pro_attribs_a00085"><td class="mdescLeft">&#160;</td><td class="mdescRight">The crystal in which the <a class="el" href="a00085.html" title="Generic type of scatterer: can be an atom, or a more complex assembly of atoms.">Scatterer</a> is This is needed so that we can know which scattering powers are available in the crystal, and also to convert fractionnal to orthonormal coordinates (for some scatterers only).  <a href="#a359e6115a710c44bf340f439a17cb073"></a><br/></td></tr>
</table>
<a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p><a class="el" href="a00047.html" title="Molecule : class for complex scatterer descriptions using cartesian coordinates with bond length/angl...">Molecule</a> : class for complex scatterer descriptions using cartesian coordinates with bond length/angle restraints, and moves either of individual atoms or using torsion bonds. </p>
<p>This can also be used for non-organic compounds (polyhedras etc...) </p>
<dl class="section note"><dt>Note</dt><dd>the parametrization is very different from <a class="el" href="a00156.html" title="ZScatterer: the basic type of complex scatterers, where atom positions are defined using a standard &quot;...">ZScatterer</a>: we keep a list of x,y,z which do not use limits (they must not), but the coordinates must be restrained or constrained from the expected bond lengths, angles and dihedral angles. The list of parameters is re-created in <a class="el" href="a00047.html#a5fbdadb37966f382a6e33150285819dc" title="This should be called by any optimization class at the begining of an optimization.">BeginOptimization()</a> (except for the global x y z parameters for the global position of the <a class="el" href="a00047.html" title="Molecule : class for complex scatterer descriptions using cartesian coordinates with bond length/angl...">Molecule</a>, in fractionnal coordinates).</dd>
<dd>
: all atoms must be somehow connected </dd></dl>
</div><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ad4132a293e7f253c730676ed3720f961"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ObjCryst::Molecule::Molecule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00020.html">Crystal</a> &amp;&#160;</td>
          <td class="paramname"><em>cryst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>

</div>
</div>
<a class="anchor" id="a896c80a621aa990de3d36e214965cd49"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ObjCryst::Molecule::Molecule </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00047.html">Molecule</a> &amp;&#160;</td>
          <td class="paramname"><em>old</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy constructor. </p>

</div>
</div>
<a class="anchor" id="ae61d3a9a72c73cd087e330b3c4cdf0be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ObjCryst::Molecule::~Molecule </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<h2>Member Function Documentation</h2>
<a class="anchor" id="a7b193eac062233b758887cba671706f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ObjCryst::Molecule::AddAtom </td>
          <td>(</td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00090.html">ScatteringPower</a> *&#160;</td>
          <td class="paramname"><em>pPow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>updateDisplay</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add an atom. </p>

</div>
</div>
<a class="anchor" id="aa37feb3abde7ca0ff6453b97d910800f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ObjCryst::Molecule::AddBond </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00043.html">MolAtom</a> &amp;&#160;</td>
          <td class="paramname"><em>atom1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00043.html">MolAtom</a> &amp;&#160;</td>
          <td class="paramname"><em>atom2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>delta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>bondOrder</em> = <code>1.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>updateDisplay</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a bond. </p>

</div>
</div>
<a class="anchor" id="a25132c259da4d0bd739ff0ffc008575e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ObjCryst::Molecule::AddBondAngle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00043.html">MolAtom</a> &amp;&#160;</td>
          <td class="paramname"><em>atom1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00043.html">MolAtom</a> &amp;&#160;</td>
          <td class="paramname"><em>atom2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00043.html">MolAtom</a> &amp;&#160;</td>
          <td class="paramname"><em>atom3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>delta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>updateDisplay</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a bond angle restraint. </p>

</div>
</div>
<a class="anchor" id="aae30adce9fdd16e42cab4f8e434f01cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ObjCryst::Molecule::AddDihedralAngle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00043.html">MolAtom</a> &amp;&#160;</td>
          <td class="paramname"><em>atom1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00043.html">MolAtom</a> &amp;&#160;</td>
          <td class="paramname"><em>atom2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00043.html">MolAtom</a> &amp;&#160;</td>
          <td class="paramname"><em>atom3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00043.html">MolAtom</a> &amp;&#160;</td>
          <td class="paramname"><em>atom4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>delta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>updateDisplay</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a dihedral angle restraint. </p>

</div>
</div>
<a class="anchor" id="a8c61827ad3303aca5c0db6698a5f9e06"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ObjCryst::Molecule::AddRigidGroup </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00082.html">RigidGroup</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>updateDisplay</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a rigid group of atoms. </p>
<p>See <a class="el" href="a00047.html#a43939b3e3ad83065cf7ccb6065a53a12" title="Rigid groups of atoms.">Molecule::mvRigidGroup</a> </p>

</div>
</div>
<a class="anchor" id="a3ce93bef9ea4da4d5e0cd47e62418a97"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="a00049.html">MolZAtom</a>&gt;&amp; ObjCryst::Molecule::AsZMatrix </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>keeporder</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="a00047.html" title="Molecule : class for complex scatterer descriptions using cartesian coordinates with bond length/angl...">Molecule</a> as Z-matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keeporder,:</td><td>if true, the order of the atoms is exactly the same as in the <a class="el" href="a00047.html" title="Molecule : class for complex scatterer descriptions using cartesian coordinates with bond length/angl...">Molecule</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5fbdadb37966f382a6e33150285819dc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ObjCryst::Molecule::BeginOptimization </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>allowApproximations</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>enableRestraints</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This should be called by any optimization class at the begining of an optimization. </p>
<p>This will also check that everything is ready, eg call the <a class="el" href="a00071.html#a48d11671e7f8699f7bc24077585c5e0f">RefinableObj::Prepare()</a> function. This also affects all sub-objects. </p>
<dl class="section note"><dt>Note</dt><dd>this may be called several time for some objects which are used by several other objects, or for nested optimizations (e.g. least-squares optimizations inside a global one).</dd>
<dd>
<a class="el" href="a00047.html#aec0a3ba0d08fdfed38cc757efb635ffb" title="This should be called by any optimization class at the end of an optimization.">EndOptimization()</a> must be called at the end of the optimization, the same number of time <a class="el" href="a00047.html#a5fbdadb37966f382a6e33150285819dc" title="This should be called by any optimization class at the begining of an optimization.">BeginOptimization()</a> was called !</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allowApproximations,:</td><td>if true, then the object can use faster but less precise functions during the optimization. This is useful for global optimization not using derivatives. </td></tr>
    <tr><td class="paramname">enableRestraints,:</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="a00223.html#_deprecated000028">Deprecated:</a></b></dt><dd>if true, then restrained parameters will be allowed to go beyond theur hard limits. This implies that the algorithm will take into account the cost (penalty) related to the restraints. Objects which do not use restraints will simply ignore this. WARNING: this parameter may be removed with the new likelihood scheme. </dd></dl>

<p>Reimplemented from <a class="el" href="a00071.html#ababd8f2916e41a20d2c1b21f6ffefe96">ObjCryst::RefinableObj</a>.</p>

</div>
</div>
<a class="anchor" id="ad6e27c1557962b32355eeadf1bf155d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">REAL ObjCryst::Molecule::BondAngleRandomChange </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00098.html">StretchModeBondAngle</a> &amp;&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>amplitude</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>respectRestraint</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>change a bond angle, while respecting the <a class="el" href="a00081.html" title="Restraint: generic class for a restraint of a given model.">Restraint</a> (if any). </p>
<dl class="section return"><dt>Returns</dt><dd>the <em>actual</em> change in bond angle. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"></td><td>the desired angular change. This will be the actual change <em>if</em> there is no restraint <em>or</em> if the restraint is constant in this range. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad7bfddcdf21c1214c5a70c84fc54cdb0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">REAL ObjCryst::Molecule::BondLengthRandomChange </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00099.html">StretchModeBondLength</a> &amp;&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>amplitude</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>respectRestraint</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stretch a bond, while respecting the <a class="el" href="a00081.html" title="Restraint: generic class for a restraint of a given model.">Restraint</a> (if any). </p>
<dl class="section return"><dt>Returns</dt><dd>the <em>actual</em> change in bond length. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"></td><td>the desired change in bond length. This will be the actual change <em>if</em> there is no restraint <em>or</em> if the restraint is constant in this range. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac52190dc78f14df37e9bc5b3c9d713c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ObjCryst::Molecule::BuildConnectivityTable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build the Connectivity table. </p>

</div>
</div>
<a class="anchor" id="aca2ed46d26209807d587722d131c6315"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ObjCryst::Molecule::BuildFlipGroup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build the groups of atoms that can be flipped. </p>
<p>This is not const because we temporarily modify the molecule conformation to test which FlipGroups are forbidden by restraints (but it should be const). </p>

</div>
</div>
<a class="anchor" id="a0944a68727d85bee4ec0cce453cb451c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ObjCryst::Molecule::BuildMDAtomGroups </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find groups of atoms that cannot be moved relatively to each other using the free or non-free stretch modes. </p>
<p>Usually these will correspond to atoms inside a flexible ring.</p>
<p>These atoms (if they are not in a rigid group) are stored in a <a class="el" href="a00042.html" title="Groups of atoms that can be moved using molecular dynamics principles, taking a list of restraints as...">MDAtomGroup</a> so that they can still move using molecular dynamics.</p>
<p><b>this</b> should be called after <a class="el" href="a00047.html#a83b7b9bac2ce9fe7b310b5267232b1ca" title="Separate StretchMode that break more than their assigned restraint from others.">BuildStretchModeGroups()</a>, to make sure the list of free/non-free stretch mode has been built. </p>

</div>
</div>
<a class="anchor" id="a9623bff2259d45c162ed28af73974f5a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ObjCryst::Molecule::BuildRingList </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build the list of rings in the molecule. </p>
<p>The list is <em>only</em> rebuilt if the bond or atom list has changed,so it should be safe to call again this function.</p>
<dl class="section note"><dt>Note</dt><dd>So far this is a const method as the ring list just reflects the bond list and therefore is mutable (see <a class="el" href="a00047.html#a35cb61305129b6bbda4a0bb014b2c90e" title="The list of rings.">Molecule::mvRing</a>)... but maybe this could change... </dd></dl>

</div>
</div>
<a class="anchor" id="a3642fa8104faa1ce84a977600f9d1aeb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ObjCryst::Molecule::BuildRotorGroup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build the groups of atoms that will be rotated during global optimization. </p>
<p>This is not const because we temporarily modify the molecule conformation to test which RotorGroups are forbidden by restraints (but it should be const). </p>

</div>
</div>
<a class="anchor" id="a83b7b9bac2ce9fe7b310b5267232b1ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ObjCryst::Molecule::BuildStretchModeGroups </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Separate <a class="el" href="a00097.html" title="Abstract base Stretch Mode for Molecule objects.">StretchMode</a> that break more than their assigned restraint from others. </p>
<p>See <a class="el" href="a00047.html#a215591f48317322bb1b9203ebad4a011" title="Groups of StretchMode not breaking any restraint (unless the one they are associated to)...">Molecule::mvpStretchModeFree</a> and <a class="el" href="a00047.html#ae87a1cece989dc3d433eb7fad925c5de" title="Groups of StretchMode breaking restraints (beyond the one they are associated to)">Molecule::mvpStretchModeNotFree</a> </p>

</div>
</div>
<a class="anchor" id="a7f4c6bf6e5be59780cb7844e53711fb3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ObjCryst::Molecule::BuildStretchModeTwist </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build the groups of atoms used to twist internally the <a class="el" href="a00047.html" title="Molecule : class for complex scatterer descriptions using cartesian coordinates with bond length/angl...">Molecule</a>, e.g. </p>
<p>by rotating one chain of atoms between 2 given atoms. </p>

</div>
</div>
<a class="anchor" id="a96728865d25881151b7010d3eaf4ec0f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="a00047.html">Molecule</a>* ObjCryst::Molecule::CreateCopy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>so-called Virtual copy constructor, needed to make copies of arrays of Scatterers </p>

<p>Implements <a class="el" href="a00085.html#a4d374adcff97163a24492d362f6def73">ObjCryst::Scatterer</a>.</p>

</div>
</div>
<a class="anchor" id="afd88ae76ab528b5dc37f9d2527353904"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">REAL ObjCryst::Molecule::DihedralAngleRandomChange </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00101.html">StretchModeTorsion</a> &amp;&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>amplitude</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>respectRestraint</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change a dihedral angle, while respecting the <a class="el" href="a00081.html" title="Restraint: generic class for a restraint of a given model.">Restraint</a> (if any). </p>
<dl class="section return"><dt>Returns</dt><dd>the <em>actual</em> change in bond angle. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"></td><td>the desired angular change. This will be the actual change <em>if</em> there is no restraint <em>or</em> if the restraint is constant in this range. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aec0a3ba0d08fdfed38cc757efb635ffb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ObjCryst::Molecule::EndOptimization </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This should be called by any optimization class at the end of an optimization. </p>
<p>This also affects all sub-objects. </p>
<dl class="section note"><dt>Note</dt><dd>this may be called several time for some objects which are used by several other objects. </dd></dl>

<p>Reimplemented from <a class="el" href="a00071.html#ab0035f6164cb24ace67b51b11993a851">ObjCryst::RefinableObj</a>.</p>

</div>
</div>
<a class="anchor" id="a20b6239624acf37e771e29c002f63618"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;<a class="el" href="a00043.html">MolAtom</a>*&gt;::reverse_iterator ObjCryst::Molecule::FindAtom </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search a <a class="el" href="a00043.html" title="MolAtom : atom inside a Molecule.">MolAtom</a> from its name. </p>
<p>Search begins at the end, and the first match is returned. returns mvAtom.rend() if no atom matches </p>

</div>
</div>
<a class="anchor" id="a10cb2cff89dd623e288cfa3376acfcfa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;<a class="el" href="a00043.html">MolAtom</a>*&gt;::const_reverse_iterator ObjCryst::Molecule::FindAtom </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search a <a class="el" href="a00043.html" title="MolAtom : atom inside a Molecule.">MolAtom</a> from its name. </p>
<p>Search begins at the end, and the first match is returned. returns mvAtom.rend() if no atom matches </p>

</div>
</div>
<a class="anchor" id="ac121a84c148439786581a103eef4d958"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;<a class="el" href="a00044.html">MolBond</a>*&gt;::const_iterator ObjCryst::Molecule::FindBond </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00043.html">MolAtom</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00043.html">MolAtom</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Searches whether a bond between two atoms already exists. </p>
<p>If no bond is found, returns Molecule::mvpAtom.end(). </p>

</div>
</div>
<a class="anchor" id="a099aadd8edb91f148a174333b1636fb5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;<a class="el" href="a00044.html">MolBond</a>*&gt;::iterator ObjCryst::Molecule::FindBond </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00043.html">MolAtom</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00043.html">MolAtom</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Searches whether a bond between two atoms already exists. </p>
<p>If no bond is found, returns Molecule::mvpAtom.end(). </p>

</div>
</div>
<a class="anchor" id="aa94113e3d0ca15f5a3acbc573198fd59"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;<a class="el" href="a00045.html">MolBondAngle</a>*&gt;::const_iterator ObjCryst::Molecule::FindBondAngle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00043.html">MolAtom</a> &amp;&#160;</td>
          <td class="paramname"><em>at1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00043.html">MolAtom</a> &amp;&#160;</td>
          <td class="paramname"><em>at0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00043.html">MolAtom</a> &amp;&#160;</td>
          <td class="paramname"><em>at2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Searches whether a bond between three atoms already exists, searching for either (at1,at2,at3) and (at3,at2,at1), as these are equivalent. </p>
<p>If no bond angle is found, returns Molecule::mvpBondAngle.end(). </p>

</div>
</div>
<a class="anchor" id="adb251aaa9a4f9e4e1b7e949e2fab73e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;<a class="el" href="a00046.html">MolDihedralAngle</a>*&gt;::const_iterator ObjCryst::Molecule::FindDihedralAngle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00043.html">MolAtom</a> &amp;&#160;</td>
          <td class="paramname"><em>at1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00043.html">MolAtom</a> &amp;&#160;</td>
          <td class="paramname"><em>at2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00043.html">MolAtom</a> &amp;&#160;</td>
          <td class="paramname"><em>at3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00043.html">MolAtom</a> &amp;&#160;</td>
          <td class="paramname"><em>at4</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Searches whether a dihedral between four atoms already exists, searching for either (at1,at2,at3,at4) and (at4,at3,at2,at1), as these are equivalent. </p>
<p>If no dihedral angle is found, returns Molecule::mvpDihedralAngle.end(). </p>

</div>
</div>
<a class="anchor" id="a58e298d1cefcf677748b9c6807956f4a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a00043.html">MolAtom</a>* ObjCryst::Molecule::GetCenterAtom </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the atom defining the origin of the <a class="el" href="a00047.html" title="Molecule : class for complex scatterer descriptions using cartesian coordinates with bond length/angl...">Molecule</a> Equal to 0 if no atom as been set. </p>

</div>
</div>
<a class="anchor" id="a7f0f1ae6670032f5afc9ccf65d45f8c4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const string&amp; ObjCryst::Molecule::GetClassName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Name for this class ("RefinableObj", "Crystal",...). </p>
<p>This is only useful to distinguish different classes when picking up objects from the <a class="el" href="a00071.html" title="Generic Refinable Object.">RefinableObj</a> Global Registry </p>

<p>Reimplemented from <a class="el" href="a00085.html#a374fc1bb2887ab1f61d456326d97c05f">ObjCryst::Scatterer</a>.</p>

</div>
</div>
<a class="anchor" id="a8dae19447740afaa1780e39a61f625c9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual string ObjCryst::Molecule::GetComponentName </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Name for the i-th component of this scatterer. </p>
<p>If the component is an <a class="el" href="a00008.html" title="The basic atom scatterer, in a crystal.">Atom</a>, Then the name is that of the atom. Else, it is the name of the scatterer plus the component number in the scatterer plus the name of the <a class="el" href="a00090.html" title="Abstract Base Class to describe the scattering power of any Scatterer component in a crystal...">ScatteringPower</a>. </p>
<dl class="section note"><dt>Note</dt><dd>It would be better to return a reference, but we don't want to keep a name for all components... Weeelll, needs some more thinking... see what performance hit results (if any).</dd></dl>
<dl class="bug"><dt><b><a class="el" href="a00224.html#_bug000001">Bug:</a></b></dt><dd>does not take into account dummy atoms !! </dd></dl>

<p>Implements <a class="el" href="a00085.html#a42bdf508da6a90859a5a61e16c27d47e">ObjCryst::Scatterer</a>.</p>

</div>
</div>
<a class="anchor" id="a1c0e8ad2410035c07c4be88315554f3f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual REAL ObjCryst::Molecule::GetLogLikelihood </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get -log(likelihood) of the current configuration for the object. </p>
<p>By default (no likelihood evaluation available), this is equal to 0.</p>
<p>This call should not be recursive, it is the task of the algorithm to get the sum of likelihoods for all objects invlolved.</p>
<dl class="section note"><dt>Note</dt><dd>contrary to the old "Cost Function" approach, with log(Likelihood) there is no 'choice' of cost function, so that it is the task of the object to give the optimized likelihood (possibly with user options).</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>: this is in under heavy development, so expect changes... </dd></dl>

<p>Reimplemented from <a class="el" href="a00071.html#a9a9a5ea2b997cd36b44ed35c2bab3245">ObjCryst::RefinableObj</a>.</p>

</div>
</div>
<a class="anchor" id="adef00ca72bec0e4553bbfba0852e1ba1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const CrystVector_REAL&amp; ObjCryst::Molecule::GetLSQDeriv </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>int</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00073.html">RefinablePar</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the first derivative values for the LSQ function, for a given parameter. </p>
<p>Note that the default method in the base <a class="el" href="a00071.html" title="Generic Refinable Object.">RefinableObj</a> class is to use numerical derivatives, so it should be overridden for better precision.</p>
<dl class="todo"><dt><b><a class="el" href="a00222.html#_todo000025">Todo:</a></b></dt><dd>This should be a const method, and the given RefPar should be const too... </dd></dl>

<p>Reimplemented from <a class="el" href="a00071.html#a24bfb12849c7733a7034928fbb0b14a8">ObjCryst::RefinableObj</a>.</p>

</div>
</div>
<a class="anchor" id="aa0e2192321dc993ba78fb84d7502e2eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="a00082.html">RigidGroup</a> *&gt;&amp; ObjCryst::Molecule::GetRigidGroupList </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>List of rigid group of atoms. </p>
<p>See <a class="el" href="a00047.html#a43939b3e3ad83065cf7ccb6065a53a12" title="Rigid groups of atoms.">Molecule::mvRigidGroup</a> </p>

</div>
</div>
<a class="anchor" id="afab17b6b5416c25a1a89b492017a590c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="a00082.html">RigidGroup</a> *&gt;&amp; ObjCryst::Molecule::GetRigidGroupList </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>List of rigid group of atoms. </p>
<p>See <a class="el" href="a00047.html#a43939b3e3ad83065cf7ccb6065a53a12" title="Rigid groups of atoms.">Molecule::mvRigidGroup</a> </p>

</div>
</div>
<a class="anchor" id="a3ac17bd45a709c82d9a4d304fde09b88"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="a00087.html">ScatteringComponentList</a>&amp; ObjCryst::Molecule::GetScatteringComponentList </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the list of all scattering components for this scatterer. </p>
<p>This is the most important function of this class, giving the list of scattering positions along with the associated <a class="el" href="a00090.html" title="Abstract Base Class to describe the scattering power of any Scatterer component in a crystal...">ScatteringPower</a>. </p>

<p>Implements <a class="el" href="a00085.html#aca0e08e3793cc69d31fce53e481c2a67">ObjCryst::Scatterer</a>.</p>

</div>
</div>
<a class="anchor" id="a00aa7620326d8663b1f4e1bd9237ffb8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ObjCryst::Molecule::GLInitDisplayList </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>noSymmetrics</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>xMin</em> = <code>-.1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>xMax</em> = <code>1.1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>yMin</em> = <code>-.1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>yMax</em> = <code>1.1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>zMin</em> = <code>-.1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>zMax</em> = <code>1.1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>displayEnantiomer</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>displayNames</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create an OpenGL Display List of the scatterer. This should only be called by a <a class="el" href="a00020.html" title="Crystal class: Unit cell, spacegroup, scatterers.">Crystal</a> object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">noSymmetrics,:</td><td>if false (the default), then all symmetrics are shown in the 3D display, within the limits defined by the min/max parameters \ param xMin,xMax,yMin,yMax,zMin,zMax: in fractionnal coordinates, the region in which we want scaterrer to be displayed. The test is made on the center of the scatterer (eg a <a class="el" href="a00156.html" title="ZScatterer: the basic type of complex scatterers, where atom positions are defined using a standard &quot;...">ZScatterer</a> (molecule) will not be 'cut' on the border). </td></tr>
    <tr><td class="paramname">displayNames,:</td><td>if true, only the names of the scatterers will be displayed, at the position of the scatterers (to actually see them, they will have to be translated with respect to the drawing of the scatterers). </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="a00085.html#a4eaf9cf9780bef83e40155810db120a0">ObjCryst::Scatterer</a>.</p>

</div>
</div>
<a class="anchor" id="a11e623f6482b468f6dd05fc0ab2bbb24"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ObjCryst::Molecule::GlobalOptRandomMove </td>
          <td>(</td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>mutationAmplitude</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00080.html">RefParType</a> *&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a random move of the current configuration. </p>
<p>This is for global optimization algorithms. the moves for each parameter are less than their global optimization step, multiplied by the mutation amplitude.</p>
<dl class="section warning"><dt>Warning</dt><dd>: this makes a random move for the parameter declared for this object, and it is the duty of the object to decide whether the included objects should be moved and how. (eg an algorithm should only call for a move with the top object, and this object decides how he and his sub-objects moves). By default (<a class="el" href="a00071.html" title="Generic Refinable Object.">RefinableObj</a> implementation) all included objects are moved recursively.</dd></dl>
<p><a class="el" href="a00071.html" title="Generic Refinable Object.">RefinableObj</a>:: </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutationAmplitude,:</td><td>multiplier for the maximum move amplitude, for all parameters </td></tr>
    <tr><td class="paramname">type,:</td><td>restrain the change exclusively to parameters of a given type (same type or descendant from this <a class="el" href="a00080.html" title="class of refinable parameter types.">RefParType</a>). </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="a00071.html#a18375c8525ae38c481ba77e9cf9d67c1">ObjCryst::RefinableObj</a>.</p>

</div>
</div>
<a class="anchor" id="ad96fe78688ce898dc9aeffcc23523967"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ObjCryst::Molecule::InitRefParList </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Prepare refinable parameters for the scatterer object </p>

<p>Implements <a class="el" href="a00085.html#a45ef328b68a0a68c0228beefc25cda7f">ObjCryst::Scatterer</a>.</p>

</div>
</div>
<a class="anchor" id="a9a43c803d62dc4f5f3b7852bbd75c939"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ObjCryst::Molecule::MolecularDynamicsEvolve </td>
          <td>(</td>
          <td class="paramtype">std::map&lt; <a class="el" href="a00043.html">MolAtom</a> *, <a class="el" href="a00152.html">XYZ</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>nbStep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="a00044.html">MolBond</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>vb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="a00045.html">MolBondAngle</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>va</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="a00046.html">MolDihedralAngle</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>vd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; <a class="el" href="a00082.html">RigidGroup</a> *, std::pair&lt; <a class="el" href="a00152.html">XYZ</a>, <a class="el" href="a00152.html">XYZ</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">REAL&#160;</td>
          <td class="paramname"><em>nrj0</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the conformation of the molecule using molecular dynamics principles. </p>
<p>Optionnally, move only a subgroup of atoms and only take into account some restraints.</p>
<p>The atoms actually moved are those included as keys in v0, and those part of the rigid bodies in vr.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v0,:</td><td>initial speed of all atoms. On return, includes the new speed coordinates. Only the atoms used as keys in v0 will be moved, so this should be used to work only on a subgroup of atoms. </td></tr>
    <tr><td class="paramname">nbStep,:</td><td>number of steps to perform. </td></tr>
    <tr><td class="paramname">dt,:</td><td>time step. Recommended value are such that v0[].xyz * dt = 0.001 </td></tr>
    <tr><td class="paramname">vb,va,vd,:</td><td>vector of bond, bond angle and dihedral angle restraints to be taken into account. If these are empty, the full list of restraints of the <a class="el" href="a00047.html" title="Molecule : class for complex scatterer descriptions using cartesian coordinates with bond length/angl...">Molecule</a> are taken into account, including rigid groups. If they are not empty, then it is assumed that no atom moved belongs to a rigid group. </td></tr>
    <tr><td class="paramname">vr,:</td><td>initial speed for the angular and translation parameters of rigid groups included in the evolution. For each entry of the map the first <a class="el" href="a00152.html" title="Structure holding 3 coordinates, or deriviatives with respect to each of these coordinates.">XYZ</a> coordinates are the speed for <a class="el" href="a00082.html#abda5125459a21cc5534c90d9516312e9" title="The translation of all the atoms as a group The values will be resetted whenever entering or leaving ...">RigidGroup::mX</a>,mY,mZ, and the second are the speed for the angular coordinates of the quaternion Q1,Q2,Q3 </td></tr>
    <tr><td class="paramname">nrj0,:</td><td>the total energy the system should try to maintain. If equal to 0, the initial energy will be used. The speed will be de/increased to compensate any energy change. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8e070563a06e9c375b3b26d2e5828c54"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ObjCryst::Molecule::OptimizeConformation </td>
          <td>(</td>
          <td class="paramtype">const long&#160;</td>
          <td class="paramname"><em>nbTrial</em> = <code>10000</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>stopCost</em> = <code>0.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Minimize configuration from internal restraints (bond lengths, angles and dihedral angles). </p>
<p>Useful when adding manually atoms to get an initial reasonable configuration. </p>

</div>
</div>
<a class="anchor" id="ac275665ed11daea220ef37154b39bf0d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ObjCryst::Molecule::OptimizeConformationSteepestDescent </td>
          <td>(</td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>maxStep</em> = <code>0.1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>nbStep</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Optimize the conformation from internal restraints (bond lengths, angles and dihedral angles), using a steepest descent algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxStep,:</td><td>maximum displacement allowed along any coordinate for all atoms. </td></tr>
    <tr><td class="paramname">nbStep,:</td><td>number of steps - the gradient is re-calculated after each step. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a98bd83a14b359c994be9ab1bf4b8453b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ostream&amp; ObjCryst::Molecule::POVRayDescription </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00021.html">CrystalPOVRayOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Output a description of the scatterer for POVRay. This should only be called by the <a class="el" href="a00020.html" title="Crystal class: Unit cell, spacegroup, scatterers.">Crystal</a> Object to which belongs this scatterer. </p>

<p>Implements <a class="el" href="a00085.html#a708cc857f82c9af4cbdf4d9334449d0f">ObjCryst::Scatterer</a>.</p>

</div>
</div>
<a class="anchor" id="aaa76da93619174b17db73de9d2374ac7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ObjCryst::Molecule::RandomizeConfiguration </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Randomize Configuration (before a global optimization). </p>
<p>This Affects only parameters which are limited and not fixed. The randomization also affects all sub-objects (recursive). </p>

<p>Reimplemented from <a class="el" href="a00071.html#a01b02e566db9aebfd0f9ed2647441f40">ObjCryst::RefinableObj</a>.</p>

</div>
</div>
<a class="anchor" id="a7d3d1e583bc7d4beb1a8a6c7f74b4811"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;<a class="el" href="a00043.html">MolAtom</a>*&gt;::iterator ObjCryst::Molecule::RemoveAtom </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00043.html">MolAtom</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>del</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove an atom. </p>
<p>Returns the iterator to the next atom in the list.</p>
<p>This also removes all corresponding bonds, bond angles, etc... If del is true (default), then the <a class="el" href="a00043.html" title="MolAtom : atom inside a Molecule.">MolAtom</a> object is deleted. The del flag gets sent to the RemoveXXX functions for the corresponding objects. </p>

</div>
</div>
<a class="anchor" id="ad7cc4b6b9eec26f396fc30c517f37e24"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;<a class="el" href="a00044.html">MolBond</a>*&gt;::iterator ObjCryst::Molecule::RemoveBond </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00044.html">MolBond</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>del</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a bond. </p>
<p>Returns the iterator to the next bond in the list.</p>
<p>If del is true (default), then the <a class="el" href="a00044.html" title="Bond between two atoms, also a restraint on the associated bond length.">MolBond</a> object is deleted. </p>

</div>
</div>
<a class="anchor" id="a113af00d52a1cc225803865a82f35512"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;<a class="el" href="a00045.html">MolBondAngle</a>*&gt;::iterator ObjCryst::Molecule::RemoveBondAngle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00045.html">MolBondAngle</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>del</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a BondAngle. </p>
<p>If del is true (default), then the <a class="el" href="a00045.html" title="Bond angle restraint between 3 atoms.">MolBondAngle</a> object is deleted. </p>

</div>
</div>
<a class="anchor" id="a3f95dc9df0a1547b07854773179d28be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;<a class="el" href="a00046.html">MolDihedralAngle</a>*&gt;::iterator ObjCryst::Molecule::RemoveDihedralAngle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00046.html">MolDihedralAngle</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>del</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a dihedral angle. </p>
<p>If del is true (default), then the <a class="el" href="a00046.html" title="Dihedral angle restraint between 4 atoms.">MolDihedralAngle</a> object is deleted. </p>

</div>
</div>
<a class="anchor" id="a0a2c86a36111f22e07356cac6364632a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="a00082.html">RigidGroup</a>*&gt;::iterator ObjCryst::Molecule::RemoveRigidGroup </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00082.html">RigidGroup</a> &amp;&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>updateDisplay</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>del</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a rigid group of atoms. </p>
<p>See <a class="el" href="a00047.html#a43939b3e3ad83065cf7ccb6065a53a12" title="Rigid groups of atoms.">Molecule::mvRigidGroup</a></p>
<p>If del is true (default), then the <a class="el" href="a00082.html" title="Rigid groups of atoms inside a molecule.">RigidGroup</a> object is deleted. </p>

</div>
</div>
<a class="anchor" id="a9daa98a9b4a992d56e0dba41b104b291"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ObjCryst::Molecule::ResetRigidGroupsPar </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the orientation &amp; translation parameters of all rigid groups to 0, after correcting the atomic positions. </p>
<p>This is <b>required</b> before saving the structure, as these parameters are not saved. </p>

</div>
</div>
<a class="anchor" id="a560c9ffc36d4874b99eb26c198ee485f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ObjCryst::Molecule::RigidifyWithDihedralAngles </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add dihedral angles so as to rigidify the <a class="el" href="a00047.html" title="Molecule : class for complex scatterer descriptions using cartesian coordinates with bond length/angl...">Molecule</a>. </p>
<p>In practice, for every sequence of atoms A-B-C-D, add the dihedral angle defined by these 4 atoms, unless either ABC or BCD are aligned (angle below 10�).</p>
<p>No duplicate dihedral angle is generated. </p>

</div>
</div>
<a class="anchor" id="a9bd595a0ad88d6832718f3bffb452866"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ObjCryst::Molecule::RotateAtomGroup </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00043.html">MolAtom</a> &amp;&#160;</td>
          <td class="paramname"><em>at1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00043.html">MolAtom</a> &amp;&#160;</td>
          <td class="paramname"><em>at2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const set&lt; <a class="el" href="a00043.html">MolAtom</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>atoms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>keepCenter</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rotate a group of atoms around an axis defined by two atoms. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keepCenter,:</td><td>if true, the coordinates of the molecule are modified so that only the rotated atoms are moved. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a84e93db5b81b90fd5befa22caaf8691c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ObjCryst::Molecule::RotateAtomGroup </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00043.html">MolAtom</a> &amp;&#160;</td>
          <td class="paramname"><em>at</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>vx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>vy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>vz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const set&lt; <a class="el" href="a00043.html">MolAtom</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>atoms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>keepCenter</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rotate a group of atoms around an axis defined by one atom and a vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keepCenter,:</td><td>if true, the coordinates of the molecule are modified so that only the rotated atoms are moved. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a24043736cd4323a31b7bc0fa6fa166da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ObjCryst::Molecule::SetCenterAtom </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00043.html">MolAtom</a> &amp;&#160;</td>
          <td class="paramname"><em>at</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the atom defining the origin of the <a class="el" href="a00047.html" title="Molecule : class for complex scatterer descriptions using cartesian coordinates with bond length/angl...">Molecule</a> Equal to 0 if no atom as been set. </p>

</div>
</div>
<a class="anchor" id="a19afb1f15773fed7a2d9dff35820bafd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ObjCryst::Molecule::SetDeleteSubObjInDestructor </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set whether to delete the MolAtoms, MolBonds, MolBondAngles and MolDihedralAngles in the destructor. </p>
<p>By default these sub-objects are deleted. </p>

</div>
</div>
<a class="anchor" id="a91e2f80f1e4526fbb6cd99f5b229db9e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ObjCryst::Molecule::TagNewBestConfig </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>During a global optimization, tells the object that the current config is the latest "best" config. </p>
<p>This can be used by the object to make more intellingent random moves (use with caution: highly experimental !). </p>

<p>Reimplemented from <a class="el" href="a00071.html#a3cb4cc924d39576618184eccd4321cf6">ObjCryst::RefinableObj</a>.</p>

</div>
</div>
<a class="anchor" id="a0d3122b53dd81aa23d2aaa2427e6291e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ObjCryst::Molecule::TranslateAtomGroup </td>
          <td>(</td>
          <td class="paramtype">const set&lt; <a class="el" href="a00043.html">MolAtom</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>atoms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>dy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>dz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>keepCenter</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Translate a group of atoms in a given direction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keepCenter,:</td><td>if true, the coordinates of the molecule are modified so that only the translated atoms are moved. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9cc198b9cb896d28c7bd90a775db4ec2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ObjCryst::Molecule::TuneGlobalOptimRotationAmplitude </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tune the rotation amplitude for free torsions and for the overall <a class="el" href="a00047.html" title="Molecule : class for complex scatterer descriptions using cartesian coordinates with bond length/angl...">Molecule</a> Rotation. </p>
<p>This should be done after <a class="el" href="a00047.html#a3642fa8104faa1ce84a977600f9d1aeb" title="Build the groups of atoms that will be rotated during global optimization.">Molecule::BuildRotorGroup()</a>; </p>

</div>
</div>
<a class="anchor" id="af1ae2c4f9febbe16019987f807271b58"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ObjCryst::Molecule::UpdateDisplay </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If there is an interface, this should be automatically be called each time there is a 'new, significant' configuration to report. </p>

<p>Reimplemented from <a class="el" href="a00071.html#ab74e2cead734fe1e652c5add46c5e116">ObjCryst::RefinableObj</a>.</p>

</div>
</div>
<a class="anchor" id="a701f78d93d495d1102d0bd26700c4a3d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ObjCryst::Molecule::XMLInput </td>
          <td>(</td>
          <td class="paramtype">istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00151.html">XMLCrystTag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Input From stream. </p>
<dl class="todo"><dt><b><a class="el" href="a00222.html#_todo000027">Todo:</a></b></dt><dd>Add an bool XMLInputTag(is,tag) function to recognize all the tags from the stream. So that each inherited class can use the XMLInputTag function from its parent (ie take advantage of inheritance). The children class would first try to interpret the tag, then if unsuccessful would pass it to its parent (thus allowing overloading), etc... </dd></dl>

<p>Reimplemented from <a class="el" href="a00071.html#ac13a4045c3f187879443c8615c38d623">ObjCryst::RefinableObj</a>.</p>

</div>
</div>
<a class="anchor" id="a47762abe37f3e8f7378b7210916e71ea"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ObjCryst::Molecule::XMLOutput </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>indent</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Output to stream in well-formed XML. </p>
<dl class="todo"><dt><b><a class="el" href="a00222.html#_todo000026">Todo:</a></b></dt><dd>Use inheritance.. as for XMLInputTag()... </dd></dl>

<p>Reimplemented from <a class="el" href="a00071.html#a7b9b6ed0f8dcf753d398c35e073de973">ObjCryst::RefinableObj</a>.</p>

</div>
</div>
<h2>Member Data Documentation</h2>
<a class="anchor" id="ae8459b9f767b0d8bc27b05140c604e0c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00078.html">RefObjOpt</a> ObjCryst::Molecule::mAutoOptimizeConformation</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Option to automatically optimize the starting conformation, if the total restraint cost is too high. </p>
<p>This is done in <a class="el" href="a00047.html#a5fbdadb37966f382a6e33150285819dc" title="This should be called by any optimization class at the begining of an optimization.">BeginOptimization()</a>.</p>
<p>This is enabled by default, and should be disabled by people who already supply a good starting conformation for their molecule. </p>

</div>
</div>
<a class="anchor" id="a13cffa530711a868859cfcfc17bce069"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">map&lt;<a class="el" href="a00043.html">MolAtom</a> *,set&lt;<a class="el" href="a00043.html">MolAtom</a> *&gt; &gt; ObjCryst::Molecule::mConnectivityTable</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Connectivity table: for each atom, keep the list of atoms bonded to it. </p>
<p>All atoms are referenced from their index. </p>

</div>
</div>
<a class="anchor" id="a5b35796cbf31728b39b82c36badaa97b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ObjCryst::Molecule::mDeleteSubObjInDestructor</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Base Rotation amplitude (in radians) for the <a class="el" href="a00047.html" title="Molecule : class for complex scatterer descriptions using cartesian coordinates with bond length/angl...">Molecule</a>, so that the average atomic displacement is equal to 0.1 A. </p>
<p>Default=0.02*pi </p>

</div>
</div>
<a class="anchor" id="a35881bfb20092d0dcc424553f5671245"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00078.html">RefObjOpt</a> ObjCryst::Molecule::mFlexModel</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>OPtion for the different types of flexibility possible for this molecule: rigid body, free atoms + restraints, torsion angles... </p>
<dl class="section warning"><dt>Warning</dt><dd>still EXPERIMENTAL ! </dd></dl>

</div>
</div>
<a class="anchor" id="a7e69eecc5aa10a9908c3a6450cc2540b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">REAL ObjCryst::Molecule::mLogLikelihoodScale</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scale (multiplier) for the log(likelihood) </p>
<p>Changing this scale is equivalent to changing the sigma values of all bonds, bond angles and dihedral angles - but it allows a simple global scaling for the user. </p>

</div>
</div>
<a class="anchor" id="a8c82ea548f4c0f29e868776c88c5eab8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00078.html">RefObjOpt</a> ObjCryst::Molecule::mOptimizeOrientation</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Option to optimize the <a class="el" href="a00047.html" title="Molecule : class for complex scatterer descriptions using cartesian coordinates with bond length/angl...">Molecule</a>'s orientation. </p>
<p>Useful to completely fix the <a class="el" href="a00047.html" title="Molecule : class for complex scatterer descriptions using cartesian coordinates with bond length/angl...">Molecule</a>. </p>

</div>
</div>
<a class="anchor" id="a61b83701b288c4fdbcda97b14608af7d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00068.html">Quaternion</a> ObjCryst::Molecule::mQuat</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The unit quaternion defining the orientation. </p>

</div>
</div>
<a class="anchor" id="ae681f50b04c32c7139727c675dc04b67"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00087.html">ScatteringComponentList</a> ObjCryst::Molecule::mScattCompList</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The list of scattering components. </p>
<p>this is mutable since it only reflects the list of atoms. </p>

</div>
</div>
<a class="anchor" id="ad67f767fe62aeef49aef1c5760d69294"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">map&lt;<a class="el" href="a00043.html">MolAtom</a>* , std::vector&lt;<a class="el" href="a00044.html">MolBond</a>*&gt; &gt; ObjCryst::Molecule::mvAtomBond</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>List of Bonds for each atom. </p>
<p>This duplicates the information in Molecule::mvBond </p>

</div>
</div>
<a class="anchor" id="ad498c51ecf4ee0b4482e5fe41cd52be7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;<a class="el" href="a00043.html">MolAtom</a>*&gt; ObjCryst::Molecule::mvpAtom</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The list of atoms. </p>

</div>
</div>
<a class="anchor" id="aabf6e0daf6f90f4052a44888f2bc3d7b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;<a class="el" href="a00044.html">MolBond</a>*&gt; ObjCryst::Molecule::mvpBond</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The list of bonds. </p>

</div>
</div>
<a class="anchor" id="a9c195054308e17604a24a3127e0cb307"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;<a class="el" href="a00045.html">MolBondAngle</a>*&gt; ObjCryst::Molecule::mvpBondAngle</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The list of bond angles. </p>

</div>
</div>
<a class="anchor" id="a21384a0b8be7bf3fc539c57d90d5c9a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;<a class="el" href="a00046.html">MolDihedralAngle</a>*&gt; ObjCryst::Molecule::mvpDihedralAngle</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The list of dihedral angles. </p>

</div>
</div>
<a class="anchor" id="a43939b3e3ad83065cf7ccb6065a53a12"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="a00082.html">RigidGroup</a>*&gt; ObjCryst::Molecule::mvRigidGroup</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rigid groups of atoms. </p>
<p>This group will be kept <em>strictly</em> rigid, preventing the use of any stretch mode altering their relative position. The entire group of atoms can however be rotated or translated. </p>

</div>
</div>
<a class="anchor" id="a35cb61305129b6bbda4a0bb014b2c90e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">list&lt;<a class="el" href="a00048.html">MolRing</a>&gt; ObjCryst::Molecule::mvRing</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The list of rings. </p>
<dl class="section note"><dt>Note</dt><dd>this only reflects the bond list, so it is mutable. </dd></dl>

</div>
</div>
<a class="anchor" id="ac54d8a074549f7710a1823b0ecefcde8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">list&lt;<a class="el" href="a00083.html">RotorGroup</a>&gt; ObjCryst::Molecule::mvRotorGroupInternal</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>List of RotorGroups for internal rotations. </p>
<p>This lists groups of atoms that can be rotated <em>between</em> two given atoms. This is useful to alter the conformation of large rings, where no free torsion bonds exists, and also for long flexible chains. </p>

</div>
</div>
<a class="anchor" id="afc51d36109a8d96a626f3c2251345c13"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">list&lt;<a class="el" href="a00083.html">RotorGroup</a>&gt; ObjCryst::Molecule::mvRotorGroupTorsion</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>List of RotorGroups corresponding to free torsion bonds. </p>
<p>In this list are list of atoms on one side of a bond, that can be rotated freely around this bond. Each bond is listed only once, with the side which has the smallest number of atoms. </p>

</div>
</div>
<a class="anchor" id="a22a07ddc2dbfeb90238b29bcca1e915d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">list&lt;<a class="el" href="a00083.html">RotorGroup</a>&gt; ObjCryst::Molecule::mvRotorGroupTorsionSingleChain</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>List of RotorGroups corresponding to free torsion bonds, but with only one chain of atoms listed. </p>
<p>The difference with Molecule::mRotorGroupTorsion is that if the bond is A-B, with atom A linked with atoms A1,A2,A3, in this list only one chain (starting either from A1, A2 or A3) will be rotated, instead of the 3 chains. This is useful when searching for the absolute configuration of atoms. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>Molecule.h</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue May 7 2013 20:03:32 for ObjCryst++ by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.2
</small></address>
</body>
</html>
