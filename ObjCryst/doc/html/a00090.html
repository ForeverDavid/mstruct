<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>ObjCryst++: ObjCryst::ScatteringPower Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">ObjCryst++
   &#160;<span id="projectnumber">1.5CVS</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="a00171.html">ObjCryst</a>      </li>
      <li class="navelem"><a class="el" href="a00090.html">ScatteringPower</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<div class="title">ObjCryst::ScatteringPower Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="ObjCryst::ScatteringPower" --><!-- doxytag: inherits="ObjCryst::RefinableObj" -->
<p>Abstract Base Class to describe the scattering power of any <a class="el" href="a00085.html" title="Generic type of scatterer: can be an atom, or a more complex assembly of atoms.">Scatterer</a> component in a crystal.  
 <a href="a00090.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for ObjCryst::ScatteringPower:</div>
<div class="dyncontent">
 <div class="center">
  <img src="a00090.png" usemap="#ObjCryst::ScatteringPower_map" alt=""/>
  <map id="ObjCryst::ScatteringPower_map" name="ObjCryst::ScatteringPower_map">
<area href="a00071.html" title="Generic Refinable Object." alt="ObjCryst::RefinableObj" shape="rect" coords="212,0,414,24"/>
<area href="a00034.html" title="Global Scattering Power." alt="ObjCryst::GlobalScatteringPower" shape="rect" coords="0,112,202,136"/>
<area href="a00091.html" title="The Scattering Power for an Atom." alt="ObjCryst::ScatteringPowerAtom" shape="rect" coords="212,112,414,136"/>
<area href="a00092.html" title="\ brief ScatteringPower for a spherical particule" alt="ObjCryst::ScatteringPowerSphere" shape="rect" coords="424,112,626,136"/>
</map>
 </div></div>

<p><a href="a00297.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a40d392b01f277a90affc2825ffa2e28d"></a><!-- doxytag: member="ObjCryst::ScatteringPower::ScatteringPower" ref="a40d392b01f277a90affc2825ffa2e28d" args="(const ScatteringPower &amp;old)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>ScatteringPower</b> (const <a class="el" href="a00090.html">ScatteringPower</a> &amp;old)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00090.html#ac31cc4135011046f93d49f4173aee3ee">GetClassName</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Name for this class ("RefinableObj", "Crystal",...).  <a href="#ac31cc4135011046f93d49f4173aee3ee"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1db56ac3b61b4f5d1f70dbf65fff114a"></a><!-- doxytag: member="ObjCryst::ScatteringPower::operator=" ref="a1db56ac3b61b4f5d1f70dbf65fff114a" args="(const ScatteringPower &amp;rhs)" -->
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="a00090.html">ScatteringPower</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual CrystVector_REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00090.html#af18f3eaaf45af87bc3a2a0ff21bc34b6">GetScatteringFactor</a> (const <a class="el" href="a00089.html">ScatteringData</a> &amp;data, const int spgSymPosIndex=-1) const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Scattering factor for all reflections of a given <a class="el" href="a00089.html" title="Class to compute structure factors for a set of reflections and a Crystal.">ScatteringData</a> object.  <a href="#af18f3eaaf45af87bc3a2a0ff21bc34b6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00090.html#a854b51b9b08e96af0fe7986fe372c50c">GetForwardScatteringFactor</a> (const <a class="el" href="a00171.html#a48fe50a094c607f8897378934d3d73ef">RadiationType</a>) const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the scattering factor at (0,0,0).  <a href="#a854b51b9b08e96af0fe7986fe372c50c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual CrystVector_REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00090.html#a3df723db77380c82ecff5f7050490255">GetTemperatureFactor</a> (const <a class="el" href="a00089.html">ScatteringData</a> &amp;data, const int spgSymPosIndex=-1) const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the temperature factor for all reflections of a given <a class="el" href="a00089.html" title="Class to compute structure factors for a set of reflections and a Crystal.">ScatteringData</a> object.  <a href="#a3df723db77380c82ecff5f7050490255"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual CrystMatrix_REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00090.html#a42c1302254787d13b9e0f2210315291a">GetResonantScattFactReal</a> (const <a class="el" href="a00089.html">ScatteringData</a> &amp;data, const int spgSymPosIndex=-1) const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the real part of the resonant scattering factor.  <a href="#a42c1302254787d13b9e0f2210315291a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual CrystMatrix_REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00090.html#a9bc5d86bf76116f645b43d46f2a9771c">GetResonantScattFactImag</a> (const <a class="el" href="a00089.html">ScatteringData</a> &amp;data, const int spgSymPosIndex=-1) const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the imaginary part of the resonant scattering factor.  <a href="#a9bc5d86bf76116f645b43d46f2a9771c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0d099ca049eebbf23a31fb32b4229d4a"></a><!-- doxytag: member="ObjCryst::ScatteringPower::IsScatteringFactorAnisotropic" ref="a0d099ca049eebbf23a31fb32b4229d4a" args="() const " -->
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00090.html#a0d099ca049eebbf23a31fb32b4229d4a">IsScatteringFactorAnisotropic</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the scattering factor anisotropic ? <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a602947d2e968b88f208d3507bd8a093d"></a><!-- doxytag: member="ObjCryst::ScatteringPower::IsTemperatureFactorAnisotropic" ref="a602947d2e968b88f208d3507bd8a093d" args="() const " -->
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00090.html#a602947d2e968b88f208d3507bd8a093d">IsTemperatureFactorAnisotropic</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the thermic factor anisotropic ? <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac8f88b96383b0b97812913427d0c65f1"></a><!-- doxytag: member="ObjCryst::ScatteringPower::IsResonantScatteringAnisotropic" ref="ac8f88b96383b0b97812913427d0c65f1" args="() const " -->
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00090.html#ac8f88b96383b0b97812913427d0c65f1">IsResonantScatteringAnisotropic</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Are the resonant scattering terms anisotropic ? <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00090.html#a5cdd13d241974a6e6f0d3803256a3d10">GetSymbol</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbol for this Scattering power (the atom name for atoms)  <a href="#a5cdd13d241974a6e6f0d3803256a3d10"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00090.html#ac3e116b2d956c229b11c98c837e042d8">GetBiso</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the isotropic temperature B factor.  <a href="#ac3e116b2d956c229b11c98c837e042d8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">REAL &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00090.html#ace567e5b32673e14521ae262388dfed6">GetBiso</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the isotropic temperature B factor.  <a href="#ace567e5b32673e14521ae262388dfed6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00090.html#a179266106b89bcbb4885f9f20ce315c3">SetBiso</a> (const REAL newB)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the isotropic temperature B factor.  <a href="#a179266106b89bcbb4885f9f20ce315c3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aab538c7888aa57c38236bd01c9252965"></a><!-- doxytag: member="ObjCryst::ScatteringPower::GetBij" ref="aab538c7888aa57c38236bd01c9252965" args="(const size_t &amp;i, const size_t &amp;j) const " -->
REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00090.html#aab538c7888aa57c38236bd01c9252965">GetBij</a> (const size_t &amp;i, const size_t &amp;j) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the anisotropic temperature B factor for (i, j) pair. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00090.html#abc78b680e9cd6a38b875731363978477">GetBij</a> (const size_t &amp;idx) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the anisotropic temperature B factor for given index.  <a href="#abc78b680e9cd6a38b875731363978477"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8c947f00897876d91f68617772a20dad"></a><!-- doxytag: member="ObjCryst::ScatteringPower::SetBij" ref="a8c947f00897876d91f68617772a20dad" args="(const size_t &amp;i, const size_t &amp;j, const REAL newB)" -->
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00090.html#a8c947f00897876d91f68617772a20dad">SetBij</a> (const size_t &amp;i, const size_t &amp;j, const REAL newB)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the anisotropic temperature B factor for (i, j) pair. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00090.html#a50b648d97ebb1ab97b39195b098eff50">SetBij</a> (const size_t &amp;idx, const REAL newB)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the anisotropic temperature B factor for given index.  <a href="#a50b648d97ebb1ab97b39195b098eff50"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a05909fe082739c6be397299813418618"></a><!-- doxytag: member="ObjCryst::ScatteringPower::IsIsotropic" ref="a05909fe082739c6be397299813418618" args="() const " -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00090.html#a05909fe082739c6be397299813418618">IsIsotropic</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the scattering power is isotropic, else false. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00090.html#ae3d48856abf5c8ef9dea6204309897bc">GetDynPopCorrIndex</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number identifying this kind of scatterer, used to decide whether two scatterers are equivalent, for the dynamical occupancy correction.  <a href="#ae3d48856abf5c8ef9dea6204309897bc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af7cf02d1229e45220953b345a6f6d427"></a><!-- doxytag: member="ObjCryst::ScatteringPower::GetNbScatteringPower" ref="af7cf02d1229e45220953b345a6f6d427" args="() const " -->
long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00090.html#af7cf02d1229e45220953b345a6f6d427">GetNbScatteringPower</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Total number of <a class="el" href="a00090.html" title="Abstract Base Class to describe the scattering power of any Scatterer component in a crystal...">ScatteringPower</a> object. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aac5f03782e5b08b3e60254b1fe0aad4a"></a><!-- doxytag: member="ObjCryst::ScatteringPower::GetLastChangeClock" ref="aac5f03782e5b08b3e60254b1fe0aad4a" args="() const " -->
const <a class="el" href="a00072.html">RefinableObjClock</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00090.html#aac5f03782e5b08b3e60254b1fe0aad4a">GetLastChangeClock</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">ObjCrystClock time when the last modification was made to the object. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acbe6442c66fcb7760b2684ec4d9456cd"></a><!-- doxytag: member="ObjCryst::ScatteringPower::GetColourName" ref="acbe6442c66fcb7760b2684ec4d9456cd" args="() const " -->
const string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00090.html#acbe6442c66fcb7760b2684ec4d9456cd">GetColourName</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the (POV-Ray) name associated to the color (if any) <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5a992fe0ab82ddc79f184bbb12d6aaa0"></a><!-- doxytag: member="ObjCryst::ScatteringPower::GetColourRGB" ref="a5a992fe0ab82ddc79f184bbb12d6aaa0" args="() const " -->
const float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00090.html#a5a992fe0ab82ddc79f184bbb12d6aaa0">GetColourRGB</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the float[3] array of RGB components defining the colour of this scattering power. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac48cb91ee4361a14d829227023479514"></a><!-- doxytag: member="ObjCryst::ScatteringPower::SetColour" ref="ac48cb91ee4361a14d829227023479514" args="(const string &amp;colorName)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00090.html#ac48cb91ee4361a14d829227023479514">SetColour</a> (const string &amp;colorName)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the colour from the associated POV-Ray name. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a312da0ad4d8229baf7d6ab7ff9c45a3c"></a><!-- doxytag: member="ObjCryst::ScatteringPower::SetColour" ref="a312da0ad4d8229baf7d6ab7ff9c45a3c" args="(const float r, const float g, const float b)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00090.html#a312da0ad4d8229baf7d6ab7ff9c45a3c">SetColour</a> (const float r, const float g, const float b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the colour from RGB components (all between 0 and 1.) <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00090.html#ac44860aca21734844379ddec87622f7b">GetRadius</a> () const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the physical radius of this type of scatterer (for 3D display purposes).  <a href="#ac44860aca21734844379ddec87622f7b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00090.html#aae98160e01ecb2098cf4777126860aa5">GetGeneGroup</a> (const <a class="el" href="a00071.html">RefinableObj</a> &amp;obj, CrystVector_uint &amp;groupIndex, unsigned int &amp;firstGroup) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the gene group assigned to each parameter.  <a href="#aae98160e01ecb2098cf4777126860aa5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00090.html#a34a36179228e07e92a85da9d17376649">GetMaximumLikelihoodPositionError</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum Likelihood: get the estimated error (sigma) on the positions for this kind of element.  <a href="#a34a36179228e07e92a85da9d17376649"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00090.html#aeba30efe61155572ffdada1121578bc9">SetMaximumLikelihoodPositionError</a> (const REAL mle)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum Likelihood: set the estimated error (sigma) on the positions for this kind of element.  <a href="#aeba30efe61155572ffdada1121578bc9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a23031fcb8c8c79d0e086da6aaadcd40c"></a><!-- doxytag: member="ObjCryst::ScatteringPower::GetMaximumLikelihoodNbGhostAtom" ref="a23031fcb8c8c79d0e086da6aaadcd40c" args="() const " -->
REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00090.html#a23031fcb8c8c79d0e086da6aaadcd40c">GetMaximumLikelihoodNbGhostAtom</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum Likelihood: get the number of ghost elements per asymmetric unit. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa3343885c4b3b9d41c386f7d8aaacd63"></a><!-- doxytag: member="ObjCryst::ScatteringPower::SetMaximumLikelihoodNbGhostAtom" ref="aa3343885c4b3b9d41c386f7d8aaacd63" args="(const REAL nb)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00090.html#aa3343885c4b3b9d41c386f7d8aaacd63">SetMaximumLikelihoodNbGhostAtom</a> (const REAL nb)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum Likelihood: set the number of ghost elements per asymmetric unit. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00072.html">RefinableObjClock</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00090.html#a63af7f309f1d9e03245f84ba21b1dc4e">GetMaximumLikelihoodParClock</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the clock value for the last change on the maximum likelihood parameters (positionnal error, number of ghost atoms).  <a href="#a63af7f309f1d9e03245f84ba21b1dc4e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a04f10b6898e5242548a6980b99a55bb9"></a><!-- doxytag: member="ObjCryst::ScatteringPower::GetFormalCharge" ref="a04f10b6898e5242548a6980b99a55bb9" args="() const " -->
virtual REAL&#160;</td><td class="memItemRight" valign="bottom"><b>GetFormalCharge</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a98c9fe3af63a4093a354bb814730aa76"></a><!-- doxytag: member="ObjCryst::ScatteringPower::SetFormalCharge" ref="a98c9fe3af63a4093a354bb814730aa76" args="(const REAL charge)" -->
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>SetFormalCharge</b> (const REAL charge)</td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a963cfe56b67286007bb93c7962e72b5c"></a><!-- doxytag: member="ObjCryst::ScatteringPower::InitRefParList" ref="a963cfe56b67286007bb93c7962e72b5c" args="()=0" -->
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>InitRefParList</b> ()=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac39b1294c085edac4c7180b4373a73c0"></a><!-- doxytag: member="ObjCryst::ScatteringPower::Init" ref="ac39b1294c085edac4c7180b4373a73c0" args="()" -->
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00090.html#ac39b1294c085edac4c7180b4373a73c0">Init</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialization of the object, used by all constructors, and operator=. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a24c0c49adab2efe6af63c4915d861577"></a><!-- doxytag: member="ObjCryst::ScatteringPower::InitRGBColour" ref="a24c0c49adab2efe6af63c4915d861577" args="()" -->
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00090.html#a24c0c49adab2efe6af63c4915d861577">InitRGBColour</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get RGB Colour coordinates from Colour Name. <br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00090.html#a0266da1d92ec3d14989a2d4047710c4b">mDynPopCorrIndex</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">number identifying this kind of scatterer, for the dynamical occupancy correction.  <a href="#a0266da1d92ec3d14989a2d4047710c4b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aad32a210a13475061a2cda7525e05501"></a><!-- doxytag: member="ObjCryst::ScatteringPower::mBiso" ref="aad32a210a13475061a2cda7525e05501" args="" -->
REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00090.html#aad32a210a13475061a2cda7525e05501">mBiso</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Temperature isotropic B factor. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a312928a0ead2f2bff84156e772752fe1"></a><!-- doxytag: member="ObjCryst::ScatteringPower::mIsIsotropic" ref="a312928a0ead2f2bff84156e772752fe1" args="" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00090.html#a312928a0ead2f2bff84156e772752fe1">mIsIsotropic</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the scattering isotropic ? <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a02a4524640e2d23805df26b114be680f"></a><!-- doxytag: member="ObjCryst::ScatteringPower::mBeta" ref="a02a4524640e2d23805df26b114be680f" args="" -->
CrystVector_REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00090.html#a02a4524640e2d23805df26b114be680f">mBeta</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Anisotropic Beta(ij) <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7b2e1854b0799312da38819cebf13672"></a><!-- doxytag: member="ObjCryst::ScatteringPower::mClock" ref="a7b2e1854b0799312da38819cebf13672" args="" -->
<a class="el" href="a00072.html">RefinableObjClock</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00090.html#a7b2e1854b0799312da38819cebf13672">mClock</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Clock. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0726f45b1f31f338326a28345b57738e"></a><!-- doxytag: member="ObjCryst::ScatteringPower::mColourName" ref="a0726f45b1f31f338326a28345b57738e" args="" -->
string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00090.html#a0726f45b1f31f338326a28345b57738e">mColourName</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Colour for this <a class="el" href="a00090.html" title="Abstract Base Class to describe the scattering power of any Scatterer component in a crystal...">ScatteringPower</a> (from POVRay) <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a00cf7e1fbe362a96be4a22c8b454fd29"></a><!-- doxytag: member="ObjCryst::ScatteringPower::mColourRGB" ref="a00cf7e1fbe362a96be4a22c8b454fd29" args="[3]" -->
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00090.html#a00cf7e1fbe362a96be4a22c8b454fd29">mColourRGB</a> [3]</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Colour for this <a class="el" href="a00090.html" title="Abstract Base Class to describe the scattering power of any Scatterer component in a crystal...">ScatteringPower</a> using RGB. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a20aa001aad26734367838792eff09682"></a><!-- doxytag: member="ObjCryst::ScatteringPower::mMaximumLikelihoodPositionError" ref="a20aa001aad26734367838792eff09682" args="" -->
REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00090.html#a20aa001aad26734367838792eff09682">mMaximumLikelihoodPositionError</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">estimated error (sigma) on the positions for this type of element. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a727c82cdb03968dba28c5f7549860093"></a><!-- doxytag: member="ObjCryst::ScatteringPower::mMaximumLikelihoodParClock" ref="a727c82cdb03968dba28c5f7549860093" args="" -->
<a class="el" href="a00072.html">RefinableObjClock</a>&#160;</td><td class="memItemRight" valign="bottom"><b>mMaximumLikelihoodParClock</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00090.html#a53eeb0a26003df0bcf604817e2fbadf7">mMaximumLikelihoodNbGhost</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of ghost atoms in the asymmetric unit.  <a href="#a53eeb0a26003df0bcf604817e2fbadf7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00090.html#a030be52e5ba5540bf068e6be4ccb190e">mFormalCharge</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Formal Charge.  <a href="#a030be52e5ba5540bf068e6be4ccb190e"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Abstract Base Class to describe the scattering power of any <a class="el" href="a00085.html" title="Generic type of scatterer: can be an atom, or a more complex assembly of atoms.">Scatterer</a> component in a crystal. </p>
<p>This includes:</p>
<ul>
<li>the scattering factor,</li>
<li>the temperature factor</li>
<li>real and imaginary parts of the resonant scattering factor.</li>
</ul>
<p>The interface is independent of the radiation type.</p>
<p>This base class is designed to handle both isotropic and anisotropic versions of scattering, temperature and anomalous factors.</p>
<dl class="todo"><dt><b><a class="el" href="a00222.html#_todo000013">Todo:</a></b></dt><dd><p class="startdd">Anisotropic scattering (temperature factor especially) code, using derived classes </p>
<p class="enddd">Clarify organization by removing any 'real' data from the top, abstract base class (eg remove Biso and Betaij), and by creating derived classes. Optionnaly 3 classes (used as members of <a class="el" href="a00090.html" title="Abstract Base Class to describe the scattering power of any Scatterer component in a crystal...">ScatteringPower</a>) could be created, TemperatureFactor, ScatteringFactor, and ResonantScatteringFactor. In any way the design of this class should not evolve, so that code using the <a class="el" href="a00090.html" title="Abstract Base Class to describe the scattering power of any Scatterer component in a crystal...">ScatteringPower</a> interface will remain compatible whatever modifications are made. </p>
</dd></dl>
</div><hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="abc78b680e9cd6a38b875731363978477"></a><!-- doxytag: member="ObjCryst::ScatteringPower::GetBij" ref="abc78b680e9cd6a38b875731363978477" args="(const size_t &amp;idx) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">REAL <a class="el" href="a00090.html#aab538c7888aa57c38236bd01c9252965">ObjCryst::ScatteringPower::GetBij</a> </td>
          <td>(</td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the anisotropic temperature B factor for given index. </p>
<p>0 -&gt; (1, 1) 1 -&gt; (2, 2) 2 -&gt; (3, 3) 3 -&gt; (1, 2) 4 -&gt; (1, 3) 5 -&gt; (2, 3) </p>

</div>
</div>
<a class="anchor" id="ac3e116b2d956c229b11c98c837e042d8"></a><!-- doxytag: member="ObjCryst::ScatteringPower::GetBiso" ref="ac3e116b2d956c229b11c98c837e042d8" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">REAL <a class="el" href="a00090.html#ac3e116b2d956c229b11c98c837e042d8">ObjCryst::ScatteringPower::GetBiso</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the isotropic temperature B factor. </p>

</div>
</div>
<a class="anchor" id="ace567e5b32673e14521ae262388dfed6"></a><!-- doxytag: member="ObjCryst::ScatteringPower::GetBiso" ref="ace567e5b32673e14521ae262388dfed6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">REAL&amp; <a class="el" href="a00090.html#ac3e116b2d956c229b11c98c837e042d8">ObjCryst::ScatteringPower::GetBiso</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the isotropic temperature B factor. </p>

</div>
</div>
<a class="anchor" id="ac31cc4135011046f93d49f4173aee3ee"></a><!-- doxytag: member="ObjCryst::ScatteringPower::GetClassName" ref="ac31cc4135011046f93d49f4173aee3ee" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const string&amp; <a class="el" href="a00090.html#ac31cc4135011046f93d49f4173aee3ee">ObjCryst::ScatteringPower::GetClassName</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Name for this class ("RefinableObj", "Crystal",...). </p>
<p>This is only useful to distinguish different classes when picking up objects from the <a class="el" href="a00071.html" title="Generic Refinable Object.">RefinableObj</a> Global Registry </p>

<p>Reimplemented from <a class="el" href="a00071.html#a62968d90a7a3080738b363934616c019">ObjCryst::RefinableObj</a>.</p>

<p>Reimplemented in <a class="el" href="a00091.html#a87fcc8fe4871d1b9b6ec08af5f353657">ObjCryst::ScatteringPowerAtom</a>, and <a class="el" href="a00092.html#a57e85d29926fe93da66041a43583e893">ObjCryst::ScatteringPowerSphere</a>.</p>

</div>
</div>
<a class="anchor" id="ae3d48856abf5c8ef9dea6204309897bc"></a><!-- doxytag: member="ObjCryst::ScatteringPower::GetDynPopCorrIndex" ref="ae3d48856abf5c8ef9dea6204309897bc" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long <a class="el" href="a00090.html#ae3d48856abf5c8ef9dea6204309897bc">ObjCryst::ScatteringPower::GetDynPopCorrIndex</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the number identifying this kind of scatterer, used to decide whether two scatterers are equivalent, for the dynamical occupancy correction. </p>

</div>
</div>
<a class="anchor" id="a854b51b9b08e96af0fe7986fe372c50c"></a><!-- doxytag: member="ObjCryst::ScatteringPower::GetForwardScatteringFactor" ref="a854b51b9b08e96af0fe7986fe372c50c" args="(const RadiationType) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual REAL <a class="el" href="a00090.html#a854b51b9b08e96af0fe7986fe372c50c">ObjCryst::ScatteringPower::GetForwardScatteringFactor</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00171.html#a48fe50a094c607f8897378934d3d73ef">RadiationType</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the scattering factor at (0,0,0). </p>
<p>Used for scatterer (electron, nucleus) density generation. </p>

<p>Implemented in <a class="el" href="a00091.html#ab979c1f31fd03b0f10f0afd625be722e">ObjCryst::ScatteringPowerAtom</a>, <a class="el" href="a00092.html#a9bd142cc8112495d41393b4faffc4fcd">ObjCryst::ScatteringPowerSphere</a>, and <a class="el" href="a00034.html#a33c01c7512929a947e6489df41edf7b3">ObjCryst::GlobalScatteringPower</a>.</p>

</div>
</div>
<a class="anchor" id="aae98160e01ecb2098cf4777126860aa5"></a><!-- doxytag: member="ObjCryst::ScatteringPower::GetGeneGroup" ref="aae98160e01ecb2098cf4777126860aa5" args="(const RefinableObj &amp;obj, CrystVector_uint &amp;groupIndex, unsigned int &amp;firstGroup) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="a00090.html#aae98160e01ecb2098cf4777126860aa5">ObjCryst::ScatteringPower::GetGeneGroup</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00071.html">RefinableObj</a> &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CrystVector_uint &amp;&#160;</td>
          <td class="paramname"><em>groupIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>firstGroup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the gene group assigned to each parameter. </p>
<p>Each parameter (a <em>gene</em> in terms of genetic algorithms) can be assigned to a gene group. Thus when mating two configurations, genes will be exchanged by groups. By default (in the base RefinabeObj class), each parameter is alone in its group. Derived classes can group genes for a better s** life.</p>
<p>The number identifying a gene group only has a meaning in a given object. It can also change on subsequent calls, and thus is not unique.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>the , supplied by an algorithm class (<a class="el" href="a00055.html" title="Base object for Optimization methods.">OptimizationObj</a>,..), which contains a list of parameters, some of which (but possibly all or none) are parameters belonging to this object. </td></tr>
    <tr><td class="paramname">groupIndex</td><td>a vector of unsigned integers, one for each parameter in the input object, giving an unsigned integer value as gene group index. At the beginning this vector should contain only zeros (no group assigned). </td></tr>
    <tr><td class="paramname">firstGroup</td><td>this is the number of groups which have already been assigned, plus one. The gene groups returned by this object will start from this value, and increment <b>firstGroup</b> for each gene group used, so that different <a class="el" href="a00071.html" title="Generic Refinable Object.">RefinableObj</a> cannot share a gene group. </td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>this function is not optimized, and should only be called at the beginning of a refinement. </dd></dl>

<p>Reimplemented from <a class="el" href="a00071.html#ad59c8ad2b0d7ee59fa3f399a54f05e54">ObjCryst::RefinableObj</a>.</p>

</div>
</div>
<a class="anchor" id="a63af7f309f1d9e03245f84ba21b1dc4e"></a><!-- doxytag: member="ObjCryst::ScatteringPower::GetMaximumLikelihoodParClock" ref="a63af7f309f1d9e03245f84ba21b1dc4e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a00072.html">RefinableObjClock</a>&amp; <a class="el" href="a00090.html#a63af7f309f1d9e03245f84ba21b1dc4e">ObjCryst::ScatteringPower::GetMaximumLikelihoodParClock</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the clock value for the last change on the maximum likelihood parameters (positionnal error, number of ghost atoms). </p>

</div>
</div>
<a class="anchor" id="a34a36179228e07e92a85da9d17376649"></a><!-- doxytag: member="ObjCryst::ScatteringPower::GetMaximumLikelihoodPositionError" ref="a34a36179228e07e92a85da9d17376649" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">REAL <a class="el" href="a00090.html#a34a36179228e07e92a85da9d17376649">ObjCryst::ScatteringPower::GetMaximumLikelihoodPositionError</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Maximum Likelihood: get the estimated error (sigma) on the positions for this kind of element. </p>

</div>
</div>
<a class="anchor" id="ac44860aca21734844379ddec87622f7b"></a><!-- doxytag: member="ObjCryst::ScatteringPower::GetRadius" ref="ac44860aca21734844379ddec87622f7b" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual REAL <a class="el" href="a00090.html#ac44860aca21734844379ddec87622f7b">ObjCryst::ScatteringPower::GetRadius</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the physical radius of this type of scatterer (for 3D display purposes). </p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>this may be removed later. </dd></dl>

<p>Implemented in <a class="el" href="a00091.html#a38cdad845523d408f473cdea050841a0">ObjCryst::ScatteringPowerAtom</a>, <a class="el" href="a00092.html#a1f4b091f0990b959acb0645fd575a080">ObjCryst::ScatteringPowerSphere</a>, and <a class="el" href="a00034.html#aadef1e0a463f70f4f70dba3d12dba9ed">ObjCryst::GlobalScatteringPower</a>.</p>

</div>
</div>
<a class="anchor" id="a9bc5d86bf76116f645b43d46f2a9771c"></a><!-- doxytag: member="ObjCryst::ScatteringPower::GetResonantScattFactImag" ref="a9bc5d86bf76116f645b43d46f2a9771c" args="(const ScatteringData &amp;data, const int spgSymPosIndex=&#45;1) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual CrystMatrix_REAL <a class="el" href="a00090.html#a9bc5d86bf76116f645b43d46f2a9771c">ObjCryst::ScatteringPower::GetResonantScattFactImag</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00089.html">ScatteringData</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>spgSymPosIndex</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the imaginary part of the resonant scattering factor. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a matrix where each row corresponds to each wavelength (currently only monochromatic experiments are made so there is only one row), and each column corresponds to each reflection <em>only</em> if the scattering term is anisotropic, which is not the case so far... </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data,:</td><td>the <a class="el" href="a00089.html" title="Class to compute structure factors for a set of reflections and a Crystal.">ScatteringData</a> object, giving access to all the reflections, and a list of wavelengths. </td></tr>
    <tr><td class="paramname">spgSymPosIndex,:</td><td>if the <a class="el" href="a00090.html" title="Abstract Base Class to describe the scattering power of any Scatterer component in a crystal...">ScatteringPower</a> is anisotropic, then the different symmetrics will not have the same scattering power for all reflections. This parameter is the index of the symmetric position in the Spacegroup. If spgSymPosIndex=-1, the isotropic values are returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>There is no anisotropic code yet, so spgSymPosIndex is simply ignored so far , but the design of this function is general for any anisotropic scattering. </dd></dl>

<p>Implemented in <a class="el" href="a00091.html#a18e0f4ec2008406f6b6f770abada9b88">ObjCryst::ScatteringPowerAtom</a>, <a class="el" href="a00092.html#aee221744487a1c29023399b71e855c06">ObjCryst::ScatteringPowerSphere</a>, and <a class="el" href="a00034.html#af3b5eefc24e2c60843793cdfbc240a11">ObjCryst::GlobalScatteringPower</a>.</p>

</div>
</div>
<a class="anchor" id="a42c1302254787d13b9e0f2210315291a"></a><!-- doxytag: member="ObjCryst::ScatteringPower::GetResonantScattFactReal" ref="a42c1302254787d13b9e0f2210315291a" args="(const ScatteringData &amp;data, const int spgSymPosIndex=&#45;1) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual CrystMatrix_REAL <a class="el" href="a00090.html#a42c1302254787d13b9e0f2210315291a">ObjCryst::ScatteringPower::GetResonantScattFactReal</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00089.html">ScatteringData</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>spgSymPosIndex</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the real part of the resonant scattering factor. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a matrix where each row corresponds to each wavelength (currently only monochromatic experiments are made so there is only one row), and each column corresponds to each reflection <em>only</em> if the scattering term is anisotropic, which is not the case so far... </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data,:</td><td>the <a class="el" href="a00089.html" title="Class to compute structure factors for a set of reflections and a Crystal.">ScatteringData</a> object, giving access to all the reflections and a list of wavelengths). </td></tr>
    <tr><td class="paramname">spgSymPosIndex,:</td><td>if the <a class="el" href="a00090.html" title="Abstract Base Class to describe the scattering power of any Scatterer component in a crystal...">ScatteringPower</a> is anisotropic, then the different symmetrics will not have the same scattering power for all reflections. This parameter is the index of the symmetric position in the Spacegroup. If spgSymPosIndex=-1, the isotropic values are returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>There is no anisotropic code yet, so spgSymPosIndex is simply ignored so far , but the design of this function is general for any anisotropic scattering. </dd></dl>

<p>Implemented in <a class="el" href="a00091.html#a538841350c5a7147f7be607dd3ef5b72">ObjCryst::ScatteringPowerAtom</a>, <a class="el" href="a00092.html#a064671bfd711ef108be7a1528e52cd46">ObjCryst::ScatteringPowerSphere</a>, and <a class="el" href="a00034.html#a9ddb16c057b744df58473fd2880baa3c">ObjCryst::GlobalScatteringPower</a>.</p>

</div>
</div>
<a class="anchor" id="af18f3eaaf45af87bc3a2a0ff21bc34b6"></a><!-- doxytag: member="ObjCryst::ScatteringPower::GetScatteringFactor" ref="af18f3eaaf45af87bc3a2a0ff21bc34b6" args="(const ScatteringData &amp;data, const int spgSymPosIndex=&#45;1) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual CrystVector_REAL <a class="el" href="a00090.html#af18f3eaaf45af87bc3a2a0ff21bc34b6">ObjCryst::ScatteringPower::GetScatteringFactor</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00089.html">ScatteringData</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>spgSymPosIndex</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the Scattering factor for all reflections of a given <a class="el" href="a00089.html" title="Class to compute structure factors for a set of reflections and a Crystal.">ScatteringData</a> object. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a vector with the scattering factor for all reflections, in the same order as in the <a class="el" href="a00089.html" title="Class to compute structure factors for a set of reflections and a Crystal.">ScatteringData</a> object. This format is independent of the radiation type (X-Ray, neutron..). </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data,:</td><td>the <a class="el" href="a00089.html" title="Class to compute structure factors for a set of reflections and a Crystal.">ScatteringData</a> object, giving access to all the reflections. </td></tr>
    <tr><td class="paramname">spgSymPosIndex,:</td><td>if the <a class="el" href="a00090.html" title="Abstract Base Class to describe the scattering power of any Scatterer component in a crystal...">ScatteringPower</a> is anisotropic, then the different symmetrics will not have the same scattering power for all reflections. This parameter is the index of the symmetric position in the Spacegroup. If spgSymPosIndex=-1, the isotropic values are returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>There is no anisotropic code yet, so spgSymPosIndex is simply ignored so far , but the design of this function is general for any anisotropic scattering. </dd></dl>

<p>Implemented in <a class="el" href="a00091.html#a1c1733e6f6aab65fbe033b877cac5ae8">ObjCryst::ScatteringPowerAtom</a>, <a class="el" href="a00092.html#a073f08b17ba89e0ac5ed8e1a61cb04fe">ObjCryst::ScatteringPowerSphere</a>, and <a class="el" href="a00034.html#acd525a54e45dc3c70fb5445b8b9b5a8c">ObjCryst::GlobalScatteringPower</a>.</p>

</div>
</div>
<a class="anchor" id="a5cdd13d241974a6e6f0d3803256a3d10"></a><!-- doxytag: member="ObjCryst::ScatteringPower::GetSymbol" ref="a5cdd13d241974a6e6f0d3803256a3d10" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const string&amp; <a class="el" href="a00090.html#a5cdd13d241974a6e6f0d3803256a3d10">ObjCryst::ScatteringPower::GetSymbol</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Symbol for this Scattering power (the atom name for atoms) </p>

<p>Reimplemented in <a class="el" href="a00091.html#a0b21c0253564cb40353171b182f50ecf">ObjCryst::ScatteringPowerAtom</a>.</p>

</div>
</div>
<a class="anchor" id="a3df723db77380c82ecff5f7050490255"></a><!-- doxytag: member="ObjCryst::ScatteringPower::GetTemperatureFactor" ref="a3df723db77380c82ecff5f7050490255" args="(const ScatteringData &amp;data, const int spgSymPosIndex=&#45;1) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual CrystVector_REAL <a class="el" href="a00090.html#a3df723db77380c82ecff5f7050490255">ObjCryst::ScatteringPower::GetTemperatureFactor</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00089.html">ScatteringData</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>spgSymPosIndex</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the temperature factor for all reflections of a given <a class="el" href="a00089.html" title="Class to compute structure factors for a set of reflections and a Crystal.">ScatteringData</a> object. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a vector with the temperature factor for all reflections, in the same order as in the <a class="el" href="a00089.html" title="Class to compute structure factors for a set of reflections and a Crystal.">ScatteringData</a> object. </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data,:</td><td>the <a class="el" href="a00089.html" title="Class to compute structure factors for a set of reflections and a Crystal.">ScatteringData</a> object, giving access to all the reflections. </td></tr>
    <tr><td class="paramname">spgSymPosIndex,:</td><td>if the <a class="el" href="a00090.html" title="Abstract Base Class to describe the scattering power of any Scatterer component in a crystal...">ScatteringPower</a> is anisotropic, then the different symmetrics will not have the same scattering power for all reflections. This parameter is the index of the symmetric position in the Spacegroup. If spgSymPosIndex=-1, the isotropic values are returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>There is no anisotropic code yet, so spgSymPosIndex is simply ignored so far , but the design of this function is general for any anisotropic scattering. </dd></dl>

<p>Implemented in <a class="el" href="a00091.html#aefe7a8b036c3f5a4a2b781b527dfa8c3">ObjCryst::ScatteringPowerAtom</a>, <a class="el" href="a00092.html#a3927291a20f5807c2ec6a9ae3627005d">ObjCryst::ScatteringPowerSphere</a>, and <a class="el" href="a00034.html#a48da59604bb5a35fdac09087bc0fcff4">ObjCryst::GlobalScatteringPower</a>.</p>

</div>
</div>
<a class="anchor" id="a50b648d97ebb1ab97b39195b098eff50"></a><!-- doxytag: member="ObjCryst::ScatteringPower::SetBij" ref="a50b648d97ebb1ab97b39195b098eff50" args="(const size_t &amp;idx, const REAL newB)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="a00090.html#a8c947f00897876d91f68617772a20dad">ObjCryst::ScatteringPower::SetBij</a> </td>
          <td>(</td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>newB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the anisotropic temperature B factor for given index. </p>
<p>0 -&gt; (1, 1) 1 -&gt; (2, 2) 2 -&gt; (3, 3) 3 -&gt; (1, 2) 4 -&gt; (1, 3) 5 -&gt; (2, 3) </p>

</div>
</div>
<a class="anchor" id="a179266106b89bcbb4885f9f20ce315c3"></a><!-- doxytag: member="ObjCryst::ScatteringPower::SetBiso" ref="a179266106b89bcbb4885f9f20ce315c3" args="(const REAL newB)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="a00090.html#a179266106b89bcbb4885f9f20ce315c3">ObjCryst::ScatteringPower::SetBiso</a> </td>
          <td>(</td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>newB</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the isotropic temperature B factor. </p>

</div>
</div>
<a class="anchor" id="aeba30efe61155572ffdada1121578bc9"></a><!-- doxytag: member="ObjCryst::ScatteringPower::SetMaximumLikelihoodPositionError" ref="aeba30efe61155572ffdada1121578bc9" args="(const REAL mle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00090.html#aeba30efe61155572ffdada1121578bc9">ObjCryst::ScatteringPower::SetMaximumLikelihoodPositionError</a> </td>
          <td>(</td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>mle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Maximum Likelihood: set the estimated error (sigma) on the positions for this kind of element. </p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a0266da1d92ec3d14989a2d4047710c4b"></a><!-- doxytag: member="ObjCryst::ScatteringPower::mDynPopCorrIndex" ref="a0266da1d92ec3d14989a2d4047710c4b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long <a class="el" href="a00090.html#a0266da1d92ec3d14989a2d4047710c4b">ObjCryst::ScatteringPower::mDynPopCorrIndex</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>number identifying this kind of scatterer, for the dynamical occupancy correction. </p>
<p>Right now it is the atomic number. </p>

</div>
</div>
<a class="anchor" id="a030be52e5ba5540bf068e6be4ccb190e"></a><!-- doxytag: member="ObjCryst::ScatteringPower::mFormalCharge" ref="a030be52e5ba5540bf068e6be4ccb190e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">REAL <a class="el" href="a00090.html#a030be52e5ba5540bf068e6be4ccb190e">ObjCryst::ScatteringPower::mFormalCharge</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Formal Charge. </p>
<p>This can be used for bond valence analysis, or energy calculations.</p>
<p>Default value is 0. </p>

</div>
</div>
<a class="anchor" id="a53eeb0a26003df0bcf604817e2fbadf7"></a><!-- doxytag: member="ObjCryst::ScatteringPower::mMaximumLikelihoodNbGhost" ref="a53eeb0a26003df0bcf604817e2fbadf7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">REAL <a class="el" href="a00090.html#a53eeb0a26003df0bcf604817e2fbadf7">ObjCryst::ScatteringPower::mMaximumLikelihoodNbGhost</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Number of ghost atoms in the asymmetric unit. </p>
<p>These contribute to the variance of the structure factor, but not to the structure factor as the uncertainty on their position is infinite. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>ScatteringPower.h</li>
</ul>
</div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Tue Apr 3 2012 18:20:01 for ObjCryst++ by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
