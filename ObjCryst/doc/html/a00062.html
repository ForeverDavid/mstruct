<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>ObjCryst++: ObjCryst::PowderPattern Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">ObjCryst++
   &#160;<span id="projectnumber">1.5CVS</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="a00171.html">ObjCryst</a></li><li class="navelem"><a class="el" href="a00062.html">PowderPattern</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<div class="title">ObjCryst::PowderPattern Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Powder pattern class, with an observed pattern and several calculated components to modelize the pattern.  
 <a href="a00062.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for ObjCryst::PowderPattern:</div>
<div class="dyncontent">
 <div class="center">
  <img src="a00062.png" usemap="#ObjCryst::PowderPattern_map" alt=""/>
  <map id="ObjCryst::PowderPattern_map" name="ObjCryst::PowderPattern_map">
<area href="a00071.html" title="Generic Refinable Object." alt="ObjCryst::RefinableObj" shape="rect" coords="0,0,151,24"/>
</map>
 </div></div>

<p><a href="a00282.html">List of all members.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6815f5a573037f29f5d7c5975c7d2360"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6815f5a573037f29f5d7c5975c7d2360"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PowderPattern</b> (const <a class="el" href="a00062.html">PowderPattern</a> &amp;)</td></tr>
<tr class="memitem:a20dadada4d5b428c5122d4c75fb49164"><td class="memItemLeft" align="right" valign="top">virtual const string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#a20dadada4d5b428c5122d4c75fb49164">GetClassName</a> () const </td></tr>
<tr class="memdesc:a20dadada4d5b428c5122d4c75fb49164"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name for this class ("RefinableObj", "Crystal",...).  <a href="#a20dadada4d5b428c5122d4c75fb49164"></a><br/></td></tr>
<tr class="memitem:a0190046adad7091ca0d7818b1ced7bb2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#a0190046adad7091ca0d7818b1ced7bb2">AddPowderPatternComponent</a> (<a class="el" href="a00065.html">PowderPatternComponent</a> &amp;)</td></tr>
<tr class="memdesc:a0190046adad7091ca0d7818b1ced7bb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a component (phase, backround) to this pattern.  <a href="#a0190046adad7091ca0d7818b1ced7bb2"></a><br/></td></tr>
<tr class="memitem:a6751e000cff31e66b311658bf24ab128"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6751e000cff31e66b311658bf24ab128"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#a6751e000cff31e66b311658bf24ab128">GetNbPowderPatternComponent</a> () const </td></tr>
<tr class="memdesc:a6751e000cff31e66b311658bf24ab128"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of components. <br/></td></tr>
<tr class="memitem:a88f56291e21538d47a2bbfa44f8c17d0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a88f56291e21538d47a2bbfa44f8c17d0"></a>
const <a class="el" href="a00065.html">PowderPatternComponent</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#a88f56291e21538d47a2bbfa44f8c17d0">GetPowderPatternComponent</a> (const string &amp;name) const </td></tr>
<tr class="memdesc:a88f56291e21538d47a2bbfa44f8c17d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to a component of the powder pattern. <br/></td></tr>
<tr class="memitem:ade54c0692377440cd110c88c11814326"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ade54c0692377440cd110c88c11814326"></a>
const <a class="el" href="a00065.html">PowderPatternComponent</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#ade54c0692377440cd110c88c11814326">GetPowderPatternComponent</a> (const int) const </td></tr>
<tr class="memdesc:ade54c0692377440cd110c88c11814326"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to a component of the powder pattern. <br/></td></tr>
<tr class="memitem:a75532455e2ffad2cf483038887d43308"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a75532455e2ffad2cf483038887d43308"></a>
<a class="el" href="a00065.html">PowderPatternComponent</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#a75532455e2ffad2cf483038887d43308">GetPowderPatternComponent</a> (const string &amp;name)</td></tr>
<tr class="memdesc:a75532455e2ffad2cf483038887d43308"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to a component of the powder pattern. <br/></td></tr>
<tr class="memitem:a06da395985ebd3c1e8f7dfd34f87a8fc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a06da395985ebd3c1e8f7dfd34f87a8fc"></a>
<a class="el" href="a00065.html">PowderPatternComponent</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#a06da395985ebd3c1e8f7dfd34f87a8fc">GetPowderPatternComponent</a> (const int)</td></tr>
<tr class="memdesc:a06da395985ebd3c1e8f7dfd34f87a8fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to a component of the powder pattern. <br/></td></tr>
<tr class="memitem:aa3db77c0b1ad916d480594e4453300e5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa3db77c0b1ad916d480594e4453300e5"></a>
REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#aa3db77c0b1ad916d480594e4453300e5">GetScaleFactor</a> (const int i) const </td></tr>
<tr class="memdesc:aa3db77c0b1ad916d480594e4453300e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to the scale factor of components (will be 1 for background components) <br/></td></tr>
<tr class="memitem:a14138c76f7cd9ee605432eb886c8cc12"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a14138c76f7cd9ee605432eb886c8cc12"></a>
REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#a14138c76f7cd9ee605432eb886c8cc12">GetScaleFactor</a> (const <a class="el" href="a00065.html">PowderPatternComponent</a> &amp;comp) const </td></tr>
<tr class="memdesc:a14138c76f7cd9ee605432eb886c8cc12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to the scale factor of components (will be 1 for background components) <br/></td></tr>
<tr class="memitem:a62f0bbe83a48154e23e8698e86545bb2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a62f0bbe83a48154e23e8698e86545bb2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#a62f0bbe83a48154e23e8698e86545bb2">SetScaleFactor</a> (const int i, REAL s)</td></tr>
<tr class="memdesc:a62f0bbe83a48154e23e8698e86545bb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to the scale factor of components (will be 1 for background components) <br/></td></tr>
<tr class="memitem:a23c3b15a62b104c8d3d5253d9975467f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a23c3b15a62b104c8d3d5253d9975467f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#a23c3b15a62b104c8d3d5253d9975467f">SetScaleFactor</a> (const <a class="el" href="a00065.html">PowderPatternComponent</a> &amp;comp, REAL s)</td></tr>
<tr class="memdesc:a23c3b15a62b104c8d3d5253d9975467f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to the scale factor of components (will be 1 for background components) <br/></td></tr>
<tr class="memitem:adb92497ec0c6793c1cb74fc1bf9914e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#adb92497ec0c6793c1cb74fc1bf9914e2">SetPowderPatternPar</a> (const REAL min, const REAL step, unsigned long nbPoint)</td></tr>
<tr class="memdesc:adb92497ec0c6793c1cb74fc1bf9914e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">the powder pattern angular range &amp; resolution parameter.  <a href="#adb92497ec0c6793c1cb74fc1bf9914e2"></a><br/></td></tr>
<tr class="memitem:a64170b8ead948e9b8569e1613d849583"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#a64170b8ead948e9b8569e1613d849583">SetPowderPatternX</a> (const CrystVector_REAL &amp;x)</td></tr>
<tr class="memdesc:a64170b8ead948e9b8569e1613d849583"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the x coordinate of the powder pattern : either the 2theta or time-of-flight values for each recorded point.  <a href="#a64170b8ead948e9b8569e1613d849583"></a><br/></td></tr>
<tr class="memitem:aa3a5a69a31b83735b015b28ef09e1722"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa3a5a69a31b83735b015b28ef09e1722"></a>
unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#aa3a5a69a31b83735b015b28ef09e1722">GetNbPoint</a> () const </td></tr>
<tr class="memdesc:aa3a5a69a31b83735b015b28ef09e1722"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of points ? <br/></td></tr>
<tr class="memitem:a0eb7f2167b25f58e4abcf4a4fa02ac2a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0eb7f2167b25f58e4abcf4a4fa02ac2a"></a>
unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#a0eb7f2167b25f58e4abcf4a4fa02ac2a">GetNbPointUsed</a> () const </td></tr>
<tr class="memdesc:a0eb7f2167b25f58e4abcf4a4fa02ac2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of points actually calculated (below the chosen max(sin(theta)/lambda)) ? <br/></td></tr>
<tr class="memitem:a6ae58ee1b78cfd6cc7d0681fe162f683"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6ae58ee1b78cfd6cc7d0681fe162f683"></a>
const <a class="el" href="a00072.html">RefinableObjClock</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#a6ae58ee1b78cfd6cc7d0681fe162f683">GetClockNbPointUsed</a> () const </td></tr>
<tr class="memdesc:a6ae58ee1b78cfd6cc7d0681fe162f683"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clock corresponding to the last time the number of points used was changed. <br/></td></tr>
<tr class="memitem:a78eed04935e86eded8ee11470fcb9232"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a78eed04935e86eded8ee11470fcb9232"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#a78eed04935e86eded8ee11470fcb9232">SetRadiation</a> (const <a class="el" href="a00069.html">Radiation</a> &amp;radiation)</td></tr>
<tr class="memdesc:a78eed04935e86eded8ee11470fcb9232"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the radiation. <br/></td></tr>
<tr class="memitem:aba39d0bd3780080f7730cb6aa368234a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aba39d0bd3780080f7730cb6aa368234a"></a>
const <a class="el" href="a00069.html">Radiation</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#aba39d0bd3780080f7730cb6aa368234a">GetRadiation</a> () const </td></tr>
<tr class="memdesc:aba39d0bd3780080f7730cb6aa368234a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Neutron or x-ray experiment ? <br/></td></tr>
<tr class="memitem:afc35a7b3cf68dae1830970b25e6e711f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afc35a7b3cf68dae1830970b25e6e711f"></a>
<a class="el" href="a00069.html">Radiation</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#afc35a7b3cf68dae1830970b25e6e711f">GetRadiation</a> ()</td></tr>
<tr class="memdesc:afc35a7b3cf68dae1830970b25e6e711f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Neutron or x-ray experiment ? <br/></td></tr>
<tr class="memitem:ad3def5314d887649c311a6519d3f6e28"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad3def5314d887649c311a6519d3f6e28"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#ad3def5314d887649c311a6519d3f6e28">SetRadiationType</a> (const <a class="el" href="a00171.html#a48fe50a094c607f8897378934d3d73ef">RadiationType</a> radiation)</td></tr>
<tr class="memdesc:ad3def5314d887649c311a6519d3f6e28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the radiation type. <br/></td></tr>
<tr class="memitem:a544895eb42e2817b35ad8adceac1cc4e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a544895eb42e2817b35ad8adceac1cc4e"></a>
<a class="el" href="a00171.html#a48fe50a094c607f8897378934d3d73ef">RadiationType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#a544895eb42e2817b35ad8adceac1cc4e">GetRadiationType</a> () const </td></tr>
<tr class="memdesc:a544895eb42e2817b35ad8adceac1cc4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Neutron or x-ray experiment ? <br/></td></tr>
<tr class="memitem:aea1c5351f710f2a91844b0f29b7b04aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#aea1c5351f710f2a91844b0f29b7b04aa">SetWavelength</a> (const REAL lambda)</td></tr>
<tr class="memdesc:aea1c5351f710f2a91844b0f29b7b04aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the wavelength of the experiment (in Angstroems).  <a href="#aea1c5351f710f2a91844b0f29b7b04aa"></a><br/></td></tr>
<tr class="memitem:a9638b42f38dd82522593e1e01b6629c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#a9638b42f38dd82522593e1e01b6629c6">SetWavelength</a> (const string &amp;XRayTubeElementName, const REAL alpha12ratio=0.5)</td></tr>
<tr class="memdesc:a9638b42f38dd82522593e1e01b6629c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the wavelength of the experiment to that of an X-Ray tube.  <a href="#a9638b42f38dd82522593e1e01b6629c6"></a><br/></td></tr>
<tr class="memitem:a09820e4b8d5a7b7f0e68963cb62a20d9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a09820e4b8d5a7b7f0e68963cb62a20d9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#a09820e4b8d5a7b7f0e68963cb62a20d9">SetEnergy</a> (const REAL energy)</td></tr>
<tr class="memdesc:a09820e4b8d5a7b7f0e68963cb62a20d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the energy of the experiment [in keV, lambda(A)=12398/E(keV)]. <br/></td></tr>
<tr class="memitem:aad186f62e923f41eee3786e60444355d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aad186f62e923f41eee3786e60444355d"></a>
REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#aad186f62e923f41eee3786e60444355d">GetWavelength</a> () const </td></tr>
<tr class="memdesc:aad186f62e923f41eee3786e60444355d"><td class="mdescLeft">&#160;</td><td class="mdescRight">wavelength of the experiment (in Angstroems) <br/></td></tr>
<tr class="memitem:ad65306dc5835e3592c13ca7c11a8b106"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad65306dc5835e3592c13ca7c11a8b106"></a>
const CrystVector_REAL &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#ad65306dc5835e3592c13ca7c11a8b106">GetPowderPatternCalc</a> () const </td></tr>
<tr class="memdesc:ad65306dc5835e3592c13ca7c11a8b106"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the calculated powder pattern. <br/></td></tr>
<tr class="memitem:a577f950d9d2d5e69dfdd31e8da0ab27a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a577f950d9d2d5e69dfdd31e8da0ab27a"></a>
const CrystVector_REAL &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#a577f950d9d2d5e69dfdd31e8da0ab27a">GetPowderPatternObs</a> () const </td></tr>
<tr class="memdesc:a577f950d9d2d5e69dfdd31e8da0ab27a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the observed powder pattern. <br/></td></tr>
<tr class="memitem:a05fa458401478e02a2e762deddfda4c2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a05fa458401478e02a2e762deddfda4c2"></a>
const CrystVector_REAL &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#a05fa458401478e02a2e762deddfda4c2">GetPowderPatternObsSigma</a> () const </td></tr>
<tr class="memdesc:a05fa458401478e02a2e762deddfda4c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the sigma for each point of the observed powder pattern. <br/></td></tr>
<tr class="memitem:af96377fff84b5bec7a2cd448587e7766"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af96377fff84b5bec7a2cd448587e7766"></a>
const CrystVector_REAL &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#af96377fff84b5bec7a2cd448587e7766">GetPowderPatternVariance</a> () const </td></tr>
<tr class="memdesc:af96377fff84b5bec7a2cd448587e7766"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the variance (obs+model) for each point of the powder pattern. <br/></td></tr>
<tr class="memitem:a41d74e9506222fbd22b32d606de23441"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a41d74e9506222fbd22b32d606de23441"></a>
const CrystVector_REAL &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#a41d74e9506222fbd22b32d606de23441">GetPowderPatternWeight</a> () const </td></tr>
<tr class="memdesc:a41d74e9506222fbd22b32d606de23441"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the weight for each point of the powder pattern. <br/></td></tr>
<tr class="memitem:a64ac562e1ca45f5419c5b7d08afe6146"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a64ac562e1ca45f5419c5b7d08afe6146"></a>
REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#a64ac562e1ca45f5419c5b7d08afe6146">GetPowderPatternXMin</a> () const </td></tr>
<tr class="memdesc:a64ac562e1ca45f5419c5b7d08afe6146"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Minimum 2theta. <br/></td></tr>
<tr class="memitem:ad4b20493be0077170b2870aeca474455"><td class="memItemLeft" align="right" valign="top">REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#ad4b20493be0077170b2870aeca474455">GetPowderPatternXStep</a> () const </td></tr>
<tr class="memdesc:ad4b20493be0077170b2870aeca474455"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the average step in 2theta.  <a href="#ad4b20493be0077170b2870aeca474455"></a><br/></td></tr>
<tr class="memitem:acd2151cd3d2673b210336fe8baf6c5ee"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acd2151cd3d2673b210336fe8baf6c5ee"></a>
REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#acd2151cd3d2673b210336fe8baf6c5ee">GetPowderPatternXMax</a> () const </td></tr>
<tr class="memdesc:acd2151cd3d2673b210336fe8baf6c5ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum 2theta. <br/></td></tr>
<tr class="memitem:ac37115cfe0ea3f7bd6f80b0068bcc94e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac37115cfe0ea3f7bd6f80b0068bcc94e"></a>
const CrystVector_REAL &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#ac37115cfe0ea3f7bd6f80b0068bcc94e">GetPowderPatternX</a> () const </td></tr>
<tr class="memdesc:ac37115cfe0ea3f7bd6f80b0068bcc94e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the vector of X (2theta or time-of-flight) coordinates. <br/></td></tr>
<tr class="memitem:a93114b9db1bfa862fdd8497ddf023547"><td class="memItemLeft" align="right" valign="top">const CrystVector_REAL &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#a93114b9db1bfa862fdd8497ddf023547">GetChi2Cumul</a> () const </td></tr>
<tr class="memdesc:a93114b9db1bfa862fdd8497ddf023547"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the powder pattern cumulative Chi^2.  <a href="#a93114b9db1bfa862fdd8497ddf023547"></a><br/></td></tr>
<tr class="memitem:ac99938787425e9e564413d55187583e5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac99938787425e9e564413d55187583e5"></a>
const <a class="el" href="a00072.html">RefinableObjClock</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#ac99938787425e9e564413d55187583e5">GetClockPowderPatternCalc</a> () const </td></tr>
<tr class="memdesc:ac99938787425e9e564413d55187583e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Last time the pattern was calculated. <br/></td></tr>
<tr class="memitem:a5d6d5ba62523890c5481473814110109"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5d6d5ba62523890c5481473814110109"></a>
const <a class="el" href="a00072.html">RefinableObjClock</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#a5d6d5ba62523890c5481473814110109">GetClockPowderPatternPar</a> () const </td></tr>
<tr class="memdesc:a5d6d5ba62523890c5481473814110109"><td class="mdescLeft">&#160;</td><td class="mdescRight">When were the pattern parameters (2theta range, step) changed ? <br/></td></tr>
<tr class="memitem:a53829d29d8af6528ecb182ff27f27919"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a53829d29d8af6528ecb182ff27f27919"></a>
const <a class="el" href="a00072.html">RefinableObjClock</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#a53829d29d8af6528ecb182ff27f27919">GetClockPowderPatternRadiation</a> () const </td></tr>
<tr class="memdesc:a53829d29d8af6528ecb182ff27f27919"><td class="mdescLeft">&#160;</td><td class="mdescRight">When were the radiation parameter (radiation type, wavelength) changed ? <br/></td></tr>
<tr class="memitem:abdc02543b8651a966d0a676a70971865"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abdc02543b8651a966d0a676a70971865"></a>
const <a class="el" href="a00072.html">RefinableObjClock</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#abdc02543b8651a966d0a676a70971865">GetClockPowderPatternXCorr</a> () const </td></tr>
<tr class="memdesc:abdc02543b8651a966d0a676a70971865"><td class="mdescLeft">&#160;</td><td class="mdescRight">When were the parameters for 2theta/TOF correction (zero, transparency, displacement) last changed ? <br/></td></tr>
<tr class="memitem:a5f0a77781549a546e5e2b9dc76f14622"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5f0a77781549a546e5e2b9dc76f14622"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#a5f0a77781549a546e5e2b9dc76f14622">SetXZero</a> (const REAL newZero)</td></tr>
<tr class="memdesc:a5f0a77781549a546e5e2b9dc76f14622"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change Zero in x (2theta,tof) <br/></td></tr>
<tr class="memitem:aee018af94fbc876762ccd98b0c8cb982"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aee018af94fbc876762ccd98b0c8cb982"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#aee018af94fbc876762ccd98b0c8cb982">Set2ThetaDisplacement</a> (const REAL displacement)</td></tr>
<tr class="memdesc:aee018af94fbc876762ccd98b0c8cb982"><td class="mdescLeft">&#160;</td><td class="mdescRight"><pre class="fragment">        Change displacement correction
</pre><p> <img class="formulaInl" alt="$ (2\theta)_{obs} = (2\theta)_{real} + a\cos(\theta) $" src="form_17.png"/> <br/></td></tr>
<tr class="memitem:a7520df007f0e2058201c81f6bf6122ff"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7520df007f0e2058201c81f6bf6122ff"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#a7520df007f0e2058201c81f6bf6122ff">Set2ThetaTransparency</a> (const REAL transparency)</td></tr>
<tr class="memdesc:a7520df007f0e2058201c81f6bf6122ff"><td class="mdescLeft">&#160;</td><td class="mdescRight"><pre class="fragment">       Change transparency correction
</pre><p> <img class="formulaInl" alt="$ (2\theta)_{obs} = (2\theta)_{real} + b\sin(2\theta) $" src="form_18.png"/> <br/></td></tr>
<tr class="memitem:a4499e38a96db3f3c0abdb6d30f3400e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#a4499e38a96db3f3c0abdb6d30f3400e1">ImportPowderPatternFullprof</a> (const string &amp;fullprofFileName)</td></tr>
<tr class="memdesc:a4499e38a96db3f3c0abdb6d30f3400e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Import fullprof-style diffraction data.  <a href="#a4499e38a96db3f3c0abdb6d30f3400e1"></a><br/></td></tr>
<tr class="memitem:a1ccba50e0df8ec4fb53c262b72ef384f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1ccba50e0df8ec4fb53c262b72ef384f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#a1ccba50e0df8ec4fb53c262b72ef384f">ImportPowderPatternPSI_DMC</a> (const string &amp;filename)</td></tr>
<tr class="memdesc:a1ccba50e0df8ec4fb53c262b72ef384f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Import powder pattern, format DMC from PSI. <br/></td></tr>
<tr class="memitem:a900f73bf552e7e6264638dd6ed6276a1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a900f73bf552e7e6264638dd6ed6276a1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#a900f73bf552e7e6264638dd6ed6276a1">ImportPowderPatternILL_D1A5</a> (const string &amp;filename)</td></tr>
<tr class="memdesc:a900f73bf552e7e6264638dd6ed6276a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Import powder pattern, format from ILL D1A/D2B (format without counter info) <br/></td></tr>
<tr class="memitem:a4a8e1dc893c04a4451327d3f48f21d0e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#a4a8e1dc893c04a4451327d3f48f21d0e">ImportPowderPatternXdd</a> (const string &amp;fileName)</td></tr>
<tr class="memdesc:a4a8e1dc893c04a4451327d3f48f21d0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Import *.xdd diffraction data (Topas,...).  <a href="#a4a8e1dc893c04a4451327d3f48f21d0e"></a><br/></td></tr>
<tr class="memitem:adabe6381d8d1189abcf420f69a41cc81"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#adabe6381d8d1189abcf420f69a41cc81">ImportPowderPatternSietronicsCPI</a> (const string &amp;fileName)</td></tr>
<tr class="memdesc:adabe6381d8d1189abcf420f69a41cc81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Import *.cpi Sietronics diffraction data.  <a href="#adabe6381d8d1189abcf420f69a41cc81"></a><br/></td></tr>
<tr class="memitem:aee56a2f23b8af5c855ceae82c246f242"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#aee56a2f23b8af5c855ceae82c246f242">ImportPowderPattern2ThetaObsSigma</a> (const string &amp;fileName, const int nbSkip=0)</td></tr>
<tr class="memdesc:aee56a2f23b8af5c855ceae82c246f242"><td class="mdescLeft">&#160;</td><td class="mdescRight">Import file with 3 columns 2Theta Iobs Sigma.  <a href="#aee56a2f23b8af5c855ceae82c246f242"></a><br/></td></tr>
<tr class="memitem:a272b9fd71a6925eb9e1a991e488259b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#a272b9fd71a6925eb9e1a991e488259b4">ImportPowderPatternFullprof4</a> (const string &amp;fileName)</td></tr>
<tr class="memdesc:a272b9fd71a6925eb9e1a991e488259b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Import diffraction data from a file, with the first line has 2ThetaMin, step, 2thetaMax, and the following lines alternate 10 Iobs and 10 sigma.  <a href="#a272b9fd71a6925eb9e1a991e488259b4"></a><br/></td></tr>
<tr class="memitem:abfc7890a1853583957284fc1a2644855"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#abfc7890a1853583957284fc1a2644855">ImportPowderPatternMultiDetectorLLBG42</a> (const string &amp;fileName)</td></tr>
<tr class="memdesc:abfc7890a1853583957284fc1a2644855"><td class="mdescLeft">&#160;</td><td class="mdescRight">diffraction data in a multi-detector format (fullprof format #6).  <a href="#abfc7890a1853583957284fc1a2644855"></a><br/></td></tr>
<tr class="memitem:a1c817b8e20b03b216323933e01e6fb00"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#a1c817b8e20b03b216323933e01e6fb00">ImportPowderPattern2ThetaObs</a> (const string &amp;fileName, const int nbSkip=0)</td></tr>
<tr class="memdesc:a1c817b8e20b03b216323933e01e6fb00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Import file with 2 columns 2Theta Iobs.  <a href="#a1c817b8e20b03b216323933e01e6fb00"></a><br/></td></tr>
<tr class="memitem:a9d7209065acb5a992129cf6a2b14b526"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#a9d7209065acb5a992129cf6a2b14b526">ImportPowderPatternTOF_ISIS_XYSigma</a> (const string &amp;fileName)</td></tr>
<tr class="memdesc:a9d7209065acb5a992129cf6a2b14b526"><td class="mdescLeft">&#160;</td><td class="mdescRight">Import TOF file (ISIS type, 3 columns t, Iobs, sigma(Iobs))  <a href="#a9d7209065acb5a992129cf6a2b14b526"></a><br/></td></tr>
<tr class="memitem:a78be27d8764377f99e324a7181eac633"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#a78be27d8764377f99e324a7181eac633">ImportPowderPatternGSAS</a> (const string &amp;fileName)</td></tr>
<tr class="memdesc:a78be27d8764377f99e324a7181eac633"><td class="mdescLeft">&#160;</td><td class="mdescRight">Import GSAS standard powder pattern data (see GSAS manual).  <a href="#a78be27d8764377f99e324a7181eac633"></a><br/></td></tr>
<tr class="memitem:a50348c3084e39c0c8f46a3ddccc03e1f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a50348c3084e39c0c8f46a3ddccc03e1f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#a50348c3084e39c0c8f46a3ddccc03e1f">ImportPowderPatternCIF</a> (const <a class="el" href="a00017.html">CIF</a> &amp;cif)</td></tr>
<tr class="memdesc:a50348c3084e39c0c8f46a3ddccc03e1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Import <a class="el" href="a00017.html" title="Main CIF class - parses the stream and separates data blocks, comments, items, loops.">CIF</a> powder pattern data. <br/></td></tr>
<tr class="memitem:a8562e190d277379e6e18d43f3d616976"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#a8562e190d277379e6e18d43f3d616976">SetPowderPatternObs</a> (const CrystVector_REAL &amp;obs)</td></tr>
<tr class="memdesc:a8562e190d277379e6e18d43f3d616976"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set observed powder pattern from vector array.  <a href="#a8562e190d277379e6e18d43f3d616976"></a><br/></td></tr>
<tr class="memitem:a9d47390be9f1a5a47ea141d2708b8992"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#a9d47390be9f1a5a47ea141d2708b8992">SavePowderPattern</a> (const string &amp;filename=&quot;powderPattern.out&quot;) const </td></tr>
<tr class="memdesc:a9d47390be9f1a5a47ea141d2708b8992"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save powder pattern to one file, text format, 3 columns theta Iobs Icalc.  <a href="#a9d47390be9f1a5a47ea141d2708b8992"></a><br/></td></tr>
<tr class="memitem:ab5319864b297bf008d239145730b04b5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab5319864b297bf008d239145730b04b5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#ab5319864b297bf008d239145730b04b5">PrintObsCalcData</a> (ostream &amp;os=cout) const </td></tr>
<tr class="memdesc:ab5319864b297bf008d239145730b04b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print to thee screen/console the observed and calculated pattern (long, mostly useful for debugging) <br/></td></tr>
<tr class="memitem:a761c704aab8ad2b326f6b287ba837a5c"><td class="memItemLeft" align="right" valign="top">REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#a761c704aab8ad2b326f6b287ba837a5c">GetR</a> () const </td></tr>
<tr class="memdesc:a761c704aab8ad2b326f6b287ba837a5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unweighted R-factor.  <a href="#a761c704aab8ad2b326f6b287ba837a5c"></a><br/></td></tr>
<tr class="memitem:a68f3f82a5bba57b7f011c528747ce337"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a68f3f82a5bba57b7f011c528747ce337"></a>
REAL&#160;</td><td class="memItemRight" valign="bottom"><b>GetIntegratedR</b> () const </td></tr>
<tr class="memitem:aa756bdaad051400d841989bc6e9bef55"><td class="memItemLeft" align="right" valign="top">REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#aa756bdaad051400d841989bc6e9bef55">GetRw</a> () const </td></tr>
<tr class="memdesc:aa756bdaad051400d841989bc6e9bef55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the weighted R-factor.  <a href="#aa756bdaad051400d841989bc6e9bef55"></a><br/></td></tr>
<tr class="memitem:a44215fd267e85dd3e77b437687ed98cc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a44215fd267e85dd3e77b437687ed98cc"></a>
REAL&#160;</td><td class="memItemRight" valign="bottom"><b>GetIntegratedRw</b> () const </td></tr>
<tr class="memitem:a96de1d1c8239548e8fad099d99b8a420"><td class="memItemLeft" align="right" valign="top">REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#a96de1d1c8239548e8fad099d99b8a420">GetChi2</a> () const </td></tr>
<tr class="memdesc:a96de1d1c8239548e8fad099d99b8a420"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return conventionnal Chi^2.  <a href="#a96de1d1c8239548e8fad099d99b8a420"></a><br/></td></tr>
<tr class="memitem:aae204d24cf18b10e40faa7a5560011de"><td class="memItemLeft" align="right" valign="top">REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#aae204d24cf18b10e40faa7a5560011de">GetIntegratedChi2</a> () const </td></tr>
<tr class="memdesc:aae204d24cf18b10e40faa7a5560011de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return integrated Chi^2.  <a href="#aae204d24cf18b10e40faa7a5560011de"></a><br/></td></tr>
<tr class="memitem:a92f59c2a608b63a166ee2e002540ae75"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a92f59c2a608b63a166ee2e002540ae75"></a>
REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#a92f59c2a608b63a166ee2e002540ae75">GetChi2_Option</a> () const </td></tr>
<tr class="memdesc:a92f59c2a608b63a166ee2e002540ae75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the conventionnal or integrated Chi^2, depending on the option. <br/></td></tr>
<tr class="memitem:abe0341d5a09b6a9c44d1c91d47c5153f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abe0341d5a09b6a9c44d1c91d47c5153f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#abe0341d5a09b6a9c44d1c91d47c5153f">FitScaleFactorForR</a> () const </td></tr>
<tr class="memdesc:abe0341d5a09b6a9c44d1c91d47c5153f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fit the scale(s) factor of each component to minimize R. <br/></td></tr>
<tr class="memitem:a1c68a9d2b723641f460fa8ebc48070ca"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1c68a9d2b723641f460fa8ebc48070ca"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>FitScaleFactorForIntegratedR</b> () const </td></tr>
<tr class="memitem:aee42df6a7994844b9aec9c67b63ae693"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aee42df6a7994844b9aec9c67b63ae693"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#aee42df6a7994844b9aec9c67b63ae693">FitScaleFactorForRw</a> () const </td></tr>
<tr class="memdesc:aee42df6a7994844b9aec9c67b63ae693"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fit the scale(s) factor of each component to minimize Rw. <br/></td></tr>
<tr class="memitem:a6eb8195658e125d5ecb0ea5891fe2595"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6eb8195658e125d5ecb0ea5891fe2595"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>FitScaleFactorForIntegratedRw</b> () const </td></tr>
<tr class="memitem:a1f2397ca48de524cb3916103eb83a267"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1f2397ca48de524cb3916103eb83a267"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#a1f2397ca48de524cb3916103eb83a267">SetSigmaToSqrtIobs</a> ()</td></tr>
<tr class="memdesc:a1f2397ca48de524cb3916103eb83a267"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set sigma=sqrt(Iobs) <br/></td></tr>
<tr class="memitem:add7d97cdb7610f7553b95c2eeefcd172"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#add7d97cdb7610f7553b95c2eeefcd172">SetWeightToInvSigmaSq</a> (const REAL minRelatSigma=1e-3)</td></tr>
<tr class="memdesc:add7d97cdb7610f7553b95c2eeefcd172"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set w = 1/sigma^2.  <a href="#add7d97cdb7610f7553b95c2eeefcd172"></a><br/></td></tr>
<tr class="memitem:a57bbc965281ecca08c5f6bc0d0076e00"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a57bbc965281ecca08c5f6bc0d0076e00"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#a57bbc965281ecca08c5f6bc0d0076e00">SetWeightToUnit</a> ()</td></tr>
<tr class="memdesc:a57bbc965281ecca08c5f6bc0d0076e00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set w = 1. <br/></td></tr>
<tr class="memitem:a3648701bed1a9ba0b576241226e06032"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#a3648701bed1a9ba0b576241226e06032">SetWeightPolynomial</a> (const REAL a, const REAL b, const REAL c, const REAL minRelatIobs=1e-3)</td></tr>
<tr class="memdesc:a3648701bed1a9ba0b576241226e06032"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set w = 1/(a+ Iobs + b*Iobs^2+c*Iobs^3)  <a href="#a3648701bed1a9ba0b576241226e06032"></a><br/></td></tr>
<tr class="memitem:a964850cf74baa499f823e85447959790"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#a964850cf74baa499f823e85447959790">AddExcludedRegion</a> (const REAL min2Theta, const REAL max2theta)</td></tr>
<tr class="memdesc:a964850cf74baa499f823e85447959790"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an Exclusion region, in 2theta, which will be ignored when computing R's XMLInput values must be, as always, in radians.  <a href="#a964850cf74baa499f823e85447959790"></a><br/></td></tr>
<tr class="memitem:a8e29b6186253d686c4f078906592df7b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#a8e29b6186253d686c4f078906592df7b">BeginOptimization</a> (const bool allowApproximations=false, const bool enableRestraints=false)</td></tr>
<tr class="memdesc:a8e29b6186253d686c4f078906592df7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This should be called by any optimization class at the begining of an optimization.  <a href="#a8e29b6186253d686c4f078906592df7b"></a><br/></td></tr>
<tr class="memitem:a35119a32e043f1b9e003cfe1ed18a1b1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#a35119a32e043f1b9e003cfe1ed18a1b1">GlobalOptRandomMove</a> (const REAL mutationAmplitude, const <a class="el" href="a00080.html">RefParType</a> *type=<a class="el" href="a00171.html#a92ed37a804903dfb302d70309b7bc474">gpRefParTypeObjCryst</a>)</td></tr>
<tr class="memdesc:a35119a32e043f1b9e003cfe1ed18a1b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a random move of the current configuration.  <a href="#a35119a32e043f1b9e003cfe1ed18a1b1"></a><br/></td></tr>
<tr class="memitem:a40363370a5a3e82d445fc3f1d653fd63"><td class="memItemLeft" align="right" valign="top">virtual REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#a40363370a5a3e82d445fc3f1d653fd63">GetLogLikelihood</a> () const </td></tr>
<tr class="memdesc:a40363370a5a3e82d445fc3f1d653fd63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get -log(likelihood) of the current configuration for the object.  <a href="#a40363370a5a3e82d445fc3f1d653fd63"></a><br/></td></tr>
<tr class="memitem:a2d2660f3e10f7df990762fb43c0754ac"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2d2660f3e10f7df990762fb43c0754ac"></a>
virtual unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#a2d2660f3e10f7df990762fb43c0754ac">GetNbLSQFunction</a> () const </td></tr>
<tr class="memdesc:a2d2660f3e10f7df990762fb43c0754ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of LSQ functions. <br/></td></tr>
<tr class="memitem:a6ef6fbc13720b0dcdd3088bd3139a9bb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6ef6fbc13720b0dcdd3088bd3139a9bb"></a>
virtual const CrystVector_REAL &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#a6ef6fbc13720b0dcdd3088bd3139a9bb">GetLSQCalc</a> (const unsigned int) const </td></tr>
<tr class="memdesc:a6ef6fbc13720b0dcdd3088bd3139a9bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current calculated value for the LSQ function. <br/></td></tr>
<tr class="memitem:ae80221740ac8000fecff6cdc941c7881"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae80221740ac8000fecff6cdc941c7881"></a>
virtual const CrystVector_REAL &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#ae80221740ac8000fecff6cdc941c7881">GetLSQObs</a> (const unsigned int) const </td></tr>
<tr class="memdesc:ae80221740ac8000fecff6cdc941c7881"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the observed values for the LSQ function. <br/></td></tr>
<tr class="memitem:a8b54821ac48a0eaefaa69162e866471e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8b54821ac48a0eaefaa69162e866471e"></a>
virtual const CrystVector_REAL &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#a8b54821ac48a0eaefaa69162e866471e">GetLSQWeight</a> (const unsigned int) const </td></tr>
<tr class="memdesc:a8b54821ac48a0eaefaa69162e866471e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the weight values for the LSQ function. <br/></td></tr>
<tr class="memitem:a85e8803b7680a6d3b5463990fee76c6f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#a85e8803b7680a6d3b5463990fee76c6f">XMLOutput</a> (ostream &amp;os, int indent=0) const </td></tr>
<tr class="memdesc:a85e8803b7680a6d3b5463990fee76c6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output to stream in well-formed XML.  <a href="#a85e8803b7680a6d3b5463990fee76c6f"></a><br/></td></tr>
<tr class="memitem:ae80f37cee10c08e6acb02300fe30c894"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#ae80f37cee10c08e6acb02300fe30c894">XMLInput</a> (istream &amp;is, const <a class="el" href="a00151.html">XMLCrystTag</a> &amp;tag)</td></tr>
<tr class="memdesc:ae80f37cee10c08e6acb02300fe30c894"><td class="mdescLeft">&#160;</td><td class="mdescRight">Input From stream.  <a href="#ae80f37cee10c08e6acb02300fe30c894"></a><br/></td></tr>
<tr class="memitem:ae03f4d2f08e749e4f494eb78050dbffe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#ae03f4d2f08e749e4f494eb78050dbffe">Prepare</a> ()</td></tr>
<tr class="memitem:ad3b643041cc61a3d39765bd7c268d6bc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#ad3b643041cc61a3d39765bd7c268d6bc">GetGeneGroup</a> (const <a class="el" href="a00071.html">RefinableObj</a> &amp;obj, CrystVector_uint &amp;groupIndex, unsigned int &amp;firstGroup) const </td></tr>
<tr class="memdesc:ad3b643041cc61a3d39765bd7c268d6bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the gene group assigned to each parameter.  <a href="#ad3b643041cc61a3d39765bd7c268d6bc"></a><br/></td></tr>
<tr class="memitem:a2b7b3ba4d020f3cf77409116ab0c7782"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#a2b7b3ba4d020f3cf77409116ab0c7782">SetMaxSinThetaOvLambda</a> (const REAL max)</td></tr>
<tr class="memdesc:a2b7b3ba4d020f3cf77409116ab0c7782"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the maximum value for sin(theta)/lambda.  <a href="#a2b7b3ba4d020f3cf77409116ab0c7782"></a><br/></td></tr>
<tr class="memitem:a4d779670e3ac85bf1ddb17b4d2d3b294"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4d779670e3ac85bf1ddb17b4d2d3b294"></a>
REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#a4d779670e3ac85bf1ddb17b4d2d3b294">GetMaxSinThetaOvLambda</a> () const </td></tr>
<tr class="memdesc:a4d779670e3ac85bf1ddb17b4d2d3b294"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum value for sin(theta)/lambda. <br/></td></tr>
<tr class="memitem:ab1474a1d0cd2c655384c23a78a1ea110"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab1474a1d0cd2c655384c23a78a1ea110"></a>
const CrystVector_long &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#ab1474a1d0cd2c655384c23a78a1ea110">GetIntegratedProfileMin</a> () const </td></tr>
<tr class="memdesc:ab1474a1d0cd2c655384c23a78a1ea110"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the list of first pixels for the integration intervals. <br/></td></tr>
<tr class="memitem:af1e56a7c30bdcc7053da429fb74ff628"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af1e56a7c30bdcc7053da429fb74ff628"></a>
const CrystVector_long &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#af1e56a7c30bdcc7053da429fb74ff628">GetIntegratedProfileMax</a> () const </td></tr>
<tr class="memdesc:af1e56a7c30bdcc7053da429fb74ff628"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the list of last pixels for the integration intervals. <br/></td></tr>
<tr class="memitem:a986e0c8bcb2f0d920bc35a8cc542a008"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a986e0c8bcb2f0d920bc35a8cc542a008"></a>
const <a class="el" href="a00072.html">RefinableObjClock</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#a986e0c8bcb2f0d920bc35a8cc542a008">GetIntegratedProfileLimitsClock</a> () const </td></tr>
<tr class="memdesc:a986e0c8bcb2f0d920bc35a8cc542a008"><td class="mdescLeft">&#160;</td><td class="mdescRight">When were the integration intervals last changed ? <br/></td></tr>
<tr class="memitem:a4c39ce0ed469d514cdec31efeb7a49a4"><td class="memItemLeft" align="right" valign="top">REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#a4c39ce0ed469d514cdec31efeb7a49a4">X2XCorr</a> (const REAL x) const </td></tr>
<tr class="memdesc:a4c39ce0ed469d514cdec31efeb7a49a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the experimental x (2theta, tof) from the theoretical value, taking into account all corrections (zero, transparency,..).  <a href="#a4c39ce0ed469d514cdec31efeb7a49a4"></a><br/></td></tr>
<tr class="memitem:a53607c581d6322d3902663c4338d66b7"><td class="memItemLeft" align="right" valign="top">REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#a53607c581d6322d3902663c4338d66b7">X2PixelCorr</a> (const REAL x) const </td></tr>
<tr class="memdesc:a53607c581d6322d3902663c4338d66b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the pixel number on the experimental pattern, from the theoretical (uncorrected) x coordinate, taking into account all corrections.  <a href="#a53607c581d6322d3902663c4338d66b7"></a><br/></td></tr>
<tr class="memitem:a352e6d6afb489c2c24e811fa8b70d801"><td class="memItemLeft" align="right" valign="top">REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#a352e6d6afb489c2c24e811fa8b70d801">X2Pixel</a> (const REAL x) const </td></tr>
<tr class="memdesc:a352e6d6afb489c2c24e811fa8b70d801"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the pixel number on the experimental pattern, corresponding to a given (experimental) x coordinate.  <a href="#a352e6d6afb489c2c24e811fa8b70d801"></a><br/></td></tr>
<tr class="memitem:a432996a6cc82b3029e5615b1d144a0dd"><td class="memItemLeft" align="right" valign="top">REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#a432996a6cc82b3029e5615b1d144a0dd">STOL2X</a> (const REAL stol) const </td></tr>
<tr class="memdesc:a432996a6cc82b3029e5615b1d144a0dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert sin(theta)/lambda to X (i.e.  <a href="#a432996a6cc82b3029e5615b1d144a0dd"></a><br/></td></tr>
<tr class="memitem:a0f6a97d56244a3e03b6742bec5e4199f"><td class="memItemLeft" align="right" valign="top">REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#a0f6a97d56244a3e03b6742bec5e4199f">X2STOL</a> (const REAL x) const </td></tr>
<tr class="memdesc:a0f6a97d56244a3e03b6742bec5e4199f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert X (either 2theta or TOF) to sin(theta)/lambda, depending on the type of radiation.  <a href="#a0f6a97d56244a3e03b6742bec5e4199f"></a><br/></td></tr>
<tr class="memitem:acea2e9e61825c9d68f73352cc5373215"><td class="memItemLeft" align="right" valign="top">REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#acea2e9e61825c9d68f73352cc5373215">STOL2Pixel</a> (const REAL stol) const </td></tr>
<tr class="memdesc:acea2e9e61825c9d68f73352cc5373215"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert sin(theta)/lambda to pixel, depending on the type of radiation.  <a href="#acea2e9e61825c9d68f73352cc5373215"></a><br/></td></tr>
<tr class="memitem:ad9de9c25681448972d968ec992534a2f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad9de9c25681448972d968ec992534a2f"></a>
<a class="el" href="a00060.html">PeakList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#ad9de9c25681448972d968ec992534a2f">FindPeaks</a> (const float dmin=2.0, const float maxratio=0.01, const unsigned int maxpeak=100)</td></tr>
<tr class="memdesc:ad9de9c25681448972d968ec992534a2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find peaks in the pattern. <br/></td></tr>
<tr class="memitem:adf389913f29eafe30d54fb778a3a75b8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adf389913f29eafe30d54fb778a3a75b8"></a>
const CrystVector_REAL &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#adf389913f29eafe30d54fb778a3a75b8">GetScaleFactor</a> () const </td></tr>
<tr class="memdesc:adf389913f29eafe30d54fb778a3a75b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the scale factors (see PowderPattern::mScaleFactor) <br/></td></tr>
<tr class="memitem:a27cc704339074a3a92395c2d632fc101"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a27cc704339074a3a92395c2d632fc101"></a>
CrystVector_REAL &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#a27cc704339074a3a92395c2d632fc101">GetScaleFactor</a> ()</td></tr>
<tr class="memdesc:a27cc704339074a3a92395c2d632fc101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the scale factors (see PowderPattern::mScaleFactor) <br/></td></tr>
<tr class="memitem:ab2ca32b0ae9d02c057c3e37b253314bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#ab2ca32b0ae9d02c057c3e37b253314bb">ExportFullprof</a> (const std::string &amp;prefix) const </td></tr>
<tr class="memdesc:ab2ca32b0ae9d02c057c3e37b253314bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export powder pattern &amp; crystal structure in Fullprof format.  <a href="#ab2ca32b0ae9d02c057c3e37b253314bb"></a><br/></td></tr>
<tr class="inherit_header pub_methods_a00071"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_a00071')"><img src="closed.png" alt="-"/>&nbsp;Public Member Functions inherited from <a class="el" href="a00071.html">ObjCryst::RefinableObj</a></td></tr>
<tr class="memitem:a081d2bfc2065c2adaa2bfdf292900235 inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a081d2bfc2065c2adaa2bfdf292900235"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a081d2bfc2065c2adaa2bfdf292900235">RefinableObj</a> ()</td></tr>
<tr class="memdesc:a081d2bfc2065c2adaa2bfdf292900235 inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br/></td></tr>
<tr class="memitem:aa0eaf0982686476cbec02a8afeebc92d inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#aa0eaf0982686476cbec02a8afeebc92d">RefinableObj</a> (const bool internalUseOnly)</td></tr>
<tr class="memdesc:aa0eaf0982686476cbec02a8afeebc92d inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#aa0eaf0982686476cbec02a8afeebc92d"></a><br/></td></tr>
<tr class="memitem:a5f77dcf037cc8d2ea1fd84bfda6ddbc0 inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a5f77dcf037cc8d2ea1fd84bfda6ddbc0">RefinableObj</a> (const <a class="el" href="a00071.html">RefinableObj</a> &amp;old)</td></tr>
<tr class="memdesc:a5f77dcf037cc8d2ea1fd84bfda6ddbc0 inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defined not implemented...  <a href="#a5f77dcf037cc8d2ea1fd84bfda6ddbc0"></a><br/></td></tr>
<tr class="memitem:a5cd8d41a828153e2585077a9fbd334ce inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5cd8d41a828153e2585077a9fbd334ce"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a5cd8d41a828153e2585077a9fbd334ce">~RefinableObj</a> ()</td></tr>
<tr class="memdesc:a5cd8d41a828153e2585077a9fbd334ce inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br/></td></tr>
<tr class="memitem:a61f51d3364e13a542e8c32df454c88aa inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a61f51d3364e13a542e8c32df454c88aa"></a>
virtual const string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a61f51d3364e13a542e8c32df454c88aa">GetName</a> () const </td></tr>
<tr class="memdesc:a61f51d3364e13a542e8c32df454c88aa inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name of the object. <br/></td></tr>
<tr class="memitem:a464caf574804fc21bd896f823131a1d7 inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a464caf574804fc21bd896f823131a1d7"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a464caf574804fc21bd896f823131a1d7">SetName</a> (const string &amp;name)</td></tr>
<tr class="memdesc:a464caf574804fc21bd896f823131a1d7 inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name of the object. <br/></td></tr>
<tr class="memitem:ab9b15adff1092f15e8f06cfeecc314f8 inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#ab9b15adff1092f15e8f06cfeecc314f8">operator=</a> (const <a class="el" href="a00071.html">RefinableObj</a> &amp;old)</td></tr>
<tr class="memdesc:ab9b15adff1092f15e8f06cfeecc314f8 inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defined not implemented...  <a href="#ab9b15adff1092f15e8f06cfeecc314f8"></a><br/></td></tr>
<tr class="memitem:a0e9b816ad753f633ef6d9650ec6b4ca6 inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a0e9b816ad753f633ef6d9650ec6b4ca6">PrepareForRefinement</a> () const </td></tr>
<tr class="memdesc:a0e9b816ad753f633ef6d9650ec6b4ca6 inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find which parameters are used and <b>not</b> fixed, for a refinement /optimization.  <a href="#a0e9b816ad753f633ef6d9650ec6b4ca6"></a><br/></td></tr>
<tr class="memitem:ac1a65da1f7563472badaf699002b8b8b inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac1a65da1f7563472badaf699002b8b8b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#ac1a65da1f7563472badaf699002b8b8b">FixAllPar</a> ()</td></tr>
<tr class="memdesc:ac1a65da1f7563472badaf699002b8b8b inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fix All parameters. <br/></td></tr>
<tr class="memitem:ab75dcf763d7f96063dcb4d85e6e78007 inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab75dcf763d7f96063dcb4d85e6e78007"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#ab75dcf763d7f96063dcb4d85e6e78007">UnFixAllPar</a> ()</td></tr>
<tr class="memdesc:ab75dcf763d7f96063dcb4d85e6e78007 inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">UnFix All parameters. <br/></td></tr>
<tr class="memitem:ad6284ca6b92364e1ebd02bbef81d7e7e inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad6284ca6b92364e1ebd02bbef81d7e7e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#ad6284ca6b92364e1ebd02bbef81d7e7e">SetParIsFixed</a> (const long parIndex, const bool fix)</td></tr>
<tr class="memdesc:ad6284ca6b92364e1ebd02bbef81d7e7e inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fix/un-fix one parameter from its #. <br/></td></tr>
<tr class="memitem:a8dc4cb100f839e12a9e0ae01facc5c9c inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8dc4cb100f839e12a9e0ae01facc5c9c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a8dc4cb100f839e12a9e0ae01facc5c9c">SetParIsFixed</a> (const string &amp;parName, const bool fix)</td></tr>
<tr class="memdesc:a8dc4cb100f839e12a9e0ae01facc5c9c inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fix/un-fix one parameter from its name. <br/></td></tr>
<tr class="memitem:acc7f25893d4dc4cec08fd04a84aa008d inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acc7f25893d4dc4cec08fd04a84aa008d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#acc7f25893d4dc4cec08fd04a84aa008d">SetParIsFixed</a> (const <a class="el" href="a00080.html">RefParType</a> *type, const bool fix)</td></tr>
<tr class="memdesc:acc7f25893d4dc4cec08fd04a84aa008d inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fix/un-fix one family of parameters. <br/></td></tr>
<tr class="memitem:a1d0737a4ecb7cb1339f3138cd792ba7c inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1d0737a4ecb7cb1339f3138cd792ba7c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a1d0737a4ecb7cb1339f3138cd792ba7c">SetParIsUsed</a> (const string &amp;parName, const bool use)</td></tr>
<tr class="memdesc:a1d0737a4ecb7cb1339f3138cd792ba7c inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set whether a parameter is used. <br/></td></tr>
<tr class="memitem:a40eba4b59117dd18831286e05b5b982c inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a40eba4b59117dd18831286e05b5b982c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a40eba4b59117dd18831286e05b5b982c">SetParIsUsed</a> (const <a class="el" href="a00080.html">RefParType</a> *type, const bool use)</td></tr>
<tr class="memdesc:a40eba4b59117dd18831286e05b5b982c inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set whether a family of parameters is used. <br/></td></tr>
<tr class="memitem:a945800fc9c72fb9a538e384a7831b37f inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a945800fc9c72fb9a538e384a7831b37f">GetNbPar</a> () const </td></tr>
<tr class="memdesc:a945800fc9c72fb9a538e384a7831b37f inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total number of refinable parameter in the object.  <a href="#a945800fc9c72fb9a538e384a7831b37f"></a><br/></td></tr>
<tr class="memitem:a6ead9da8785dbaa3dc4fb5f93cb455a3 inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6ead9da8785dbaa3dc4fb5f93cb455a3"></a>
long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a6ead9da8785dbaa3dc4fb5f93cb455a3">GetNbParNotFixed</a> () const </td></tr>
<tr class="memdesc:a6ead9da8785dbaa3dc4fb5f93cb455a3 inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total number of non-fixed parameters. Is initialized by <a class="el" href="a00071.html#a0e9b816ad753f633ef6d9650ec6b4ca6" title="Find which parameters are used and not fixed, for a refinement /optimization.">PrepareForRefinement()</a> <br/></td></tr>
<tr class="memitem:ae5c543d3b0fb010afa37b5f12620405b inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae5c543d3b0fb010afa37b5f12620405b"></a>
<a class="el" href="a00073.html">RefinablePar</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#ae5c543d3b0fb010afa37b5f12620405b">GetPar</a> (const long i)</td></tr>
<tr class="memdesc:ae5c543d3b0fb010afa37b5f12620405b inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access all parameters in the order they were inputted. <br/></td></tr>
<tr class="memitem:a5686cc39b27bc719be33aad0700438a1 inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5686cc39b27bc719be33aad0700438a1"></a>
const <a class="el" href="a00073.html">RefinablePar</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a5686cc39b27bc719be33aad0700438a1">GetPar</a> (const long i) const </td></tr>
<tr class="memdesc:a5686cc39b27bc719be33aad0700438a1 inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access all parameters in the order they were inputted. <br/></td></tr>
<tr class="memitem:aea1c3b652c3f1eb5444bd47456e04392 inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aea1c3b652c3f1eb5444bd47456e04392"></a>
<a class="el" href="a00073.html">RefinablePar</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#aea1c3b652c3f1eb5444bd47456e04392">GetPar</a> (const string &amp;name)</td></tr>
<tr class="memdesc:aea1c3b652c3f1eb5444bd47456e04392 inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access all parameters from their name. <br/></td></tr>
<tr class="memitem:a519b443c48cc463ed6b0682a6f557074 inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a519b443c48cc463ed6b0682a6f557074"></a>
const <a class="el" href="a00073.html">RefinablePar</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a519b443c48cc463ed6b0682a6f557074">GetPar</a> (const string &amp;name) const </td></tr>
<tr class="memdesc:a519b443c48cc463ed6b0682a6f557074 inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access all parameters from their name. <br/></td></tr>
<tr class="memitem:a07ea375ae64f69559e0b595e8c111087 inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a07ea375ae64f69559e0b595e8c111087"></a>
<a class="el" href="a00073.html">RefinablePar</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a07ea375ae64f69559e0b595e8c111087">GetPar</a> (const REAL *)</td></tr>
<tr class="memdesc:a07ea375ae64f69559e0b595e8c111087 inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access parameter from its adress. <br/></td></tr>
<tr class="memitem:a82b9eeedc157f76f17e9f9461c3a11d7 inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a82b9eeedc157f76f17e9f9461c3a11d7"></a>
const <a class="el" href="a00073.html">RefinablePar</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a82b9eeedc157f76f17e9f9461c3a11d7">GetPar</a> (const REAL *) const </td></tr>
<tr class="memdesc:a82b9eeedc157f76f17e9f9461c3a11d7 inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access parameter from its adress. <br/></td></tr>
<tr class="memitem:ac226ae69247c59e1d22b5be5010534c9 inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac226ae69247c59e1d22b5be5010534c9"></a>
long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#ac226ae69247c59e1d22b5be5010534c9">GetParIndex</a> (const string &amp;name, const bool nothrow=false) const </td></tr>
<tr class="memdesc:ac226ae69247c59e1d22b5be5010534c9 inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a parameter index (the order it was inputted) from its name. <br/></td></tr>
<tr class="memitem:a86afd7f55aafa42dd0a65a04c3eaf192 inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a86afd7f55aafa42dd0a65a04c3eaf192"></a>
long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a86afd7f55aafa42dd0a65a04c3eaf192">GetParIndex</a> (const REAL *, const bool nothrow=false) const </td></tr>
<tr class="memdesc:a86afd7f55aafa42dd0a65a04c3eaf192 inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a parameter index (the order it was inputted) from its adress. <br/></td></tr>
<tr class="memitem:ae06ade6e11e2de4d041d07612a7d802c inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00073.html">RefinablePar</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#ae06ade6e11e2de4d041d07612a7d802c">GetParNotFixed</a> (const long i)</td></tr>
<tr class="memdesc:ae06ade6e11e2de4d041d07612a7d802c inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access all parameters in the order they were inputted, skipping fixed parameters.  <a href="#ae06ade6e11e2de4d041d07612a7d802c"></a><br/></td></tr>
<tr class="memitem:a91112351e072c2448c4af8be3ad2da12 inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00073.html">RefinablePar</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a91112351e072c2448c4af8be3ad2da12">GetParNotFixed</a> (const long i) const </td></tr>
<tr class="memdesc:a91112351e072c2448c4af8be3ad2da12 inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access all parameters in the order they were inputed, skipping fixed parameters.  <a href="#a91112351e072c2448c4af8be3ad2da12"></a><br/></td></tr>
<tr class="memitem:a0c0050a3d3141ca34eb8f4b559ad2f8d inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a0c0050a3d3141ca34eb8f4b559ad2f8d">AddPar</a> (const <a class="el" href="a00073.html">RefinablePar</a> &amp;newRefPar)</td></tr>
<tr class="memdesc:a0c0050a3d3141ca34eb8f4b559ad2f8d inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a refinable parameter.  <a href="#a0c0050a3d3141ca34eb8f4b559ad2f8d"></a><br/></td></tr>
<tr class="memitem:a4a792c84f7d35e71b3e89aae5a87bffa inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a4a792c84f7d35e71b3e89aae5a87bffa">AddPar</a> (<a class="el" href="a00073.html">RefinablePar</a> *newRefPar)</td></tr>
<tr class="memdesc:a4a792c84f7d35e71b3e89aae5a87bffa inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a refinable parameter.  <a href="#a4a792c84f7d35e71b3e89aae5a87bffa"></a><br/></td></tr>
<tr class="memitem:a6a28259e473fadd53fbc9b9bf7930813 inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a6a28259e473fadd53fbc9b9bf7930813">AddPar</a> (<a class="el" href="a00071.html">RefinableObj</a> &amp;newRefParList, const bool copyParam=false)</td></tr>
<tr class="memdesc:a6a28259e473fadd53fbc9b9bf7930813 inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add all the parameters in another <a class="el" href="a00071.html" title="Generic Refinable Object.">RefinableObj</a>.  <a href="#a6a28259e473fadd53fbc9b9bf7930813"></a><br/></td></tr>
<tr class="memitem:a33a10888dfa13b40a5989d6b9af52174 inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="a00073.html">RefinablePar</a> * &gt;::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a33a10888dfa13b40a5989d6b9af52174">RemovePar</a> (<a class="el" href="a00073.html">RefinablePar</a> *refPar)</td></tr>
<tr class="memdesc:a33a10888dfa13b40a5989d6b9af52174 inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a refinable parameter.  <a href="#a33a10888dfa13b40a5989d6b9af52174"></a><br/></td></tr>
<tr class="memitem:a6033a7d7892806d9157daad9c4aea8c3 inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6033a7d7892806d9157daad9c4aea8c3"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>Print</b> () const </td></tr>
<tr class="memitem:abd5b0aa78ff6ec95838e78e2d3685b56 inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#abd5b0aa78ff6ec95838e78e2d3685b56">CreateParamSet</a> (const string name=&quot;&quot;) const </td></tr>
<tr class="memdesc:abd5b0aa78ff6ec95838e78e2d3685b56 inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save the current set of refined values in a new set.  <a href="#abd5b0aa78ff6ec95838e78e2d3685b56"></a><br/></td></tr>
<tr class="memitem:ae9a2401becfcd7dda785c0931d3f31f3 inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae9a2401becfcd7dda785c0931d3f31f3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#ae9a2401becfcd7dda785c0931d3f31f3">ClearParamSet</a> (const unsigned long id) const </td></tr>
<tr class="memdesc:ae9a2401becfcd7dda785c0931d3f31f3 inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase the param set with the given id, releasing memory. <br/></td></tr>
<tr class="memitem:afdcabf808440aa0d566e56f145de235d inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#afdcabf808440aa0d566e56f145de235d">SaveParamSet</a> (const unsigned long id) const </td></tr>
<tr class="memdesc:afdcabf808440aa0d566e56f145de235d inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight"><pre class="fragment">Save the current set of refined values over a previously-created set
</pre><p> *of saved values.  <a href="#afdcabf808440aa0d566e56f145de235d"></a><br/></td></tr>
<tr class="memitem:a057437fe6759b589906d8a16f9732e22 inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a057437fe6759b589906d8a16f9732e22">RestoreParamSet</a> (const unsigned long id)</td></tr>
<tr class="memdesc:a057437fe6759b589906d8a16f9732e22 inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore a saved set of values.  <a href="#a057437fe6759b589906d8a16f9732e22"></a><br/></td></tr>
<tr class="memitem:aa5ebd29814d5ed1a18a669ea0f3417f3 inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top">const CrystVector_REAL &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#aa5ebd29814d5ed1a18a669ea0f3417f3">GetParamSet</a> (const unsigned long setId) const </td></tr>
<tr class="memdesc:aa5ebd29814d5ed1a18a669ea0f3417f3 inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access one save refpar set.  <a href="#aa5ebd29814d5ed1a18a669ea0f3417f3"></a><br/></td></tr>
<tr class="memitem:a33290cd0d3d90620cb7465dacb675085 inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top">CrystVector_REAL &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a33290cd0d3d90620cb7465dacb675085">GetParamSet</a> (const unsigned long setId)</td></tr>
<tr class="memdesc:a33290cd0d3d90620cb7465dacb675085 inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access one save refpar set.  <a href="#a33290cd0d3d90620cb7465dacb675085"></a><br/></td></tr>
<tr class="memitem:ab17775f3f007ae6edd2de6fd2433c6ce inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top">REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#ab17775f3f007ae6edd2de6fd2433c6ce">GetParamSet_ParNotFixedHumanValue</a> (const unsigned long setId, const long parNumber) const </td></tr>
<tr class="memdesc:ab17775f3f007ae6edd2de6fd2433c6ce inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the (human) value of one refined parameter in a saved set of parameters.  <a href="#ab17775f3f007ae6edd2de6fd2433c6ce"></a><br/></td></tr>
<tr class="memitem:ac269ad4ad4ca8b4e9f13f5466475d959 inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top">const void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#ac269ad4ad4ca8b4e9f13f5466475d959">EraseAllParamSet</a> ()</td></tr>
<tr class="memdesc:ac269ad4ad4ca8b4e9f13f5466475d959 inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase all saved refpar sets.  <a href="#ac269ad4ad4ca8b4e9f13f5466475d959"></a><br/></td></tr>
<tr class="memitem:a1426f90c9b580a4854917ab7db876c3e inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top">const string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a1426f90c9b580a4854917ab7db876c3e">GetParamSetName</a> (const unsigned long setId) const </td></tr>
<tr class="memdesc:a1426f90c9b580a4854917ab7db876c3e inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name associated to a refpar set.  <a href="#a1426f90c9b580a4854917ab7db876c3e"></a><br/></td></tr>
<tr class="memitem:a2f24a7b834f5588e32aac9c6e33a1020 inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2f24a7b834f5588e32aac9c6e33a1020"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a2f24a7b834f5588e32aac9c6e33a1020">SetLimitsAbsolute</a> (const string &amp;parName, const REAL min, const REAL max)</td></tr>
<tr class="memdesc:a2f24a7b834f5588e32aac9c6e33a1020 inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the limits for a given parameter, giving absolute new limits. <br/></td></tr>
<tr class="memitem:a371f137ad14a77ee3b545520d05fe4d6 inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a371f137ad14a77ee3b545520d05fe4d6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a371f137ad14a77ee3b545520d05fe4d6">SetLimitsAbsolute</a> (const <a class="el" href="a00080.html">RefParType</a> *type, const REAL min, const REAL max)</td></tr>
<tr class="memdesc:a371f137ad14a77ee3b545520d05fe4d6 inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the limits for a category of parameters, giving absolute new limits. <br/></td></tr>
<tr class="memitem:acacf469614253239fdeebb21e50f0c1c inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#acacf469614253239fdeebb21e50f0c1c">SetLimitsRelative</a> (const string &amp;parName, const REAL min, const REAL max)</td></tr>
<tr class="memdesc:acacf469614253239fdeebb21e50f0c1c inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the limits for a given parameter, giving relative new limits (eg giving -.1 and +.1 will set new limits at the current value + min and current value + max) Thus min should logically be &lt;0 and max &gt;0.  <a href="#acacf469614253239fdeebb21e50f0c1c"></a><br/></td></tr>
<tr class="memitem:ae8d497fc43ac3f166a21781a62dfa25d inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#ae8d497fc43ac3f166a21781a62dfa25d">SetLimitsRelative</a> (const <a class="el" href="a00080.html">RefParType</a> *type, const REAL min, const REAL max)</td></tr>
<tr class="memdesc:ae8d497fc43ac3f166a21781a62dfa25d inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the limits for a category of parameters, giving relative new limits (eg giving -.1 and +.1 will set new limits at the current value + min and current value + max).  <a href="#ae8d497fc43ac3f166a21781a62dfa25d"></a><br/></td></tr>
<tr class="memitem:adc6b05a95d524d600910a47861190e84 inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#adc6b05a95d524d600910a47861190e84">SetLimitsProportional</a> (const string &amp;parName, const REAL min, const REAL max)</td></tr>
<tr class="memdesc:adc6b05a95d524d600910a47861190e84 inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the limits for a given parameter, proportionnaly to the current value.  <a href="#adc6b05a95d524d600910a47861190e84"></a><br/></td></tr>
<tr class="memitem:a75741a3e7f7f1740243901b60f406e93 inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a75741a3e7f7f1740243901b60f406e93">SetLimitsProportional</a> (const <a class="el" href="a00080.html">RefParType</a> *type, const REAL min, const REAL max)</td></tr>
<tr class="memdesc:a75741a3e7f7f1740243901b60f406e93 inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the limits for a category of parameters, proportionnaly to their current value.  <a href="#a75741a3e7f7f1740243901b60f406e93"></a><br/></td></tr>
<tr class="memitem:ae4f0b5b0038ff3b49dcdc8adbf98bc58 inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae4f0b5b0038ff3b49dcdc8adbf98bc58"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#ae4f0b5b0038ff3b49dcdc8adbf98bc58">SetGlobalOptimStep</a> (const <a class="el" href="a00080.html">RefParType</a> *type, const REAL step)</td></tr>
<tr class="memdesc:ae4f0b5b0038ff3b49dcdc8adbf98bc58 inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the maximum step to use during Global Optimization algorithms. <br/></td></tr>
<tr class="memitem:a30e81164b0176ca00e90d994ca0a0827 inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a30e81164b0176ca00e90d994ca0a0827"></a>
<a class="el" href="a00054.html">ObjRegistry</a>&lt; <a class="el" href="a00071.html">RefinableObj</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a30e81164b0176ca00e90d994ca0a0827">GetSubObjRegistry</a> ()</td></tr>
<tr class="memdesc:a30e81164b0176ca00e90d994ca0a0827 inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to the registry of <a class="el" href="a00071.html" title="Generic Refinable Object.">RefinableObj</a> used by this object. <br/></td></tr>
<tr class="memitem:a23999d5fb06661cddc9bfa294c48624e inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a23999d5fb06661cddc9bfa294c48624e"></a>
const <a class="el" href="a00054.html">ObjRegistry</a>&lt; <a class="el" href="a00071.html">RefinableObj</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a23999d5fb06661cddc9bfa294c48624e">GetSubObjRegistry</a> () const </td></tr>
<tr class="memdesc:a23999d5fb06661cddc9bfa294c48624e inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to the registry of <a class="el" href="a00071.html" title="Generic Refinable Object.">RefinableObj</a> used by this object. <br/></td></tr>
<tr class="memitem:a8afc65925b0e4d1894d72c457ad38bc9 inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a8afc65925b0e4d1894d72c457ad38bc9">RegisterClient</a> (<a class="el" href="a00071.html">RefinableObj</a> &amp;) const </td></tr>
<tr class="memdesc:a8afc65925b0e4d1894d72c457ad38bc9 inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a new object using this object.  <a href="#a8afc65925b0e4d1894d72c457ad38bc9"></a><br/></td></tr>
<tr class="memitem:ae37091ca0b7091eaf87bf630433ad91d inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae37091ca0b7091eaf87bf630433ad91d"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#ae37091ca0b7091eaf87bf630433ad91d">DeRegisterClient</a> (<a class="el" href="a00071.html">RefinableObj</a> &amp;) const </td></tr>
<tr class="memdesc:ae37091ca0b7091eaf87bf630433ad91d inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deregister an object (which not any more) using this object. <br/></td></tr>
<tr class="memitem:abb63797f2ffc7e8317f66ce9749f105f inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abb63797f2ffc7e8317f66ce9749f105f"></a>
virtual const <a class="el" href="a00054.html">ObjRegistry</a><br class="typebreak"/>
&lt; <a class="el" href="a00071.html">RefinableObj</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#abb63797f2ffc7e8317f66ce9749f105f">GetClientRegistry</a> () const </td></tr>
<tr class="memdesc:abb63797f2ffc7e8317f66ce9749f105f inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the list of clients. <br/></td></tr>
<tr class="memitem:aaf7fdd5c8d015285639fe24138e31b6b inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaf7fdd5c8d015285639fe24138e31b6b"></a>
virtual <a class="el" href="a00054.html">ObjRegistry</a><br class="typebreak"/>
&lt; <a class="el" href="a00071.html">RefinableObj</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#aaf7fdd5c8d015285639fe24138e31b6b">GetClientRegistry</a> ()</td></tr>
<tr class="memdesc:aaf7fdd5c8d015285639fe24138e31b6b inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the list of clients. <br/></td></tr>
<tr class="memitem:addbd91121eaf715f67080d95cfdc857c inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="addbd91121eaf715f67080d95cfdc857c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#addbd91121eaf715f67080d95cfdc857c">IsBeingRefined</a> () const </td></tr>
<tr class="memdesc:addbd91121eaf715f67080d95cfdc857c inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the object being refined ? (Can be refined by one algorithm at a time only.) <br/></td></tr>
<tr class="memitem:ab0035f6164cb24ace67b51b11993a851 inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#ab0035f6164cb24ace67b51b11993a851">EndOptimization</a> ()</td></tr>
<tr class="memdesc:ab0035f6164cb24ace67b51b11993a851 inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">This should be called by any optimization class at the end of an optimization.  <a href="#ab0035f6164cb24ace67b51b11993a851"></a><br/></td></tr>
<tr class="memitem:a565c41c23c04f5945512374ae671e2e3 inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a565c41c23c04f5945512374ae671e2e3">SetApproximationFlag</a> (const bool allow)</td></tr>
<tr class="memdesc:a565c41c23c04f5945512374ae671e2e3 inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable numerical approximations.  <a href="#a565c41c23c04f5945512374ae671e2e3"></a><br/></td></tr>
<tr class="memitem:a01b02e566db9aebfd0f9ed2647441f40 inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a01b02e566db9aebfd0f9ed2647441f40">RandomizeConfiguration</a> ()</td></tr>
<tr class="memdesc:a01b02e566db9aebfd0f9ed2647441f40 inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Randomize Configuration (before a global optimization).  <a href="#a01b02e566db9aebfd0f9ed2647441f40"></a><br/></td></tr>
<tr class="memitem:a47fc5a85493671a3590ed7e3971b18fe inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a47fc5a85493671a3590ed7e3971b18fe">BeginGlobalOptRandomMove</a> ()</td></tr>
<tr class="memdesc:a47fc5a85493671a3590ed7e3971b18fe inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raise a flag, to be sure not to make a random change more than once in each <a class="el" href="a00071.html" title="Generic Refinable Object.">RefinableObj</a>.  <a href="#a47fc5a85493671a3590ed7e3971b18fe"></a><br/></td></tr>
<tr class="memitem:a24bfb12849c7733a7034928fbb0b14a8 inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top">virtual const CrystVector_REAL &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a24bfb12849c7733a7034928fbb0b14a8">GetLSQDeriv</a> (const unsigned int, <a class="el" href="a00073.html">RefinablePar</a> &amp;)</td></tr>
<tr class="memdesc:a24bfb12849c7733a7034928fbb0b14a8 inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the first derivative values for the LSQ function, for a given parameter.  <a href="#a24bfb12849c7733a7034928fbb0b14a8"></a><br/></td></tr>
<tr class="memitem:a3b6228c6fbd154441d935af2d511fe82 inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a3b6228c6fbd154441d935af2d511fe82">ResetParList</a> ()</td></tr>
<tr class="memdesc:a3b6228c6fbd154441d935af2d511fe82 inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Re-init the list of refinable parameters, removing all parameters.  <a href="#a3b6228c6fbd154441d935af2d511fe82"></a><br/></td></tr>
<tr class="memitem:ab74e2cead734fe1e652c5add46c5e116 inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#ab74e2cead734fe1e652c5add46c5e116">UpdateDisplay</a> () const </td></tr>
<tr class="memdesc:ab74e2cead734fe1e652c5add46c5e116 inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">If there is an interface, this should be automatically be called each time there is a 'new, significant' configuration to report.  <a href="#ab74e2cead734fe1e652c5add46c5e116"></a><br/></td></tr>
<tr class="memitem:a389c9d9ed7e8c700abfa4dfb72a32792 inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a389c9d9ed7e8c700abfa4dfb72a32792"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a389c9d9ed7e8c700abfa4dfb72a32792">GetNbOption</a> () const </td></tr>
<tr class="memdesc:a389c9d9ed7e8c700abfa4dfb72a32792 inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of Options for this object. <br/></td></tr>
<tr class="memitem:a2dcb69d78e55dc75a7377e5a772536de inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2dcb69d78e55dc75a7377e5a772536de"></a>
<a class="el" href="a00078.html">RefObjOpt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a2dcb69d78e55dc75a7377e5a772536de">GetOption</a> (const unsigned int i)</td></tr>
<tr class="memdesc:a2dcb69d78e55dc75a7377e5a772536de inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to the options. <br/></td></tr>
<tr class="memitem:a77b66fd9c4e752e9b58ecd9e5ec2a218 inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a77b66fd9c4e752e9b58ecd9e5ec2a218"></a>
const <a class="el" href="a00078.html">RefObjOpt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a77b66fd9c4e752e9b58ecd9e5ec2a218">GetOption</a> (const unsigned int i) const </td></tr>
<tr class="memdesc:a77b66fd9c4e752e9b58ecd9e5ec2a218 inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">const access to the options <br/></td></tr>
<tr class="memitem:a33f94e9c9c0717ea77c8b9427e9e137e inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a33f94e9c9c0717ea77c8b9427e9e137e">SetDeleteRefParInDestructor</a> (const bool b)</td></tr>
<tr class="memdesc:a33f94e9c9c0717ea77c8b9427e9e137e inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set this object not to delete its list of parameters when destroyed.  <a href="#a33f94e9c9c0717ea77c8b9427e9e137e"></a><br/></td></tr>
<tr class="memitem:a52422a72840cdb07ac5274eced2d2152 inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00072.html">RefinableObjClock</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a52422a72840cdb07ac5274eced2d2152">GetRefParListClock</a> () const </td></tr>
<tr class="memdesc:a52422a72840cdb07ac5274eced2d2152 inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">What was the last time a <a class="el" href="a00073.html" title="Generic class for parameters of refinable objects.">RefinablePar</a> was added/removed ?  <a href="#a52422a72840cdb07ac5274eced2d2152"></a><br/></td></tr>
<tr class="memitem:a92288a2ec22c405bbb9985bdc1a0b633 inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top">virtual REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a92288a2ec22c405bbb9985bdc1a0b633">GetRestraintCost</a> () const </td></tr>
<tr class="memdesc:a92288a2ec22c405bbb9985bdc1a0b633 inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the restraint cost (overall penalty of all restraints)  <a href="#a92288a2ec22c405bbb9985bdc1a0b633"></a><br/></td></tr>
<tr class="memitem:a0eec1ccf5ba9769e5c6a82a85ecf451d inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a0eec1ccf5ba9769e5c6a82a85ecf451d">AddRestraint</a> (<a class="el" href="a00081.html">Restraint</a> *pNewRestraint)</td></tr>
<tr class="memdesc:a0eec1ccf5ba9769e5c6a82a85ecf451d inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new restraint.  <a href="#a0eec1ccf5ba9769e5c6a82a85ecf451d"></a><br/></td></tr>
<tr class="memitem:a0e738f16d06bed8a50985a97deb48e7d inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="a00081.html">Restraint</a> * &gt;::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a0e738f16d06bed8a50985a97deb48e7d">RemoveRestraint</a> (<a class="el" href="a00081.html">Restraint</a> *pRestraint)</td></tr>
<tr class="memdesc:a0e738f16d06bed8a50985a97deb48e7d inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a restraint from the list of known restraints.  <a href="#a0e738f16d06bed8a50985a97deb48e7d"></a><br/></td></tr>
<tr class="memitem:a3cb4cc924d39576618184eccd4321cf6 inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a3cb4cc924d39576618184eccd4321cf6">TagNewBestConfig</a> () const </td></tr>
<tr class="memdesc:a3cb4cc924d39576618184eccd4321cf6 inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">During a global optimization, tells the object that the current config is the latest "best" config.  <a href="#a3cb4cc924d39576618184eccd4321cf6"></a><br/></td></tr>
<tr class="memitem:a5910fb213a6b51da18d5f65badceb029 inherit pub_methods_a00071"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5910fb213a6b51da18d5f65badceb029"></a>
const <a class="el" href="a00072.html">RefinableObjClock</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a5910fb213a6b51da18d5f65badceb029">GetClockMaster</a> () const </td></tr>
<tr class="memdesc:a5910fb213a6b51da18d5f65badceb029 inherit pub_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">This clocks records <em>any</em> change in the object. See refinableObj::mClockMaster. <br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:aeec384d7b4c64208705e335b1d777078"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeec384d7b4c64208705e335b1d777078"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#aeec384d7b4c64208705e335b1d777078">CalcPowderPattern</a> () const </td></tr>
<tr class="memdesc:aeec384d7b4c64208705e335b1d777078"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calc the powder pattern. <br/></td></tr>
<tr class="memitem:a4e83fb08b877615a285203e7b64d11f5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4e83fb08b877615a285203e7b64d11f5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#a4e83fb08b877615a285203e7b64d11f5">CalcPowderPatternIntegrated</a> () const </td></tr>
<tr class="memdesc:a4e83fb08b877615a285203e7b64d11f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calc the integrated powder pattern. <br/></td></tr>
<tr class="memitem:af621257d23b5f61b692005b4cbf16548"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af621257d23b5f61b692005b4cbf16548"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#af621257d23b5f61b692005b4cbf16548">Init</a> ()</td></tr>
<tr class="memdesc:af621257d23b5f61b692005b4cbf16548"><td class="mdescLeft">&#160;</td><td class="mdescRight">Init parameters and options. <br/></td></tr>
<tr class="memitem:aaadcc6843ef4cbb5ea93adb376adca3b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaadcc6843ef4cbb5ea93adb376adca3b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#aaadcc6843ef4cbb5ea93adb376adca3b">PrepareIntegratedRfactor</a> () const </td></tr>
<tr class="memdesc:aaadcc6843ef4cbb5ea93adb376adca3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare the calculation of the integrated R-factors. <br/></td></tr>
<tr class="memitem:ae0bab5e34ba3f4e3c31314950406a183"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae0bab5e34ba3f4e3c31314950406a183"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#ae0bab5e34ba3f4e3c31314950406a183">CalcNbPointUsed</a> () const </td></tr>
<tr class="memdesc:ae0bab5e34ba3f4e3c31314950406a183"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the number of points of the pattern actually used, from the maximum value of sin(theta)/lambda. <br/></td></tr>
<tr class="memitem:a58e00018fd044e5175518600bb6086f4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a58e00018fd044e5175518600bb6086f4"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#a58e00018fd044e5175518600bb6086f4">InitOptions</a> ()</td></tr>
<tr class="memdesc:a58e00018fd044e5175518600bb6086f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize options. <br/></td></tr>
<tr class="memitem:aff2984de220b14affbc74582bb0ee76b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aff2984de220b14affbc74582bb0ee76b"></a>
Number of points actually due <br class="typebreak"/>
to the maximum value of&#160;</td><td class="memItemRight" valign="bottom"><b>sin</b> (theta)/lambda.mutable unsigned long mNbPointUsed</td></tr>
<tr class="memitem:ab4a812e1e87df37d43f46e9d6aa35573"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab4a812e1e87df37d43f46e9d6aa35573"></a>
Number of integration <br class="typebreak"/>
intervals actually due to the <br class="typebreak"/>
maximum value of&#160;</td><td class="memItemRight" valign="bottom"><b>sin</b> (theta)/lambda.mutable unsigned long mNbIntegrationUsed</td></tr>
<tr class="memitem:a927ace4cea0826ffbba8145adca07998"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a927ace4cea0826ffbba8145adca07998"></a>
Clock recording the last time <br class="typebreak"/>
the number of points&#160;</td><td class="memItemRight" valign="bottom"><b>used</b> (PowderPattern::mNbPointUsed) was changed.mutable <a class="el" href="a00072.html">RefinableObjClock</a> mClockNbPointUsed</td></tr>
<tr class="inherit_header pro_methods_a00071"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_a00071')"><img src="closed.png" alt="-"/>&nbsp;Protected Member Functions inherited from <a class="el" href="a00071.html">ObjCryst::RefinableObj</a></td></tr>
<tr class="memitem:a6c1fd4ec11915278a6a9db9bf3aa1374 inherit pro_methods_a00071"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6c1fd4ec11915278a6a9db9bf3aa1374"></a>
long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a6c1fd4ec11915278a6a9db9bf3aa1374">FindPar</a> (const string &amp;name) const </td></tr>
<tr class="memdesc:a6c1fd4ec11915278a6a9db9bf3aa1374 inherit pro_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a refinable parameter with a given name. <br/></td></tr>
<tr class="memitem:a96acb0979c364332bc5365a73b58a246 inherit pro_methods_a00071"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a96acb0979c364332bc5365a73b58a246"></a>
long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a96acb0979c364332bc5365a73b58a246">FindPar</a> (const REAL *) const </td></tr>
<tr class="memdesc:a96acb0979c364332bc5365a73b58a246 inherit pro_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a refinable parameter from the adress of its value. <br/></td></tr>
<tr class="memitem:ae4740b33ea934e4ab9b9bce9ebbfa806 inherit pro_methods_a00071"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#ae4740b33ea934e4ab9b9bce9ebbfa806">AddSubRefObj</a> (<a class="el" href="a00071.html">RefinableObj</a> &amp;)</td></tr>
<tr class="memitem:af533cb95da45c5ce875c9f5ec8cf9c1e inherit pro_methods_a00071"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#af533cb95da45c5ce875c9f5ec8cf9c1e">RemoveSubRefObj</a> (<a class="el" href="a00071.html">RefinableObj</a> &amp;)</td></tr>
<tr class="memitem:a8bd8353b34fc4088a987be0eaf01e5f6 inherit pro_methods_a00071"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a8bd8353b34fc4088a987be0eaf01e5f6">AddOption</a> (<a class="el" href="a00078.html">RefObjOpt</a> *opt)</td></tr>
<tr class="memitem:a5db8d488c4782f2e143fbb6ec96e0b32 inherit pro_methods_a00071"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5db8d488c4782f2e143fbb6ec96e0b32"></a>
map&lt; unsigned long, pair<br class="typebreak"/>
&lt; CrystVector_REAL, string &gt;<br class="typebreak"/>
 &gt;::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a5db8d488c4782f2e143fbb6ec96e0b32">FindParamSet</a> (unsigned long id) const </td></tr>
<tr class="memdesc:a5db8d488c4782f2e143fbb6ec96e0b32 inherit pro_methods_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a parameter set with a given id (and check if it is there) <br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a039c845ac70b5118f5090077a5ef7f70"><td class="memItemLeft" align="right" valign="top">CrystVector_REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#a039c845ac70b5118f5090077a5ef7f70">mPowderPatternCalc</a></td></tr>
<tr class="memdesc:a039c845ac70b5118f5090077a5ef7f70"><td class="mdescLeft">&#160;</td><td class="mdescRight">The calculated powder pattern.  <a href="#a039c845ac70b5118f5090077a5ef7f70"></a><br/></td></tr>
<tr class="memitem:abf4b59b588e54dd6504722a4e8700c43"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abf4b59b588e54dd6504722a4e8700c43"></a>
CrystVector_REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#abf4b59b588e54dd6504722a4e8700c43">mPowderPatternIntegratedCalc</a></td></tr>
<tr class="memdesc:abf4b59b588e54dd6504722a4e8700c43"><td class="mdescLeft">&#160;</td><td class="mdescRight">The calculated powder pattern, integrated. <br/></td></tr>
<tr class="memitem:aa38c508b5516a2b4e357b7116e0b11da"><td class="memItemLeft" align="right" valign="top">CrystVector_REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#aa38c508b5516a2b4e357b7116e0b11da">mPowderPatternBackgroundCalc</a></td></tr>
<tr class="memdesc:aa38c508b5516a2b4e357b7116e0b11da"><td class="mdescLeft">&#160;</td><td class="mdescRight">The calculated powder pattern part which corresponds to 'background' (eg non-scalable components).  <a href="#aa38c508b5516a2b4e357b7116e0b11da"></a><br/></td></tr>
<tr class="memitem:a18da34aac86b27d5511268113b5f9260"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a18da34aac86b27d5511268113b5f9260"></a>
CrystVector_REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#a18da34aac86b27d5511268113b5f9260">mPowderPatternBackgroundIntegratedCalc</a></td></tr>
<tr class="memdesc:a18da34aac86b27d5511268113b5f9260"><td class="mdescLeft">&#160;</td><td class="mdescRight">The calculated powder pattern part which corresponds to 'background' (eg non-scalable components), integrated. <br/></td></tr>
<tr class="memitem:aa7de3fc187edf28b3688569866b00700"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa7de3fc187edf28b3688569866b00700"></a>
CrystVector_REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#aa7de3fc187edf28b3688569866b00700">mPowderPatternObs</a></td></tr>
<tr class="memdesc:aa7de3fc187edf28b3688569866b00700"><td class="mdescLeft">&#160;</td><td class="mdescRight">The observed powder pattern. <br/></td></tr>
<tr class="memitem:ab0468caae908a520555da3b104714129"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab0468caae908a520555da3b104714129"></a>
CrystVector_REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#ab0468caae908a520555da3b104714129">mPowderPatternObsSigma</a></td></tr>
<tr class="memdesc:ab0468caae908a520555da3b104714129"><td class="mdescLeft">&#160;</td><td class="mdescRight">The sigma of the observed pattern. <br/></td></tr>
<tr class="memitem:a65da6b3a338951905cf52aa4b22f9324"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a65da6b3a338951905cf52aa4b22f9324"></a>
CrystVector_REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#a65da6b3a338951905cf52aa4b22f9324">mPowderPatternWeight</a></td></tr>
<tr class="memdesc:a65da6b3a338951905cf52aa4b22f9324"><td class="mdescLeft">&#160;</td><td class="mdescRight">The weight for each point of the pattern. <br/></td></tr>
<tr class="memitem:ac962c591539d06c65ce32e56580029c2"><td class="memItemLeft" align="right" valign="top">CrystVector_REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#ac962c591539d06c65ce32e56580029c2">mPowderPatternVariance</a></td></tr>
<tr class="memdesc:ac962c591539d06c65ce32e56580029c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The complete variance associated to each point of the powder pattern, taking into account observation and model errors.  <a href="#ac962c591539d06c65ce32e56580029c2"></a><br/></td></tr>
<tr class="memitem:a7c7192cf095beca2d515a15f4c57d227"><td class="memItemLeft" align="right" valign="top">CrystVector_REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#a7c7192cf095beca2d515a15f4c57d227">mPowderPatternVarianceIntegrated</a></td></tr>
<tr class="memdesc:a7c7192cf095beca2d515a15f4c57d227"><td class="mdescLeft">&#160;</td><td class="mdescRight">The complete variance associated to each point of the powder pattern, taking into account observation and model errors.  <a href="#a7c7192cf095beca2d515a15f4c57d227"></a><br/></td></tr>
<tr class="memitem:a0ed58eb5c5c33166838c1d57aa26ddae"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0ed58eb5c5c33166838c1d57aa26ddae"></a>
CrystVector_REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#a0ed58eb5c5c33166838c1d57aa26ddae">mChi2Cumul</a></td></tr>
<tr class="memdesc:a0ed58eb5c5c33166838c1d57aa26ddae"><td class="mdescLeft">&#160;</td><td class="mdescRight">The cumulative Chi^2 (integrated or not, depending on the option) <br/></td></tr>
<tr class="memitem:a4857b149efae6be6014648718d1cf62c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4857b149efae6be6014648718d1cf62c"></a>
CrystVector_REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#a4857b149efae6be6014648718d1cf62c">mPowderPatternUsedCalc</a></td></tr>
<tr class="memdesc:a4857b149efae6be6014648718d1cf62c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The calculated powder pattern. Cropped to the maximum sin(theta)/lambda for LSQ. <br/></td></tr>
<tr class="memitem:a5390f7b642a104f692b459ad50de14e1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5390f7b642a104f692b459ad50de14e1"></a>
CrystVector_REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#a5390f7b642a104f692b459ad50de14e1">mPowderPatternUsedObs</a></td></tr>
<tr class="memdesc:a5390f7b642a104f692b459ad50de14e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The calculated powder pattern. Cropped to the maximum sin(theta)/lambda for LSQ. <br/></td></tr>
<tr class="memitem:ab1afb9ea500e8ba4d91178033ad7d18c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab1afb9ea500e8ba4d91178033ad7d18c"></a>
CrystVector_REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#ab1afb9ea500e8ba4d91178033ad7d18c">mPowderPatternUsedWeight</a></td></tr>
<tr class="memdesc:ab1afb9ea500e8ba4d91178033ad7d18c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The weight for each point of the pattern. Cropped to the maximum sin(theta)/lambda for LSQ. <br/></td></tr>
<tr class="memitem:ac71a81d157387c2bdb7791cfa6d18e64"><td class="memItemLeft" align="right" valign="top">CrystVector_REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#ac71a81d157387c2bdb7791cfa6d18e64">mX</a></td></tr>
<tr class="memdesc:ac71a81d157387c2bdb7791cfa6d18e64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of x coordinates (either 2theta or time-of-flight) for the pattern.  <a href="#ac71a81d157387c2bdb7791cfa6d18e64"></a><br/></td></tr>
<tr class="memitem:ae28448d544d8d581ec9ee1ff357790b0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae28448d544d8d581ec9ee1ff357790b0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#ae28448d544d8d581ec9ee1ff357790b0">mIsXAscending</a></td></tr>
<tr class="memdesc:ae28448d544d8d581ec9ee1ff357790b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the mX vector sorted in ascending order ? (true for 2theta, false for TOF) <br/></td></tr>
<tr class="memitem:a19b60b359851708470a639767f98931e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a19b60b359851708470a639767f98931e"></a>
unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#a19b60b359851708470a639767f98931e">mNbPoint</a></td></tr>
<tr class="memdesc:a19b60b359851708470a639767f98931e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of points in the pattern. <br/></td></tr>
<tr class="memitem:a05765f5848b8f408c98061501d576da1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a05765f5848b8f408c98061501d576da1"></a>
<a class="el" href="a00069.html">Radiation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#a05765f5848b8f408c98061501d576da1">mRadiation</a></td></tr>
<tr class="memdesc:a05765f5848b8f408c98061501d576da1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="a00069.html" title="Class to define the radiation (type, monochromaticity, wavelength(s)) of an experiment.">Radiation</a> corresponding to this experiment. <br/></td></tr>
<tr class="memitem:ae346e0d2354a37cbaad34c2d053f52be"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae346e0d2354a37cbaad34c2d053f52be"></a>
<a class="el" href="a00072.html">RefinableObjClock</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#ae346e0d2354a37cbaad34c2d053f52be">mClockPowderPatternPar</a></td></tr>
<tr class="memdesc:ae346e0d2354a37cbaad34c2d053f52be"><td class="mdescLeft">&#160;</td><td class="mdescRight">When were the pattern parameters (2theta or time-of-flight range) changed ? <br/></td></tr>
<tr class="memitem:afb844ef286aa8109960c1de1fa7f1972"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afb844ef286aa8109960c1de1fa7f1972"></a>
<a class="el" href="a00072.html">RefinableObjClock</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#afb844ef286aa8109960c1de1fa7f1972">mClockPowderPatternRadiation</a></td></tr>
<tr class="memdesc:afb844ef286aa8109960c1de1fa7f1972"><td class="mdescLeft">&#160;</td><td class="mdescRight">When were the radiation parameter (radiation type, wavelength) changed ? <br/></td></tr>
<tr class="memitem:aafa1a93644c2c7b5e30dcf6c2d0c7b94"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aafa1a93644c2c7b5e30dcf6c2d0c7b94"></a>
<a class="el" href="a00072.html">RefinableObjClock</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#aafa1a93644c2c7b5e30dcf6c2d0c7b94">mClockPowderPatternCalc</a></td></tr>
<tr class="memdesc:aafa1a93644c2c7b5e30dcf6c2d0c7b94"><td class="mdescLeft">&#160;</td><td class="mdescRight">When was the powder pattern last computed ? <br/></td></tr>
<tr class="memitem:a8eae5432b9c084a5416ecc46330faaf7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8eae5432b9c084a5416ecc46330faaf7"></a>
<a class="el" href="a00072.html">RefinableObjClock</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#a8eae5432b9c084a5416ecc46330faaf7">mClockPowderPatternIntegratedCalc</a></td></tr>
<tr class="memdesc:a8eae5432b9c084a5416ecc46330faaf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">When was the powder pattern (integrated) last computed ? <br/></td></tr>
<tr class="memitem:ae1e38d5d59428ee4658f7bf8e49416a3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae1e38d5d59428ee4658f7bf8e49416a3"></a>
<a class="el" href="a00072.html">RefinableObjClock</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#ae1e38d5d59428ee4658f7bf8e49416a3">mClockPowderPatternXCorr</a></td></tr>
<tr class="memdesc:ae1e38d5d59428ee4658f7bf8e49416a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Corrections to 2Theta. <br/></td></tr>
<tr class="memitem:abcd57fa3c97fd3434daa137a619b65e2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abcd57fa3c97fd3434daa137a619b65e2"></a>
<a class="el" href="a00072.html">RefinableObjClock</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#abcd57fa3c97fd3434daa137a619b65e2">mClockScaleFactor</a></td></tr>
<tr class="memdesc:abcd57fa3c97fd3434daa137a619b65e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Last modification of the scale factor. <br/></td></tr>
<tr class="memitem:a65c938b76b08552e2147135aa269dd8e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a65c938b76b08552e2147135aa269dd8e"></a>
CrystVector_REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#a65c938b76b08552e2147135aa269dd8e">mExcludedRegionMinX</a></td></tr>
<tr class="memdesc:a65c938b76b08552e2147135aa269dd8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Min coordinate for for all excluded regions. <br/></td></tr>
<tr class="memitem:a77a9cb2e80edd777eac9b56fe68e95ef"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a77a9cb2e80edd777eac9b56fe68e95ef"></a>
CrystVector_REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#a77a9cb2e80edd777eac9b56fe68e95ef">mExcludedRegionMaxX</a></td></tr>
<tr class="memdesc:a77a9cb2e80edd777eac9b56fe68e95ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Max coordinate for 2theta for all excluded regions. <br/></td></tr>
<tr class="memitem:ae4722ceea4440d27a7de6115f70705ab"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae4722ceea4440d27a7de6115f70705ab"></a>
REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#ae4722ceea4440d27a7de6115f70705ab">mXZero</a></td></tr>
<tr class="memdesc:ae4722ceea4440d27a7de6115f70705ab"><td class="mdescLeft">&#160;</td><td class="mdescRight"><pre class="fragment">        Zero correction :
</pre><p> <img class="formulaInl" alt="$ (2\theta)_{obs} = (2\theta)_{real} +(2\theta)_{0}$" src="form_19.png"/> Thus mPowderPattern2ThetaMin=(mPowderPattern2ThetaMin-m2ThetaZero) <br/></td></tr>
<tr class="memitem:a5af69d404bd80c279935990a24edec0b"><td class="memItemLeft" align="right" valign="top">REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#a5af69d404bd80c279935990a24edec0b">mMaxSinThetaOvLambda</a></td></tr>
<tr class="memdesc:a5af69d404bd80c279935990a24edec0b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><pre class="fragment">         Displacement correction :
</pre><p> <img class="formulaInl" alt="$ (2\theta)_{obs} = (2\theta)_{real} + \frac{a}{\cos(\theta)} $" src="form_20.png"/> REAL m2ThetaDisplacement; Transparency correction : <img class="formulaInl" alt="$ (2\theta)_{obs} = (2\theta)_{real} + b\sin(2\theta) $" src="form_18.png"/> REAL m2ThetaTransparency; Time Of Flight (TOF) parameters : <img class="formulaInl" alt="$ t = DIFC*\frac{\sin(\theta)}{\lambda} + DIFA*\left(\frac{\sin(\theta)}{\lambda}\right)^2 + mXZero$" src="form_21.png"/> REAL mDIFC,mDIFA; Components of the powder pattern The components (crystalline phases, background,...) of the powder pattern <a class="el" href="a00054.html">ObjRegistry&lt;PowderPatternComponent&gt;</a> mPowderPatternComponentRegistry; The scale factors for each component.  <a href="#a5af69d404bd80c279935990a24edec0b"></a><br/></td></tr>
<tr class="memitem:ad709ac89cea3bf5eb5d29f7beb429794"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad709ac89cea3bf5eb5d29f7beb429794"></a>
Number of points actually&#160;</td><td class="memItemRight" valign="bottom"><b>used</b></td></tr>
<tr class="memitem:ae6d9f72cbed814c222921f274db95280"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae6d9f72cbed814c222921f274db95280"></a>
Number of integration <br class="typebreak"/>
intervals actually&#160;</td><td class="memItemRight" valign="bottom"><b>used</b></td></tr>
<tr class="inherit_header pro_attribs_a00071"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_a00071')"><img src="closed.png" alt="-"/>&nbsp;Protected Attributes inherited from <a class="el" href="a00071.html">ObjCryst::RefinableObj</a></td></tr>
<tr class="memitem:ad8ddc8c4b3daae8649986d7febc5fca4 inherit pro_attribs_a00071"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad8ddc8c4b3daae8649986d7febc5fca4"></a>
string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#ad8ddc8c4b3daae8649986d7febc5fca4">mName</a></td></tr>
<tr class="memdesc:ad8ddc8c4b3daae8649986d7febc5fca4 inherit pro_attribs_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name for this RefinableObject. Should be unique, at least in the same scope.+. <br/></td></tr>
<tr class="memitem:ae05556c30ef2d6818c22750c89690fc9 inherit pro_attribs_a00071"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae05556c30ef2d6818c22750c89690fc9"></a>
vector&lt; <a class="el" href="a00073.html">RefinablePar</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#ae05556c30ef2d6818c22750c89690fc9">mvpRefPar</a></td></tr>
<tr class="memdesc:ae05556c30ef2d6818c22750c89690fc9 inherit pro_attribs_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of pointers to the refinable parameters. <br/></td></tr>
<tr class="memitem:ad3b06da1eb64191be95934c097829efc inherit pro_attribs_a00071"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="a00081.html">Restraint</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#ad3b06da1eb64191be95934c097829efc">mvpRestraint</a></td></tr>
<tr class="memdesc:ad3b06da1eb64191be95934c097829efc inherit pro_attribs_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of pointers to the restraints for this object.  <a href="#ad3b06da1eb64191be95934c097829efc"></a><br/></td></tr>
<tr class="memitem:a22adaed8c98377e45800e5d8624531a2 inherit pro_attribs_a00071"><td class="memItemLeft" align="right" valign="top">map&lt; unsigned long, pair<br class="typebreak"/>
&lt; CrystVector_REAL, string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a22adaed8c98377e45800e5d8624531a2">mvpSavedValuesSet</a></td></tr>
<tr class="memdesc:a22adaed8c98377e45800e5d8624531a2 inherit pro_attribs_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map of (index,pointers to arrays) used to save sets of values for all parameters.  <a href="#a22adaed8c98377e45800e5d8624531a2"></a><br/></td></tr>
<tr class="memitem:a8cffff9a5b5d2a76bd9e29cce5f4700e inherit pro_attribs_a00071"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8cffff9a5b5d2a76bd9e29cce5f4700e"></a>
long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a8cffff9a5b5d2a76bd9e29cce5f4700e">mNbRefParNotFixed</a></td></tr>
<tr class="memdesc:a8cffff9a5b5d2a76bd9e29cce5f4700e inherit pro_attribs_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total of not-fixed parameters. <br/></td></tr>
<tr class="memitem:a359f6599fdaa11ea01afd91289265bac inherit pro_attribs_a00071"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a359f6599fdaa11ea01afd91289265bac"></a>
CrystVector_long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a359f6599fdaa11ea01afd91289265bac">mRefparNotFixedIndex</a></td></tr>
<tr class="memdesc:a359f6599fdaa11ea01afd91289265bac inherit pro_attribs_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of not-fixed parameters. <br/></td></tr>
<tr class="memitem:a920ae46a7d90f940866d35b7548d77a8 inherit pro_attribs_a00071"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a920ae46a7d90f940866d35b7548d77a8">mOptimizationDepth</a></td></tr>
<tr class="memdesc:a920ae46a7d90f940866d35b7548d77a8 inherit pro_attribs_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the object being refined or optimized ? if mOptimizationDepth=0, no optimization is taking place.  <a href="#a920ae46a7d90f940866d35b7548d77a8"></a><br/></td></tr>
<tr class="memitem:a101ff2559ab840729c8cbc7b2469afd6 inherit pro_attribs_a00071"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a101ff2559ab840729c8cbc7b2469afd6"></a>
<a class="el" href="a00054.html">ObjRegistry</a>&lt; <a class="el" href="a00071.html">RefinableObj</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a101ff2559ab840729c8cbc7b2469afd6">mSubObjRegistry</a></td></tr>
<tr class="memdesc:a101ff2559ab840729c8cbc7b2469afd6 inherit pro_attribs_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registry of RefinableObject needed for this object (owned by this object or not) <br/></td></tr>
<tr class="memitem:abe0324d0b4bbd15ee9134412b98f55c3 inherit pro_attribs_a00071"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00054.html">ObjRegistry</a>&lt; <a class="el" href="a00071.html">RefinableObj</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#abe0324d0b4bbd15ee9134412b98f55c3">mClientObjRegistry</a></td></tr>
<tr class="memdesc:abe0324d0b4bbd15ee9134412b98f55c3 inherit pro_attribs_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registry of RefinableObject using this object.  <a href="#abe0324d0b4bbd15ee9134412b98f55c3"></a><br/></td></tr>
<tr class="memitem:a85a478e7564d71102aedf7c3e81f56d0 inherit pro_attribs_a00071"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00054.html">ObjRegistry</a>&lt; <a class="el" href="a00078.html">RefObjOpt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a85a478e7564d71102aedf7c3e81f56d0">mOptionRegistry</a></td></tr>
<tr class="memdesc:a85a478e7564d71102aedf7c3e81f56d0 inherit pro_attribs_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of options for this object.  <a href="#a85a478e7564d71102aedf7c3e81f56d0"></a><br/></td></tr>
<tr class="memitem:a8e3295302c9a1f9ea29f1749132e561b inherit pro_attribs_a00071"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a8e3295302c9a1f9ea29f1749132e561b">mDeleteRefParInDestructor</a></td></tr>
<tr class="memdesc:a8e3295302c9a1f9ea29f1749132e561b inherit pro_attribs_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">If true (the default), then all <a class="el" href="a00073.html" title="Generic class for parameters of refinable objects.">RefinablePar</a> will be deleted when the the object is deleted.  <a href="#a8e3295302c9a1f9ea29f1749132e561b"></a><br/></td></tr>
<tr class="memitem:a867562fcd8c5afd0fd178c98729e1f35 inherit pro_attribs_a00071"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a867562fcd8c5afd0fd178c98729e1f35"></a>
<a class="el" href="a00072.html">RefinableObjClock</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a867562fcd8c5afd0fd178c98729e1f35">mRefParListClock</a></td></tr>
<tr class="memdesc:a867562fcd8c5afd0fd178c98729e1f35 inherit pro_attribs_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Last time the RefinableParList was modified (a parameter added or removed). <br/></td></tr>
<tr class="memitem:aab4b8fa7fc23598d79351ebd500beb3e inherit pro_attribs_a00071"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#aab4b8fa7fc23598d79351ebd500beb3e">mRandomMoveIsDone</a></td></tr>
<tr class="memitem:a20a9cbc22a6b81f95dc66ebd0ed1668d inherit pro_attribs_a00071"><td class="memItemLeft" align="right" valign="top">CrystVector_REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a20a9cbc22a6b81f95dc66ebd0ed1668d">mLSQDeriv</a></td></tr>
<tr class="memdesc:a20a9cbc22a6b81f95dc66ebd0ed1668d inherit pro_attribs_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Temporary array used to return derivative values of the LSQ function for given parameters.  <a href="#a20a9cbc22a6b81f95dc66ebd0ed1668d"></a><br/></td></tr>
<tr class="memitem:acbb5e80371ef0c72ef1bd8559226ae22 inherit pro_attribs_a00071"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00072.html">RefinableObjClock</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#acbb5e80371ef0c72ef1bd8559226ae22">mClockMaster</a></td></tr>
<tr class="memdesc:acbb5e80371ef0c72ef1bd8559226ae22 inherit pro_attribs_a00071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Master clock, which is changed whenever the object has been altered.  <a href="#acbb5e80371ef0c72ef1bd8559226ae22"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Powder pattern class, with an observed pattern and several calculated components to modelize the pattern. </p>
<p>This can also be used for simulation, using a fake Iobs. Supports multiple phases. </p>
</div><hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a964850cf74baa499f823e85447959790"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ObjCryst::PowderPattern::AddExcludedRegion </td>
          <td>(</td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>min2Theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>max2theta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add an Exclusion region, in 2theta, which will be ignored when computing R's XMLInput values must be, as always, in radians. </p>
<p>Does not work yet with integrated R factors. Note that the pattern is still computed in these regions. They are only ignored by statistics functions (R, Rws). </p>

</div>
</div>
<a class="anchor" id="a0190046adad7091ca0d7818b1ced7bb2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ObjCryst::PowderPattern::AddPowderPatternComponent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00065.html">PowderPatternComponent</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a component (phase, backround) to this pattern. </p>
<p>It must have been allocated in the heap. The pattern parameters (2theta min, step, nbpoints, wavelength, radiation type) of the component are automatically changed to that of the <a class="el" href="a00062.html" title="Powder pattern class, with an observed pattern and several calculated components to modelize the patt...">PowderPattern</a> object. </p>

</div>
</div>
<a class="anchor" id="a8e29b6186253d686c4f078906592df7b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ObjCryst::PowderPattern::BeginOptimization </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>allowApproximations</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>enableRestraints</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This should be called by any optimization class at the begining of an optimization. </p>
<p>This will also check that everything is ready, eg call the <a class="el" href="a00071.html#a48d11671e7f8699f7bc24077585c5e0f">RefinableObj::Prepare()</a> function. This also affects all sub-objects. </p>
<dl class="section note"><dt>Note:</dt><dd>this may be called several time for some objects which are used by several other objects, or for nested optimizations (e.g. least-squares optimizations inside a global one).</dd>
<dd>
<a class="el" href="a00071.html#ab0035f6164cb24ace67b51b11993a851" title="This should be called by any optimization class at the end of an optimization.">EndOptimization()</a> must be called at the end of the optimization, the same number of time <a class="el" href="a00062.html#a8e29b6186253d686c4f078906592df7b" title="This should be called by any optimization class at the begining of an optimization.">BeginOptimization()</a> was called !</dd></dl>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">allowApproximations,:</td><td>if true, then the object can use faster but less precise functions during the optimization. This is useful for global optimization not using derivatives. </td></tr>
    <tr><td class="paramname">enableRestraints,:</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="a00223.html#_deprecated000028">Deprecated:</a></b></dt><dd>if true, then restrained parameters will be allowed to go beyond theur hard limits. This implies that the algorithm will take into account the cost (penalty) related to the restraints. Objects which do not use restraints will simply ignore this. WARNING: this parameter may be removed with the new likelihood scheme. </dd></dl>

<p>Reimplemented from <a class="el" href="a00071.html#ababd8f2916e41a20d2c1b21f6ffefe96">ObjCryst::RefinableObj</a>.</p>

</div>
</div>
<a class="anchor" id="ab2ca32b0ae9d02c057c3e37b253314bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ObjCryst::PowderPattern::ExportFullprof </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prefix</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Export powder pattern &amp; crystal structure in Fullprof format. </p>
<p>This will create two files - the .pcr file (including the crystal structure and all pattern parameters), and the .dat file with the powder pattern, written using the "Ins=10" file format. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">prefix,:</td><td>the prefix used to output the two files, 'prefix'.pcr and 'prefix'.dat</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note:</dt><dd>: in development. Only supports constant wavelength neutron &amp; X-ray patterns. </dd></dl>

</div>
</div>
<a class="anchor" id="a96de1d1c8239548e8fad099d99b8a420"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">REAL ObjCryst::PowderPattern::GetChi2 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return conventionnal Chi^2. </p>
<dl class="section return"><dt>Returns:</dt><dd><img class="formulaInl" alt="$ \chi^2 = \sum_i w_i \left(I_i^{obs}-I_i^{calc} \right)^2 $" src="form_2.png"/> </dd></dl>

</div>
</div>
<a class="anchor" id="a93114b9db1bfa862fdd8497ddf023547"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const CrystVector_REAL&amp; ObjCryst::PowderPattern::GetChi2Cumul </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the powder pattern cumulative Chi^2. </p>
<p>Depending on the chosen option, *it will be calculated in an integrated manner or not.</p>
<p>The vector is recomputed on every call, so this is <em>slow</em>. </p>

</div>
</div>
<a class="anchor" id="a20dadada4d5b428c5122d4c75fb49164"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const string&amp; ObjCryst::PowderPattern::GetClassName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Name for this class ("RefinableObj", "Crystal",...). </p>
<p>This is only useful to distinguish different classes when picking up objects from the <a class="el" href="a00071.html" title="Generic Refinable Object.">RefinableObj</a> Global Registry </p>

<p>Reimplemented from <a class="el" href="a00071.html#a62968d90a7a3080738b363934616c019">ObjCryst::RefinableObj</a>.</p>

</div>
</div>
<a class="anchor" id="ad3b643041cc61a3d39765bd7c268d6bc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ObjCryst::PowderPattern::GetGeneGroup </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00071.html">RefinableObj</a> &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CrystVector_uint &amp;&#160;</td>
          <td class="paramname"><em>groupIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>firstGroup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the gene group assigned to each parameter. </p>
<p>Each parameter (a <em>gene</em> in terms of genetic algorithms) can be assigned to a gene group. Thus when mating two configurations, genes will be exchanged by groups. By default (in the base RefinabeObj class), each parameter is alone in its group. Derived classes can group genes for a better s** life.</p>
<p>The number identifying a gene group only has a meaning in a given object. It can also change on subsequent calls, and thus is not unique.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>the , supplied by an algorithm class (<a class="el" href="a00055.html" title="Base object for Optimization methods.">OptimizationObj</a>,..), which contains a list of parameters, some of which (but possibly all or none) are parameters belonging to this object. </td></tr>
    <tr><td class="paramname">groupIndex</td><td>a vector of unsigned integers, one for each parameter in the input object, giving an unsigned integer value as gene group index. At the beginning this vector should contain only zeros (no group assigned). </td></tr>
    <tr><td class="paramname">firstGroup</td><td>this is the number of groups which have already been assigned, plus one. The gene groups returned by this object will start from this value, and increment <b>firstGroup</b> for each gene group used, so that different <a class="el" href="a00071.html" title="Generic Refinable Object.">RefinableObj</a> cannot share a gene group. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note:</dt><dd>this function is not optimized, and should only be called at the beginning of a refinement. </dd></dl>

<p>Reimplemented from <a class="el" href="a00071.html#ad59c8ad2b0d7ee59fa3f399a54f05e54">ObjCryst::RefinableObj</a>.</p>

</div>
</div>
<a class="anchor" id="aae204d24cf18b10e40faa7a5560011de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">REAL ObjCryst::PowderPattern::GetIntegratedChi2 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return integrated Chi^2. </p>

</div>
</div>
<a class="anchor" id="a40363370a5a3e82d445fc3f1d653fd63"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual REAL ObjCryst::PowderPattern::GetLogLikelihood </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get -log(likelihood) of the current configuration for the object. </p>
<p>By default (no likelihood evaluation available), this is equal to 0.</p>
<p>This call should not be recursive, it is the task of the algorithm to get the sum of likelihoods for all objects invlolved.</p>
<dl class="section note"><dt>Note:</dt><dd>contrary to the old "Cost Function" approach, with log(Likelihood) there is no 'choice' of cost function, so that it is the task of the object to give the optimized likelihood (possibly with user options).</dd></dl>
<dl class="section warning"><dt>Warning:</dt><dd>: this is in under heavy development, so expect changes... </dd></dl>

<p>Reimplemented from <a class="el" href="a00071.html#a9a9a5ea2b997cd36b44ed35c2bab3245">ObjCryst::RefinableObj</a>.</p>

</div>
</div>
<a class="anchor" id="ad4b20493be0077170b2870aeca474455"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">REAL ObjCryst::PowderPattern::GetPowderPatternXStep </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the average step in 2theta. </p>
<dl class="section warning"><dt>Warning:</dt><dd>: this will only return (2ThetaMax-2ThetaMin)/(nbPoints-1), so this is the 2theta step only if the step is fixed.</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="a00223.html#_deprecated000025">Deprecated:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a761c704aab8ad2b326f6b287ba837a5c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">REAL ObjCryst::PowderPattern::GetR </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unweighted R-factor. </p>
<dl class="section return"><dt>Returns:</dt><dd><img class="formulaInl" alt="$ R= \sqrt {\frac{\sum_i \left( I_i^{obs}-I_i^{calc} \right)^2} {\sum_i (I_i^{obs})^2} }$" src="form_1.png"/> </dd></dl>

</div>
</div>
<a class="anchor" id="aa756bdaad051400d841989bc6e9bef55"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">REAL ObjCryst::PowderPattern::GetRw </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the weighted R-factor. </p>
<dl class="section return"><dt>Returns:</dt><dd><img class="formulaInl" alt="$ R_{w}= \sqrt {\frac{\sum_i w_i\left( I_i^{obs}-I_i^{calc} \right)^2} {\sum_i w_i (I_i^{obs})^2} }$" src="form_0.png"/> </dd></dl>

</div>
</div>
<a class="anchor" id="a35119a32e043f1b9e003cfe1ed18a1b1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ObjCryst::PowderPattern::GlobalOptRandomMove </td>
          <td>(</td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>mutationAmplitude</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00080.html">RefParType</a> *&#160;</td>
          <td class="paramname"><em>type</em> = <code><a class="el" href="a00171.html#a92ed37a804903dfb302d70309b7bc474">gpRefParTypeObjCryst</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a random move of the current configuration. </p>
<p>This is for global optimization algorithms. the moves for each parameter are less than their global optimization step, multiplied by the mutation amplitude.</p>
<dl class="section warning"><dt>Warning:</dt><dd>: this makes a random move for the parameter declared for this object, and it is the duty of the object to decide whether the included objects should be moved and how. (eg an algorithm should only call for a move with the top object, and this object decides how he and his sub-objects moves). By default (<a class="el" href="a00071.html" title="Generic Refinable Object.">RefinableObj</a> implementation) all included objects are moved recursively.</dd></dl>
<p><a class="el" href="a00071.html" title="Generic Refinable Object.">RefinableObj</a>:: </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutationAmplitude,:</td><td>multiplier for the maximum move amplitude, for all parameters </td></tr>
    <tr><td class="paramname">type,:</td><td>restrain the change exclusively to parameters of a given type (same type or descendant from this <a class="el" href="a00080.html" title="class of refinable parameter types.">RefParType</a>). </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="a00071.html#a18375c8525ae38c481ba77e9cf9d67c1">ObjCryst::RefinableObj</a>.</p>

</div>
</div>
<a class="anchor" id="a1c817b8e20b03b216323933e01e6fb00"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ObjCryst::PowderPattern::ImportPowderPattern2ThetaObs </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nbSkip</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Import file with 2 columns 2Theta Iobs. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">fileName,:</td><td>the filename (surprise!) </td></tr>
    <tr><td class="paramname">nbSkip,:</td><td>the number of lines to skip at the beginning of the file (default=0) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aee56a2f23b8af5c855ceae82c246f242"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ObjCryst::PowderPattern::ImportPowderPattern2ThetaObsSigma </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nbSkip</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Import file with 3 columns 2Theta Iobs Sigma. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">fileName,:</td><td>the filename (surprise!) </td></tr>
    <tr><td class="paramname">nbSkip,:</td><td>the number of lines to skip at the beginning of the file (default=0) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4499e38a96db3f3c0abdb6d30f3400e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ObjCryst::PowderPattern::ImportPowderPatternFullprof </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>fullprofFileName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Import fullprof-style diffraction data. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">fullprofFileName,:</td><td>filename </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a272b9fd71a6925eb9e1a991e488259b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ObjCryst::PowderPattern::ImportPowderPatternFullprof4 </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>fileName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Import diffraction data from a file, with the first line has 2ThetaMin, step, 2thetaMax, and the following lines alternate 10 Iobs and 10 sigma. </p>
<p>Ends with null entries (to fill last Iobs line to reach last sigme line).</p>
<p>That's fullprof format #4. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">fileName,:</td><td>filename </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a78be27d8764377f99e324a7181eac633"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ObjCryst::PowderPattern::ImportPowderPatternGSAS </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>fileName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Import GSAS standard powder pattern data (see GSAS manual). </p>
<dl class="section warning"><dt>Warning:</dt><dd>: partial support (only CONST-constant wavelength- data so far) </dd></dl>

</div>
</div>
<a class="anchor" id="abfc7890a1853583957284fc1a2644855"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ObjCryst::PowderPattern::ImportPowderPatternMultiDetectorLLBG42 </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>fileName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>diffraction data in a multi-detector format (fullprof format #6). </p>
<p>First line is text. Third entry of second line is the 2theta step. Third *line has the 2thetamin, fourth line has monitors and temperatures. Then each line has ten pairs (I2,I8)of NbCounters,intensity. Ends with negative entries. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">fileName,:</td><td>filename </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adabe6381d8d1189abcf420f69a41cc81"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ObjCryst::PowderPattern::ImportPowderPatternSietronicsCPI </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>fileName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Import *.cpi Sietronics diffraction data. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">fileName,:</td><td>filename </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9d7209065acb5a992129cf6a2b14b526"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ObjCryst::PowderPattern::ImportPowderPatternTOF_ISIS_XYSigma </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>fileName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Import TOF file (ISIS type, 3 columns t, Iobs, sigma(Iobs)) </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">fileName,:</td><td>the filename </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4a8e1dc893c04a4451327d3f48f21d0e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ObjCryst::PowderPattern::ImportPowderPatternXdd </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>fileName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Import *.xdd diffraction data (Topas,...). </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">fileName,:</td><td>filename </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae03f4d2f08e749e4f494eb78050dbffe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ObjCryst::PowderPattern::Prepare </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Prepare everything (if necessary) for an optimization/calculation. </p>

<p>Reimplemented from <a class="el" href="a00071.html#a48d11671e7f8699f7bc24077585c5e0f">ObjCryst::RefinableObj</a>.</p>

</div>
</div>
<a class="anchor" id="a9d47390be9f1a5a47ea141d2708b8992"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ObjCryst::PowderPattern::SavePowderPattern </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>filename</em> = <code>&quot;powderPattern.out&quot;</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save powder pattern to one file, text format, 3 columns theta Iobs Icalc. </p>
<p>If Iobs is missing, the column is omitted.</p>
<dl class="todo"><dt><b><a class="el" href="a00222.html#_todo000007">Todo:</a></b></dt><dd>export in other formats (.prf,...), with a list of reflection position for all phases... </dd></dl>

</div>
</div>
<a class="anchor" id="a2b7b3ba4d020f3cf77409116ab0c7782"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ObjCryst::PowderPattern::SetMaxSinThetaOvLambda </td>
          <td>(</td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>max</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the maximum value for sin(theta)/lambda. </p>
<p>All data (reflections,..) still exist but are ignored for all calculations. </p>

</div>
</div>
<a class="anchor" id="a8562e190d277379e6e18d43f3d616976"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ObjCryst::PowderPattern::SetPowderPatternObs </td>
          <td>(</td>
          <td class="paramtype">const CrystVector_REAL &amp;&#160;</td>
          <td class="paramname"><em>obs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set observed powder pattern from vector array. </p>
<p>Note: powder pattern parameters must have been set before calling this function, for example by calling DiffractionDataPowder::InitPowderPatternPar(). </p>

</div>
</div>
<a class="anchor" id="adb92497ec0c6793c1cb74fc1bf9914e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ObjCryst::PowderPattern::SetPowderPatternPar </td>
          <td>(</td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>nbPoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the powder pattern angular range &amp; resolution parameter. </p>
<p>this will affect all components (phases) of the pattern.</p>
<p>Use this with caution, as the number of points must be correct with respect to the observed data (Iobs).</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">min,:</td><td>min 2theta (in radians) or time-of-flight (in microseconds) value, </td></tr>
    <tr><td class="paramname">step,:</td><td>step (assumed constant) in 2theta or time-of-flight (in microseconds). </td></tr>
    <tr><td class="paramname">nbPoints,:</td><td>number of points in the pattern.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning:</dt><dd>: use only this for constant-step patterns. Otherwise, use <a class="el" href="a00062.html#a64170b8ead948e9b8569e1613d849583" title="Set the x coordinate of the powder pattern : either the 2theta or time-of-flight values for each reco...">PowderPattern::SetPowderPatternX()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a64170b8ead948e9b8569e1613d849583"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ObjCryst::PowderPattern::SetPowderPatternX </td>
          <td>(</td>
          <td class="paramtype">const CrystVector_REAL &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the x coordinate of the powder pattern : either the 2theta or time-of-flight values for each recorded point. </p>
<p>The step need not be constant, but the variation must be strictly monotonous.</p>
<p>2theta must be in radians and time-of-flight in microseconds </p>

</div>
</div>
<a class="anchor" id="aea1c5351f710f2a91844b0f29b7b04aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ObjCryst::PowderPattern::SetWavelength </td>
          <td>(</td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>lambda</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the wavelength of the experiment (in Angstroems). </p>
<dl class="section note"><dt>Note:</dt><dd>: this is only useful for a monochromatic (X-Ray or neutron) powder pattern. </dd></dl>

</div>
</div>
<a class="anchor" id="a9638b42f38dd82522593e1e01b6629c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ObjCryst::PowderPattern::SetWavelength </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>XRayTubeElementName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>alpha12ratio</em> = <code>0.5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the wavelength of the experiment to that of an X-Ray tube. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">XRayTubeElementName</td><td>: name of the anticathode element name. Known *ones are Cr, Fe, Cu, Mo, Ag. </td></tr>
    <tr><td class="paramname">alpha2Alpha2ratio,:</td><td>Kalpha2/Kalpha1 ratio (0.5 by default)</td></tr>
  </table>
  </dd>
</dl>
<p>*Alpha1 and alpha2 wavelength are taken *from R. Grosse-Kunstleve package, and the average wavelength is calculated *using the alpha2/alpha1 weight. All structure factors computation are made *using the average wavelength, and for powder diffraction, profiles are output *at the alpha1 and alpha2 ratio for the calculated pattern.</p>
<p>*NOTE : if the name of the wavelength is generic (eg"Cu"), *then the program considers that *there are both Alpha1 and Alpha2, and thus automatically changes the WavelengthType *to WAVELENGTH_ALPHA12. If instead either alpha1 or alpha2 (eg "CuA1") is asked for, *the WavelengthType is set to WAVELENGTH_MONOCHROMATIC. In both cases, the radiation type is set to X-Ray. </p>

</div>
</div>
<a class="anchor" id="a3648701bed1a9ba0b576241226e06032"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ObjCryst::PowderPattern::SetWeightPolynomial </td>
          <td>(</td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>minRelatIobs</em> = <code>1e-3</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set w = 1/(a+ Iobs + b*Iobs^2+c*Iobs^3) </p>
<p>To filter too small or null intensities: if Iobs &lt; [minRelatIobs * max(Iobs)], then use Iobs=minRelatIobs * max(Iobs) to compute the weight.</p>
<p>Typical values: a=2*min(Iobs) b=2/max(Iobs) c=0 </p>

</div>
</div>
<a class="anchor" id="add7d97cdb7610f7553b95c2eeefcd172"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ObjCryst::PowderPattern::SetWeightToInvSigmaSq </td>
          <td>(</td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>minRelatSigma</em> = <code>1e-3</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set w = 1/sigma^2. </p>
<p>To filter too small or null intensities :If sigma&lt; minRelatSigma* max(sigma), then w=1/(minRelatSigma* max(sigma))^2 </p>

</div>
</div>
<a class="anchor" id="acea2e9e61825c9d68f73352cc5373215"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">REAL ObjCryst::PowderPattern::STOL2Pixel </td>
          <td>(</td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>stol</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert sin(theta)/lambda to pixel, depending on the type of radiation. </p>
<p>This does not take into account any zero/transparency, etc... correction </p>

</div>
</div>
<a class="anchor" id="a432996a6cc82b3029e5615b1d144a0dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">REAL ObjCryst::PowderPattern::STOL2X </td>
          <td>(</td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>stol</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert sin(theta)/lambda to X (i.e. </p>
<p>either to 2theta or to TOF), depending on the type of radiation.</p>
<p>This does not take into account any zero/transparency, etc... correction </p>

</div>
</div>
<a class="anchor" id="a352e6d6afb489c2c24e811fa8b70d801"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">REAL ObjCryst::PowderPattern::X2Pixel </td>
          <td>(</td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the pixel number on the experimental pattern, corresponding to a given (experimental) x coordinate. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">x,:</td><td>the x (2theta, tof) value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the x (2theta, tof) value as it appears on the pattern.</dd></dl>
<dl class="section warning"><dt>Warning:</dt><dd>: this can be real slow, especially for non-fixed steps.</dd>
<dd>
: this returns the exact pixel coordinate, as a floating-point value, and <em>not</em> the closest pixel coordinate. </dd></dl>

</div>
</div>
<a class="anchor" id="a53607c581d6322d3902663c4338d66b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">REAL ObjCryst::PowderPattern::X2PixelCorr </td>
          <td>(</td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the pixel number on the experimental pattern, from the theoretical (uncorrected) x coordinate, taking into account all corrections. </p>
<p>(zero, transparency,..). </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">x,:</td><td>the theoretical x (2theta, tof) value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the x (2theta, tof) value as it appears on the pattern.</dd></dl>
<dl class="section warning"><dt>Warning:</dt><dd>: this can be real slow, especially for non-fixed steps.</dd>
<dd>
: this returns the exact pixel coordinate, as a floating-point value, and <em>not</em> the closest pixel coordinate. </dd></dl>

</div>
</div>
<a class="anchor" id="a0f6a97d56244a3e03b6742bec5e4199f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">REAL ObjCryst::PowderPattern::X2STOL </td>
          <td>(</td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert X (either 2theta or TOF) to sin(theta)/lambda, depending on the type of radiation. </p>
<p>This does not take into account any zero/transparency, etc... correction </p>

</div>
</div>
<a class="anchor" id="a4c39ce0ed469d514cdec31efeb7a49a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">REAL ObjCryst::PowderPattern::X2XCorr </td>
          <td>(</td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the experimental x (2theta, tof) from the theoretical value, taking into account all corrections (zero, transparency,..). </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">ttheta,:</td><td>the theoretical x (2theta, tof) value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the x (2theta, tof) value as it appears on the pattern. </dd></dl>

</div>
</div>
<a class="anchor" id="ae80f37cee10c08e6acb02300fe30c894"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ObjCryst::PowderPattern::XMLInput </td>
          <td>(</td>
          <td class="paramtype">istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00151.html">XMLCrystTag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Input From stream. </p>
<dl class="todo"><dt><b><a class="el" href="a00222.html#_todo000027">Todo:</a></b></dt><dd>Add an bool XMLInputTag(is,tag) function to recognize all the tags from the stream. So that each inherited class can use the XMLInputTag function from its parent (ie take advantage of inheritance). The children class would first try to interpret the tag, then if unsuccessful would pass it to its parent (thus allowing overloading), etc... </dd></dl>

<p>Reimplemented from <a class="el" href="a00071.html#ac13a4045c3f187879443c8615c38d623">ObjCryst::RefinableObj</a>.</p>

</div>
</div>
<a class="anchor" id="a85e8803b7680a6d3b5463990fee76c6f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ObjCryst::PowderPattern::XMLOutput </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>indent</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Output to stream in well-formed XML. </p>
<dl class="todo"><dt><b><a class="el" href="a00222.html#_todo000026">Todo:</a></b></dt><dd>Use inheritance.. as for XMLInputTag()... </dd></dl>

<p>Reimplemented from <a class="el" href="a00071.html#a7b9b6ed0f8dcf753d398c35e073de973">ObjCryst::RefinableObj</a>.</p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a5af69d404bd80c279935990a24edec0b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">REAL ObjCryst::PowderPattern::mMaxSinThetaOvLambda</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><pre class="fragment">         Displacement correction :
</pre><p> <img class="formulaInl" alt="$ (2\theta)_{obs} = (2\theta)_{real} + \frac{a}{\cos(\theta)} $" src="form_20.png"/> REAL m2ThetaDisplacement; Transparency correction : <img class="formulaInl" alt="$ (2\theta)_{obs} = (2\theta)_{real} + b\sin(2\theta) $" src="form_18.png"/> REAL m2ThetaTransparency; Time Of Flight (TOF) parameters : <img class="formulaInl" alt="$ t = DIFC*\frac{\sin(\theta)}{\lambda} + DIFA*\left(\frac{\sin(\theta)}{\lambda}\right)^2 + mXZero$" src="form_21.png"/> REAL mDIFC,mDIFA; Components of the powder pattern The components (crystalline phases, background,...) of the powder pattern <a class="el" href="a00054.html">ObjRegistry&lt;PowderPatternComponent&gt;</a> mPowderPatternComponentRegistry; The scale factors for each component. </p>
<p>For unscalable phases, this is set to 1 (constant).</p>
<p>This is mutable because generally we use the 'best' scale factor, but it should not be... mutable CrystVector_REAL mScaleFactor;</p>
<p>Use faster, less precise functions ? bool mUseFastLessPreciseFunc;</p>
<p>For statistics Should Statistics (R, Rw,..) exclude the background ? bool mStatisticsExcludeBackground; </p>
<p>To compute scale factors, which are the components (phases) that can be scaled ? mutable CrystVector_int mScalableComponentIndex; </p>
<p>Used to fit the components' scale factors mutable CrystMatrix_REAL mFitScaleFactorM,mFitScaleFactorB,mFitScaleFactorX;</p>
<p>Use Integrated profiles for Chi^2, R, Rwp... <a class="el" href="a00078.html" title="Base class for options.">RefObjOpt</a> mOptProfileIntegration;</p>
<p>Integrated R-factors mutable CrystVector_long mIntegratedPatternMin,mIntegratedPatternMax; mutable CrystVector_REAL mIntegratedObs; mutable CrystVector_REAL mIntegratedWeight; mutable CrystVector_REAL mIntegratedWeightObs; mutable CrystVector_REAL mIntegratedVarianceObs; mutable <a class="el" href="a00072.html" title="We need to record exactly when refinable objects have been modified for the last time (to avoid re-co...">RefinableObjClock</a> mClockIntegratedFactorsPrep; Statistical indicators mutable REAL mChi2,mIntegratedChi2; This is the logarithm of the part of log(Likelihood) which corresponds to the normalization terms of gaussian distribution for each obs/calc point. In practice, this is the sum of 1/2*log(2pi*sig(i)^2), although we discard the 2pi terms. mutable REAL mChi2LikeNorm,mIntegratedChi2LikeNorm; mutable REAL mR; mutable REAL mRw; Clock the last time Chi^2 was computed mutable <a class="el" href="a00072.html" title="We need to record exactly when refinable objects have been modified for the last time (to avoid re-co...">RefinableObjClock</a> mClockChi2,mClockIntegratedChi2; /** Maximum sin(theta)/lambda for all calculations (10 by default).</p>
<p>This keeps all data in memory, but only the part which is below the max is calculated. </p>

</div>
</div>
<a class="anchor" id="aa38c508b5516a2b4e357b7116e0b11da"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CrystVector_REAL ObjCryst::PowderPattern::mPowderPatternBackgroundCalc</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The calculated powder pattern part which corresponds to 'background' (eg non-scalable components). </p>
<p>It is already included in mPowderPatternCalc </p>

</div>
</div>
<a class="anchor" id="a039c845ac70b5118f5090077a5ef7f70"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CrystVector_REAL ObjCryst::PowderPattern::mPowderPatternCalc</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The calculated powder pattern. </p>
<p>It is mutable since it is completely defined by other parameters (eg it is not an 'independent parameter') </p>

</div>
</div>
<a class="anchor" id="ac962c591539d06c65ce32e56580029c2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CrystVector_REAL ObjCryst::PowderPattern::mPowderPatternVariance</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The complete variance associated to each point of the powder pattern, taking into account observation and model errors. </p>

</div>
</div>
<a class="anchor" id="a7c7192cf095beca2d515a15f4c57d227"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CrystVector_REAL ObjCryst::PowderPattern::mPowderPatternVarianceIntegrated</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The complete variance associated to each point of the powder pattern, taking into account observation and model errors. </p>
<p>Integrated. </p>

</div>
</div>
<a class="anchor" id="ac71a81d157387c2bdb7791cfa6d18e64"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CrystVector_REAL ObjCryst::PowderPattern::mX</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector of x coordinates (either 2theta or time-of-flight) for the pattern. </p>
<p>Stored in ascending order for 2theta, and descending for TOF, i.e. always in ascending order for the corresponding sin(theta)/lambda. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>PowderPattern.h</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Jul 13 2012 17:28:14 for ObjCryst++ by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.1
</small></address>
</body>
</html>
