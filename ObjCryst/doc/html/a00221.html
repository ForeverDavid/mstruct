<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>ObjCryst++: Todo List</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.2-20100208 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">


<h1><a class="anchor" id="todo">Todo List </a></h1><p><a class="anchor" id="_todo000020"></a> </p>
<dl>
<dt>Class <a class="el" href="a00024.html">CrystVector&lt; T &gt;</a>  </dt>
<dd>check again Blitz++ support in newer gcc versions. </dd>
</dl>
<p><a class="anchor" id="_todo000014"></a> </p>
<dl>
<dt>Class <a class="el" href="a00007.html">ObjCryst::AsymmetricUnit</a>  </dt>
<dd>Currently the initialization of the asymmetric unit is done numerically, slowly. A faster algorithm should be used (using dichotomy), or we could switch to using a table of asymmetric units. </dd>
</dl>
<p><a class="anchor" id="_todo000001"></a> </p>
<dl>
<dt>Class <a class="el" href="a00020.html">ObjCryst::Crystal</a>  </dt>
<dd><p class="startdd">exporting (and importing) crystal structures to/from other files format than ObjCryst's XML (eg CIF, and format used by refinement software)</p>
<p class="enddd"></p>
</dd>
</dl>
<p><a class="anchor" id="_todo000003"></a> </p>
<dl>
<dt>Member <a class="el" href="a00020.html#a1d59955724fb598fbba3ff4c0bd125e3">ObjCryst::Crystal::CalcDistTable</a> (const bool fast) const  </dt>
<dd><p class="startdd">sanitize the result distance table in a more usable structure than the currently used Crystal::mDistTableSq and Crystal::mDistTableIndex. </p>
<p class="enddd">optimize again. Test if recomputation is needed using Clocks. Use a global option instead of asymUnitMargin. </p>
</dd>
</dl>
<p><a class="anchor" id="_todo000002"></a> </p>
<dl>
<dt>Member <a class="el" href="a00020.html#ac4a7086d3757be4bbe2484f549a1b0fc">ObjCryst::Crystal::Print</a> (ostream &amp;os=cout) const  </dt>
<dd>one function to print on one line and a PrintLong() function </dd>
</dl>
<p><a class="anchor" id="_todo000005"></a> </p>
<dl>
<dt>Class <a class="el" href="a00048.html">ObjCryst::MolZAtom</a>  </dt>
<dd>: some flags could be added to mark the fixed/limited nature of the parameters. </dd>
</dl>
<p><a class="anchor" id="_todo000022"></a> </p>
<dl>
<dt>Class <a class="el" href="a00053.html">ObjCryst::ObjRegistry&lt; T &gt;</a>  </dt>
<dd>(?) create two derived classes with the same interface, one which is a const registry (the 'client' registry for RefinableObj), and one which has a non-const access to the registered objects (the 'sub-objects' in RefinableObj). </dd>
</dl>
<p><a class="anchor" id="_todo000008"></a> </p>
<dl>
<dt>Class <a class="el" href="a00060.html">ObjCryst::PolarizationCorr</a>  </dt>
<dd>: extend this to take into account other diffracting &amp; monochromatic geometries. </dd>
</dl>
<p><a class="anchor" id="_todo000007"></a> </p>
<dl>
<dt>Member <a class="el" href="a00061.html#a9d47390be9f1a5a47ea141d2708b8992">ObjCryst::PowderPattern::SavePowderPattern</a> (const string &amp;filename="powderPattern.out") const  </dt>
<dd>export in other formats (.prf,...), with a list of reflection position for all phases... </dd>
</dl>
<p><a class="anchor" id="_todo000006"></a> </p>
<dl>
<dt>Member <a class="el" href="a00065.html#addc10ae4a02801eb441e38b4beae2e9a">ObjCryst::PowderPatternDiffraction::mIntensityCorr</a>  </dt>
<dd>: store all corrections in a registry, so that other corrections can more easily be added (? Maybe not that useful, especially since these correction do not need to be displayed to the user ?). </dd>
</dl>
<p><a class="anchor" id="_todo000009"></a> </p>
<dl>
<dt>Class <a class="el" href="a00068.html">ObjCryst::Radiation</a>  </dt>
<dd>also add here information about the polarization of the beam. </dd>
</dl>
<p><a class="anchor" id="_todo000023"></a> </p>
<dl>
<dt>Class <a class="el" href="a00070.html">ObjCryst::RefinableObj</a>  </dt>
<dd>Define more clearly which operations are recursive (ie also modify sub-objects). </dd>
</dl>
<p><a class="anchor" id="_todo000025"></a> </p>
<dl>
<dt>Member <a class="el" href="a00070.html#a24bfb12849c7733a7034928fbb0b14a8">ObjCryst::RefinableObj::GetLSQDeriv</a> (const unsigned int, RefinablePar &amp;) </dt>
<dd>This should be a const method, and the given RefPar should be const too... </dd>
</dl>
<p><a class="anchor" id="_todo000024"></a> </p>
<dl>
<dt>Member <a class="el" href="a00070.html#a8afc65925b0e4d1894d72c457ad38bc9">ObjCryst::RefinableObj::RegisterClient</a> (RefinableObj &amp;) const  </dt>
<dd>: the clients should be const, but are not... This need to be fixed... </dd>
</dl>
<p><a class="anchor" id="_todo000027"></a> </p>
<dl>
<dt>Member <a class="el" href="a00070.html#ac13a4045c3f187879443c8615c38d623">ObjCryst::RefinableObj::XMLInput</a> (istream &amp;is, const XMLCrystTag &amp;tag) </dt>
<dd>Add an bool XMLInputTag(is,tag) function to recognize all the tags from the stream. So that each inherited class can use the XMLInputTag function from its parent (ie take advantage of inheritance). The children class would first try to interpret the tag, then if unsuccessful would pass it to its parent (thus allowing overloading), etc... </dd>
</dl>
<p><a class="anchor" id="_todo000026"></a> </p>
<dl>
<dt>Member <a class="el" href="a00070.html#a7b9b6ed0f8dcf753d398c35e073de973">ObjCryst::RefinableObj::XMLOutput</a> (ostream &amp;os, int indent=0) const  </dt>
<dd>Use inheritance.. as for XMLInputTag()... </dd>
</dl>
<p><a class="anchor" id="_todo000021"></a> </p>
<dl>
<dt>Class <a class="el" href="a00072.html">ObjCryst::RefinablePar</a>  </dt>
<dd><p class="startdd">: define parameters using equations between parameters. </p>
<p class="enddd">: for complex objects with lots of parameters, give the possibility to define vectors of parameters, all with the same properties, to reduce memory usage. </p>
</dd>
</dl>
<p><a class="anchor" id="_todo000010"></a> </p>
<dl>
<dt>Class <a class="el" href="a00088.html">ObjCryst::ScatteringData</a>  </dt>
<dd><p class="startdd">Optimize computation for Bijvoet/Friedel mates. To do this, generate an internal list of 'true independent reflections', with two entries for each, for both mates, and make the 'real' reflections only a reference to these reflections.</p>
<p></p>
<p class="enddd">a <b>lot</b> of cleaning is necessary in the computing of structure factors, for (1) the 'preparation' part (deciding what needs to be recomputed) and (2) to allow anisotropic temperature factors (or other anisotropic parts) </p>
</dd>
</dl>
<p><a class="anchor" id="_todo000012"></a> </p>
<dl>
<dt>Member <a class="el" href="a00088.html#ae126b860d309daa78e975b8b6d8a3ec0">ObjCryst::ScatteringData::SetIsIgnoringImagScattFact</a> (const bool b) </dt>
<dd>this should become useless once we take fully advantage of coupled computation of Structure Factors for Fridel/Bijvoet mates using an internal list of 'fully unique' reflections. Then only one of the mates need to be computed.. </dd>
</dl>
<p><a class="anchor" id="_todo000013"></a> </p>
<dl>
<dt>Class <a class="el" href="a00089.html">ObjCryst::ScatteringPower</a>  </dt>
<dd><p class="startdd">Anisotropic scattering (temperature factor especially) code, using derived classes </p>
<p class="enddd">Clarify organization by removing any 'real' data from the top, abstract base class (eg remove Biso and Betaij), and by creating derived classes. Optionnaly 3 classes (used as members of ScatteringPower) could be created, TemperatureFactor, ScatteringFactor, and ResonantScatteringFactor. In any way the design of this class should not evolve, so that code using the ScatteringPower interface will remain compatible whatever modifications are made. </p>
</dd>
</dl>
<p><a class="anchor" id="_todo000015"></a> </p>
<dl>
<dt>Member <a class="el" href="a00094.html#adc3c511d36ad707690ca4f9c0154a8a0">ObjCryst::SpaceGroup::ChangeToAsymmetricUnit</a> (REAL x, REAL y, REAL z) const  </dt>
<dd>SpaceGroup::IsInAsymmetricUnit() </dd>
</dl>
<p><a class="anchor" id="_todo000016"></a> </p>
<dl>
<dt>Member <a class="el" href="a00094.html#a7c3746694fb9a6dbe3f258febb858744">ObjCryst::SpaceGroup::Print</a> () const  </dt>
<dd></dd>
</dl>
<p><a class="anchor" id="_todo000028"></a> </p>
<dl>
<dt>Class <a class="el" href="a00114.html">ObjCryst::WXCrystObj</a>  </dt>
<dd>Allow the objects to be collabsable. The difficulty is that even if the object is not shown, it is not removed by the Sizer as long as it is not deleted... Needs some testing ! Otherwise it would also be possible to delete and re-create sub-objects when collapsing, but that would be more difficult. </dd>
</dl>
<p><a class="anchor" id="_todo000031"></a> </p>
<dl>
<dt>Class <a class="el" href="a00124.html">ObjCryst::WXFieldRefPar</a>  </dt>
<dd>: allow acces to the parameters limits </dd>
</dl>
<p><a class="anchor" id="_todo000030"></a> </p>
<dl>
<dt>Class <a class="el" href="a00136.html">ObjCryst::WXPowderPatternBackground</a>  </dt>
<dd>Display the list of background points with the refinable intensity. Add th possibility to change the points. </dd>
</dl>
<p><a class="anchor" id="_todo000029"></a> </p>
<dl>
<dt>Class <a class="el" href="a00138.html">ObjCryst::WXPowderPatternGraph</a>  </dt>
<dd>display the difference pattern. Allow to zoom. Display reflection positions for crystalline phases. </dd>
</dl>
<p><a class="anchor" id="_todo000018"></a> </p>
<dl>
<dt>Member <a class="el" href="a00155.html#a551fabc1d57cab02e957946dcfa1aae7">ObjCryst::ZScatterer::ExportFenskeHallZMatrix</a> (ostream &amp;os) </dt>
<dd>USe more strict formatting than space-delimited. </dd>
</dl>
<p><a class="anchor" id="_todo000017"></a> </p>
<dl>
<dt>Member <a class="el" href="a00155.html#a097d27206e6e54259bb987a06d65f71c">ObjCryst::ZScatterer::ImportFenskeHallZMatrix</a> (istream &amp;is, bool named=false) </dt>
<dd>: identify which dihedral angles should <em>not</em> be limited, by analysing a coordination table. </dd>
</dl>
<p><a class="anchor" id="_todo000019"></a> </p>
<dl>
<dt>Member <a class="el" href="a00155.html#aa02e92087f85784a74d1bdcebf178da9">ObjCryst::ZScatterer::m3DDisplayIndex</a>  </dt>
<dd>This is still experimental. This is only used for the display of ZPolyhedron, and should be more developped (and it should also be saved in XML files !) </dd>
</dl>
</div>
<hr class="footer"/><address style="text-align: right;"><small>Generated by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2-20100208 </small></address>
</body>
</html>
