<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>ObjCryst++: ObjCryst::PowderPatternBackground Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">ObjCryst++
   &#160;<span id="projectnumber">1.5CVS</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="a00171.html">ObjCryst</a>      </li>
      <li class="navelem"><a class="el" href="a00063.html">PowderPatternBackground</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<div class="title">ObjCryst::PowderPatternBackground Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="ObjCryst::PowderPatternBackground" --><!-- doxytag: inherits="ObjCryst::PowderPatternComponent" -->
<p>Phase to compute a background contribution to a powder pattern using an interpolation.  
 <a href="a00063.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for ObjCryst::PowderPatternBackground:</div>
<div class="dyncontent">
 <div class="center">
  <img src="a00063.png" usemap="#ObjCryst::PowderPatternBackground_map" alt=""/>
  <map id="ObjCryst::PowderPatternBackground_map" name="ObjCryst::PowderPatternBackground_map">
<area href="a00065.html" title="Generic class to compute components (eg the contribution of a given phase, or background) of a powder..." alt="ObjCryst::PowderPatternComponent" shape="rect" coords="0,56,219,80"/>
<area href="a00071.html" title="Generic Refinable Object." alt="ObjCryst::RefinableObj" shape="rect" coords="0,0,219,24"/>
</map>
 </div></div>

<p><a href="a00279.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a46496ee29e07d0c8949bfc45d77a4c3e"></a><!-- doxytag: member="ObjCryst::PowderPatternBackground::PowderPatternBackground" ref="a46496ee29e07d0c8949bfc45d77a4c3e" args="(const PowderPatternBackground &amp;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PowderPatternBackground</b> (const <a class="el" href="a00063.html">PowderPatternBackground</a> &amp;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00063.html#afae084513270b7adf50954bec4037380">GetClassName</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Name for this class ("RefinableObj", "Crystal",...).  <a href="#afae084513270b7adf50954bec4037380"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00063.html#a02032467fb6485e05f0a1bbf74133833">SetParentPowderPattern</a> (<a class="el" href="a00062.html">PowderPattern</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the <a class="el" href="a00062.html" title="Powder pattern class, with an observed pattern and several calculated components to modelize the patt...">PowderPattern</a> object which uses this component.  <a href="#a02032467fb6485e05f0a1bbf74133833"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const CrystVector_REAL &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00063.html#adb37c0a9b8e41e6dc11e6a9718c89bf5">GetPowderPatternCalc</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the calculated powder pattern for this component.  <a href="#adb37c0a9b8e41e6dc11e6a9718c89bf5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual pair&lt; const <br class="typebreak"/>
CrystVector_REAL *, const <br class="typebreak"/>
<a class="el" href="a00072.html">RefinableObjClock</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00063.html#a5bc997017cf1d95641b44021175c3dad">GetPowderPatternIntegratedCalc</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the integrated values of the powder pattern.  <a href="#a5bc997017cf1d95641b44021175c3dad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae68fc3a9883ca45c81a22119c28d9379"></a><!-- doxytag: member="ObjCryst::PowderPatternBackground::ImportUserBackground" ref="ae68fc3a9883ca45c81a22119c28d9379" args="(const string &amp;filename)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00063.html#ae68fc3a9883ca45c81a22119c28d9379">ImportUserBackground</a> (const string &amp;filename)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Import background points from a file (with two columns 2theta (or tof), intensity) <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afda9ea065efbed3fcfc783060de9b415"></a><!-- doxytag: member="ObjCryst::PowderPatternBackground::SetInterpPoints" ref="afda9ea065efbed3fcfc783060de9b415" args="(const CrystVector_REAL tth, const CrystVector_REAL backgd)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetInterpPoints</b> (const CrystVector_REAL tth, const CrystVector_REAL backgd)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a09b8b88c54f8916cea09ffd93bb5c18d"></a><!-- doxytag: member="ObjCryst::PowderPatternBackground::GetInterpPoints" ref="a09b8b88c54f8916cea09ffd93bb5c18d" args="() const " -->
const std::pair&lt; const <br class="typebreak"/>
CrystVector_REAL *, const <br class="typebreak"/>
CrystVector_REAL * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>GetInterpPoints</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00063.html#a41f59111f35f92d0c3b99942606b234e">XMLOutput</a> (ostream &amp;os, int indent=0) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Output to stream in well-formed XML.  <a href="#a41f59111f35f92d0c3b99942606b234e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00063.html#a7747e4a20056c4756943319bc8ffba8d">XMLInput</a> (istream &amp;is, const <a class="el" href="a00151.html">XMLCrystTag</a> &amp;tag)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Input From stream.  <a href="#a7747e4a20056c4756943319bc8ffba8d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00063.html#ae34c8b65496994cce5b6b73748d3a2b9">GetGeneGroup</a> (const <a class="el" href="a00071.html">RefinableObj</a> &amp;obj, CrystVector_uint &amp;groupIndex, unsigned int &amp;firstGroup) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the gene group assigned to each parameter.  <a href="#ae34c8b65496994cce5b6b73748d3a2b9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00063.html#ac9a022b49d583e8ae81e4d96e50cc9d8">BeginOptimization</a> (const bool allowApproximations=false, const bool enableRestraints=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This should be called by any optimization class at the begining of an optimization.  <a href="#ac9a022b49d583e8ae81e4d96e50cc9d8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const CrystVector_REAL &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00063.html#a871e01608feb73589bb27f4375194630">GetPowderPatternCalcVariance</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the variance associated to each point of the calculated powder pattern, for this component.  <a href="#a871e01608feb73589bb27f4375194630"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual pair&lt; const <br class="typebreak"/>
CrystVector_REAL *, const <br class="typebreak"/>
<a class="el" href="a00072.html">RefinableObjClock</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00063.html#a48d8a351e2fcb8428a9af36c6a4fbf0f">GetPowderPatternIntegratedCalcVariance</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the variance associated to each point of the calculated powder pattern, for this component (integrated version).  <a href="#a48d8a351e2fcb8428a9af36c6a4fbf0f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abae616675aa5f8cf66eb0b788aedb43d"></a><!-- doxytag: member="ObjCryst::PowderPatternBackground::HasPowderPatternCalcVariance" ref="abae616675aa5f8cf66eb0b788aedb43d" args="() const " -->
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00063.html#abae616675aa5f8cf66eb0b788aedb43d">HasPowderPatternCalcVariance</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Does this component have a variance associated with each calculated point ? i.e., do we use maximum likelihood to take into account incomplete models ? <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00063.html#af1a8228087bafd3c3ae0830b3d94df2a">TagNewBestConfig</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">During a global optimization, tells the object that the current config is the latest "best" config.  <a href="#af1a8228087bafd3c3ae0830b3d94df2a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00063.html#a0735ae2350ebce9320ebc2fd16dd94be">OptimizeBayesianBackground</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Optimize the background using a Bayesian approach.  <a href="#a0735ae2350ebce9320ebc2fd16dd94be"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00063.html#a874e0bed05f17df53ad6ddd3df989dc9">FixParametersBeyondMaxresolution</a> (<a class="el" href="a00071.html">RefinableObj</a> &amp;obj)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fix parameters corresponding to points of the pattern that are not actually calculated.  <a href="#a874e0bed05f17df53ad6ddd3df989dc9"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00063.html#a563a5021d4d1dbbf7d5cec58f524c60a">CalcPowderPattern</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calc the powder pattern.  <a href="#a563a5021d4d1dbbf7d5cec58f524c60a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00063.html#af486465f3fa318d9d7737fb1347d0649">CalcPowderPatternIntegrated</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calc the integrated powder pattern.  <a href="#af486465f3fa318d9d7737fb1347d0649"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00063.html#aac7d53c229cd59c2c9d4c5de539a60e1">Prepare</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const CrystVector_long &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00063.html#a348238a43c30b1601eaa1c30503b56e2">GetBraggLimits</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the pixel positions separating the integration intervals around reflections.  <a href="#a348238a43c30b1601eaa1c30503b56e2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00063.html#a6c6c5f75dc132609ba822337123edd1d">SetMaxSinThetaOvLambda</a> (const REAL max)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the maximum value for sin(theta)/lambda.  <a href="#a6c6c5f75dc132609ba822337123edd1d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5ec5ac4fd9ac7247fdb29c1b40e4369b"></a><!-- doxytag: member="ObjCryst::PowderPatternBackground::InitRefParList" ref="a5ec5ac4fd9ac7247fdb29c1b40e4369b" args="()" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>InitRefParList</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9546d8c2c1de47d8eea570f20ab45bcb"></a><!-- doxytag: member="ObjCryst::PowderPatternBackground::InitOptions" ref="a9546d8c2c1de47d8eea570f20ab45bcb" args="()" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>InitOptions</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af795f71db9fadac9c6c142d9af6c8dcc"></a><!-- doxytag: member="ObjCryst::PowderPatternBackground::InitSpline" ref="af795f71db9fadac9c6c142d9af6c8dcc" args="() const " -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>InitSpline</b> () const </td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1b41334ecbbbe337121f6041b7068e99"></a><!-- doxytag: member="ObjCryst::PowderPatternBackground::mBackgroundNbPoint" ref="a1b41334ecbbbe337121f6041b7068e99" args="" -->
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00063.html#a1b41334ecbbbe337121f6041b7068e99">mBackgroundNbPoint</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of fitting points for background. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a68740ba9e8c4348e2a6b2d96024436eb"></a><!-- doxytag: member="ObjCryst::PowderPatternBackground::mBackgroundInterpPointX" ref="a68740ba9e8c4348e2a6b2d96024436eb" args="" -->
CrystVector_REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00063.html#a68740ba9e8c4348e2a6b2d96024436eb">mBackgroundInterpPointX</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of 2theta values for the fitting points of the background. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a942a33452d66e00cd155743a9c8c21e2"></a><!-- doxytag: member="ObjCryst::PowderPatternBackground::mBackgroundInterpPointIntensity" ref="a942a33452d66e00cd155743a9c8c21e2" args="" -->
CrystVector_REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00063.html#a942a33452d66e00cd155743a9c8c21e2">mBackgroundInterpPointIntensity</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Values of background at interpolating points. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CrystVector_long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00063.html#a1280a4f46ff6ba37182878507fab21f4">mPointOrder</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscript of the points, sorted the correct order, taking into account the type of radiation (monochromatic/TOF).  <a href="#a1280a4f46ff6ba37182878507fab21f4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CrystVector_REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00063.html#a16f3af868232f0bbe8c4884ec1676518">mvSplinePixel</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of pixel values between each interval, for faster <a class="el" href="a00025.html" title="Cubic spline interpolation.">CubicSpline</a> calculations.  <a href="#a16f3af868232f0bbe8c4884ec1676518"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00025.html">CubicSpline</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00063.html#a671b5004d363af3cd7efbe97b488ac33">mvSpline</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Spline used for interpolation.  <a href="#a671b5004d363af3cd7efbe97b488ac33"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae26867d298bf99ee07d196b5636a144f"></a><!-- doxytag: member="ObjCryst::PowderPatternBackground::mClockBackgroundPoint" ref="ae26867d298bf99ee07d196b5636a144f" args="" -->
<a class="el" href="a00072.html">RefinableObjClock</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00063.html#ae26867d298bf99ee07d196b5636a144f">mClockBackgroundPoint</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Modification of the interpolated points. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af2988bbeae93a4ebe62161bfb136a859"></a><!-- doxytag: member="ObjCryst::PowderPatternBackground::mClockSpline" ref="af2988bbeae93a4ebe62161bfb136a859" args="" -->
<a class="el" href="a00072.html">RefinableObjClock</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00063.html#af2988bbeae93a4ebe62161bfb136a859">mClockSpline</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialization of the spline. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00063.html#aca05bc94a86a737d8b744704478c2c24">mMaxSinThetaOvLambda</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum sin(theta)/lambda for all calculations (10 by default).  <a href="#aca05bc94a86a737d8b744704478c2c24"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afb62b2f85e9bab627f14265830d1ff09"></a><!-- doxytag: member="ObjCryst::PowderPatternBackground::mModelVariance" ref="afb62b2f85e9bab627f14265830d1ff09" args="" -->
REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00063.html#afb62b2f85e9bab627f14265830d1ff09">mModelVariance</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant error (sigma) on the calculated pattern, due to an incomplete model. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8dcbfb135b47ce820d7a6500818c84fd"></a><!-- doxytag: member="ObjCryst::PowderPatternBackground::mInterpolationModel" ref="a8dcbfb135b47ce820d7a6500818c84fd" args="" -->
<a class="el" href="a00078.html">RefObjOpt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00063.html#a8dcbfb135b47ce820d7a6500818c84fd">mInterpolationModel</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of interpolation performed: linear or cubic spline. <br/></td></tr>
<tr><td colspan="2"><h2><a name="friends"></a>
Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7b7565a5c419f2d4753446ff094a44cb"></a><!-- doxytag: member="ObjCryst::PowderPatternBackground::PowderPattern" ref="a7b7565a5c419f2d4753446ff094a44cb" args="" -->
class&#160;</td><td class="memItemRight" valign="bottom"><b>PowderPattern</b></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Phase to compute a background contribution to a powder pattern using an interpolation. </p>
<p>Currently only linear interpolation is available. (in the works: cubic spline interpolation background) </p>
</div><hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ac9a022b49d583e8ae81e4d96e50cc9d8"></a><!-- doxytag: member="ObjCryst::PowderPatternBackground::BeginOptimization" ref="ac9a022b49d583e8ae81e4d96e50cc9d8" args="(const bool allowApproximations=false, const bool enableRestraints=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="a00063.html#ac9a022b49d583e8ae81e4d96e50cc9d8">ObjCryst::PowderPatternBackground::BeginOptimization</a> </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>allowApproximations</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>enableRestraints</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This should be called by any optimization class at the begining of an optimization. </p>
<p>This will also check that everything is ready, eg call the <a class="el" href="a00071.html#a48d11671e7f8699f7bc24077585c5e0f">RefinableObj::Prepare()</a> function. This also affects all sub-objects. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>this may be called several time for some objects which are used by several other objects, or for nested optimizations (e.g. least-squares optimizations inside a global one).</dd>
<dd>
<a class="el" href="a00071.html#ab0035f6164cb24ace67b51b11993a851" title="This should be called by any optimization class at the end of an optimization.">EndOptimization()</a> must be called at the end of the optimization, the same number of time <a class="el" href="a00063.html#ac9a022b49d583e8ae81e4d96e50cc9d8" title="This should be called by any optimization class at the begining of an optimization.">BeginOptimization()</a> was called !</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">allowApproximations,:</td><td>if true, then the object can use faster but less precise functions during the optimization. This is useful for global optimization not using derivatives. </td></tr>
    <tr><td class="paramname">enableRestraints:\xrefitem</td><td>deprecated 28. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="a00071.html#ababd8f2916e41a20d2c1b21f6ffefe96">ObjCryst::RefinableObj</a>.</p>

</div>
</div>
<a class="anchor" id="a563a5021d4d1dbbf7d5cec58f524c60a"></a><!-- doxytag: member="ObjCryst::PowderPatternBackground::CalcPowderPattern" ref="a563a5021d4d1dbbf7d5cec58f524c60a" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="a00063.html#a563a5021d4d1dbbf7d5cec58f524c60a">ObjCryst::PowderPatternBackground::CalcPowderPattern</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calc the powder pattern. </p>
<p>As always, recomputation is only done if necessary (ie if a parameter has changed since the last computation) </p>

<p>Implements <a class="el" href="a00065.html#a8417ecb93009a9b7b9fccf074a9438d9">ObjCryst::PowderPatternComponent</a>.</p>

</div>
</div>
<a class="anchor" id="af486465f3fa318d9d7737fb1347d0649"></a><!-- doxytag: member="ObjCryst::PowderPatternBackground::CalcPowderPatternIntegrated" ref="af486465f3fa318d9d7737fb1347d0649" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="a00063.html#af486465f3fa318d9d7737fb1347d0649">ObjCryst::PowderPatternBackground::CalcPowderPatternIntegrated</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calc the integrated powder pattern. </p>
<p>This should be optimized so that the full powder pattern is not explicitely computed. </p>

<p>Implements <a class="el" href="a00065.html#a24c4fb58e500cd669f3298475a31f72f">ObjCryst::PowderPatternComponent</a>.</p>

</div>
</div>
<a class="anchor" id="a874e0bed05f17df53ad6ddd3df989dc9"></a><!-- doxytag: member="ObjCryst::PowderPatternBackground::FixParametersBeyondMaxresolution" ref="a874e0bed05f17df53ad6ddd3df989dc9" args="(RefinableObj &amp;obj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00063.html#a874e0bed05f17df53ad6ddd3df989dc9">ObjCryst::PowderPatternBackground::FixParametersBeyondMaxresolution</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00071.html">RefinableObj</a> &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fix parameters corresponding to points of the pattern that are not actually calculated. </p>
<p>This is necessary for modelling using splines, to avoid divergence of interpolation points during least squares optimization.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">obj,:</td><td>the object in which are parameters to be fixed. Normally this will be the <a class="el" href="a00063.html" title="Phase to compute a background contribution to a powder pattern using an interpolation.">PowderPatternBackground</a> object itself, but it can also be the parameter list copied such as in a <a class="el" href="a00039.html" title="(Quick &amp; dirty) Least-Squares Refinement Object with Numerical derivatives">LSQNumObj</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a348238a43c30b1601eaa1c30503b56e2"></a><!-- doxytag: member="ObjCryst::PowderPatternBackground::GetBraggLimits" ref="a348238a43c30b1601eaa1c30503b56e2" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const CrystVector_long&amp; <a class="el" href="a00063.html#a348238a43c30b1601eaa1c30503b56e2">ObjCryst::PowderPatternBackground::GetBraggLimits</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the pixel positions separating the integration intervals around reflections. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>: an array with the pixel positions, empty if this component has no peaks. The positions should be in increasing order, but could go beyond the pattern limits. </dd></dl>

<p>Implements <a class="el" href="a00065.html#a727488f859528b0a9b5da47973804e01">ObjCryst::PowderPatternComponent</a>.</p>

</div>
</div>
<a class="anchor" id="afae084513270b7adf50954bec4037380"></a><!-- doxytag: member="ObjCryst::PowderPatternBackground::GetClassName" ref="afae084513270b7adf50954bec4037380" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const string&amp; <a class="el" href="a00063.html#afae084513270b7adf50954bec4037380">ObjCryst::PowderPatternBackground::GetClassName</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Name for this class ("RefinableObj", "Crystal",...). </p>
<p>This is only useful to distinguish different classes when picking up objects from the <a class="el" href="a00071.html" title="Generic Refinable Object.">RefinableObj</a> Global Registry </p>

<p>Reimplemented from <a class="el" href="a00065.html#a5e797476d8d76ef797e1e8b51db9e8fb">ObjCryst::PowderPatternComponent</a>.</p>

</div>
</div>
<a class="anchor" id="ae34c8b65496994cce5b6b73748d3a2b9"></a><!-- doxytag: member="ObjCryst::PowderPatternBackground::GetGeneGroup" ref="ae34c8b65496994cce5b6b73748d3a2b9" args="(const RefinableObj &amp;obj, CrystVector_uint &amp;groupIndex, unsigned int &amp;firstGroup) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="a00063.html#ae34c8b65496994cce5b6b73748d3a2b9">ObjCryst::PowderPatternBackground::GetGeneGroup</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00071.html">RefinableObj</a> &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CrystVector_uint &amp;&#160;</td>
          <td class="paramname"><em>groupIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>firstGroup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the gene group assigned to each parameter. </p>
<p>Each parameter (a <em>gene</em> in terms of genetic algorithms) can be assigned to a gene group. Thus when mating two configurations, genes will be exchanged by groups. By default (in the base RefinabeObj class), each parameter is alone in its group. Derived classes can group genes for a better s** life.</p>
<p>The number identifying a gene group only has a meaning in a given object. It can also change on subsequent calls, and thus is not unique.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>the , supplied by an algorithm class (<a class="el" href="a00055.html" title="Base object for Optimization methods.">OptimizationObj</a>,..), which contains a list of parameters, some of which (but possibly all or none) are parameters belonging to this object. </td></tr>
    <tr><td class="paramname">groupIndex</td><td>a vector of unsigned integers, one for each parameter in the input object, giving an unsigned integer value as gene group index. At the beginning this vector should contain only zeros (no group assigned). </td></tr>
    <tr><td class="paramname">firstGroup</td><td>this is the number of groups which have already been assigned, plus one. The gene groups returned by this object will start from this value, and increment <b>firstGroup</b> for each gene group used, so that different <a class="el" href="a00071.html" title="Generic Refinable Object.">RefinableObj</a> cannot share a gene group. </td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>this function is not optimized, and should only be called at the beginning of a refinement. </dd></dl>

<p>Reimplemented from <a class="el" href="a00071.html#ad59c8ad2b0d7ee59fa3f399a54f05e54">ObjCryst::RefinableObj</a>.</p>

</div>
</div>
<a class="anchor" id="adb37c0a9b8e41e6dc11e6a9718c89bf5"></a><!-- doxytag: member="ObjCryst::PowderPatternBackground::GetPowderPatternCalc" ref="adb37c0a9b8e41e6dc11e6a9718c89bf5" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const CrystVector_REAL&amp; <a class="el" href="a00063.html#adb37c0a9b8e41e6dc11e6a9718c89bf5">ObjCryst::PowderPatternBackground::GetPowderPatternCalc</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the calculated powder pattern for this component. </p>
<p>Note that the pattern is <em>not</em> scaled. </p>

<p>Implements <a class="el" href="a00065.html#a45258e9f9b44ff019bf53aa3dfb1a305">ObjCryst::PowderPatternComponent</a>.</p>

</div>
</div>
<a class="anchor" id="a871e01608feb73589bb27f4375194630"></a><!-- doxytag: member="ObjCryst::PowderPatternBackground::GetPowderPatternCalcVariance" ref="a871e01608feb73589bb27f4375194630" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const CrystVector_REAL&amp; <a class="el" href="a00063.html#a871e01608feb73589bb27f4375194630">ObjCryst::PowderPatternBackground::GetPowderPatternCalcVariance</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the variance associated to each point of the calculated powder pattern, for this component. </p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>: this is experimental, with the aim of using Maximum Likelihood to improve structure determination. </dd></dl>

<p>Implements <a class="el" href="a00065.html#ad67b39669fd0d336b01937ee81a59ddc">ObjCryst::PowderPatternComponent</a>.</p>

</div>
</div>
<a class="anchor" id="a5bc997017cf1d95641b44021175c3dad"></a><!-- doxytag: member="ObjCryst::PowderPatternBackground::GetPowderPatternIntegratedCalc" ref="a5bc997017cf1d95641b44021175c3dad" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual pair&lt;const CrystVector_REAL*,const <a class="el" href="a00072.html">RefinableObjClock</a>*&gt; <a class="el" href="a00063.html#a5bc997017cf1d95641b44021175c3dad">ObjCryst::PowderPatternBackground::GetPowderPatternIntegratedCalc</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the integrated values of the powder pattern. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>: the integration intervals are those given by the parent <a class="el" href="a00062.html" title="Powder pattern class, with an observed pattern and several calculated components to modelize the patt...">PowderPattern</a>, so that all <a class="el" href="a00065.html" title="Generic class to compute components (eg the contribution of a given phase, or background) of a powder...">PowderPatternComponent</a>'s intervals are taken into account</dd></dl>
<p>This avoids explicitely calculating the full profile powder pattern. </p>

<p>Implements <a class="el" href="a00065.html#ac54b7ae5a177492de681afc2cbed72eb">ObjCryst::PowderPatternComponent</a>.</p>

</div>
</div>
<a class="anchor" id="a48d8a351e2fcb8428a9af36c6a4fbf0f"></a><!-- doxytag: member="ObjCryst::PowderPatternBackground::GetPowderPatternIntegratedCalcVariance" ref="a48d8a351e2fcb8428a9af36c6a4fbf0f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual pair&lt;const CrystVector_REAL*,const <a class="el" href="a00072.html">RefinableObjClock</a>*&gt; <a class="el" href="a00063.html#a48d8a351e2fcb8428a9af36c6a4fbf0f">ObjCryst::PowderPatternBackground::GetPowderPatternIntegratedCalcVariance</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the variance associated to each point of the calculated powder pattern, for this component (integrated version). </p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>: this is experimental, with the aim of using Maximum Likelihood to improve structure determination. </dd></dl>

<p>Implements <a class="el" href="a00065.html#ae721bd290b50aa9503bac419616a21c6">ObjCryst::PowderPatternComponent</a>.</p>

</div>
</div>
<a class="anchor" id="a0735ae2350ebce9320ebc2fd16dd94be"></a><!-- doxytag: member="ObjCryst::PowderPatternBackground::OptimizeBayesianBackground" ref="a0735ae2350ebce9320ebc2fd16dd94be" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00063.html#a0735ae2350ebce9320ebc2fd16dd94be">ObjCryst::PowderPatternBackground::OptimizeBayesianBackground</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Optimize the background using a Bayesian approach. </p>
<p>The background parameters must be un-fixed before.</p>
<p>The minimization will a maximum of 50 Simplex runs (see the <a class="el" href="a00093.html" title="Conjugate Gradient Algorithm object.">SimplexObj</a> documentation), each with 200 cycles.</p>
<p>See the class documentation for <a class="el" href="a00064.html" title="This object is used to estimate the background in a powder pattern, using a Bayesian approach (David ...">PowderPatternBackgroundBayesianMinimiser</a>. </p>

</div>
</div>
<a class="anchor" id="aac7d53c229cd59c2c9d4c5de539a60e1"></a><!-- doxytag: member="ObjCryst::PowderPatternBackground::Prepare" ref="aac7d53c229cd59c2c9d4c5de539a60e1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="a00063.html#aac7d53c229cd59c2c9d4c5de539a60e1">ObjCryst::PowderPatternBackground::Prepare</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This will be called by the parent <a class="el" href="a00062.html" title="Powder pattern class, with an observed pattern and several calculated components to modelize the patt...">PowderPattern</a> object, before calculating the first powder pattern. Or maybe it should be called automatically by the object itself... </p>

<p>Implements <a class="el" href="a00065.html#a6a99877f0f9dec09fd5f596a7ddeb6f6">ObjCryst::PowderPatternComponent</a>.</p>

</div>
</div>
<a class="anchor" id="a6c6c5f75dc132609ba822337123edd1d"></a><!-- doxytag: member="ObjCryst::PowderPatternBackground::SetMaxSinThetaOvLambda" ref="a6c6c5f75dc132609ba822337123edd1d" args="(const REAL max)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="a00063.html#a6c6c5f75dc132609ba822337123edd1d">ObjCryst::PowderPatternBackground::SetMaxSinThetaOvLambda</a> </td>
          <td>(</td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>max</em></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the maximum value for sin(theta)/lambda. </p>
<p>All data above still exist but are ignored for all calculations. </p>

<p>Implements <a class="el" href="a00065.html#a4731b5a64ee9aab6779e2ef323242fe5">ObjCryst::PowderPatternComponent</a>.</p>

</div>
</div>
<a class="anchor" id="a02032467fb6485e05f0a1bbf74133833"></a><!-- doxytag: member="ObjCryst::PowderPatternBackground::SetParentPowderPattern" ref="a02032467fb6485e05f0a1bbf74133833" args="(PowderPattern &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="a00063.html#a02032467fb6485e05f0a1bbf74133833">ObjCryst::PowderPatternBackground::SetParentPowderPattern</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00062.html">PowderPattern</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the <a class="el" href="a00062.html" title="Powder pattern class, with an observed pattern and several calculated components to modelize the patt...">PowderPattern</a> object which uses this component. </p>
<p>This sets all necessary pattern parameters (2theta/tof range, wavelength, radiation type...) accordingly. </p>

<p>Implements <a class="el" href="a00065.html#a6b3dc911118c280dbbdcb7fb97acf980">ObjCryst::PowderPatternComponent</a>.</p>

</div>
</div>
<a class="anchor" id="af1a8228087bafd3c3ae0830b3d94df2a"></a><!-- doxytag: member="ObjCryst::PowderPatternBackground::TagNewBestConfig" ref="af1a8228087bafd3c3ae0830b3d94df2a" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="a00063.html#af1a8228087bafd3c3ae0830b3d94df2a">ObjCryst::PowderPatternBackground::TagNewBestConfig</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>During a global optimization, tells the object that the current config is the latest "best" config. </p>
<p>This can be used by the object to make more intellingent random moves (use with caution: highly experimental !). </p>

<p>Reimplemented from <a class="el" href="a00071.html#a3cb4cc924d39576618184eccd4321cf6">ObjCryst::RefinableObj</a>.</p>

</div>
</div>
<a class="anchor" id="a7747e4a20056c4756943319bc8ffba8d"></a><!-- doxytag: member="ObjCryst::PowderPatternBackground::XMLInput" ref="a7747e4a20056c4756943319bc8ffba8d" args="(istream &amp;is, const XMLCrystTag &amp;tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="a00063.html#a7747e4a20056c4756943319bc8ffba8d">ObjCryst::PowderPatternBackground::XMLInput</a> </td>
          <td>(</td>
          <td class="paramtype">istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00151.html">XMLCrystTag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Input From stream. </p>
<dl class="todo"><dt><b><a class="el" href="a00222.html#_todo000027">Todo:</a></b></dt><dd>Add an bool XMLInputTag(is,tag) function to recognize all the tags from the stream. So that each inherited class can use the XMLInputTag function from its parent (ie take advantage of inheritance). The children class would first try to interpret the tag, then if unsuccessful would pass it to its parent (thus allowing overloading), etc... </dd></dl>

<p>Reimplemented from <a class="el" href="a00071.html#ac13a4045c3f187879443c8615c38d623">ObjCryst::RefinableObj</a>.</p>

</div>
</div>
<a class="anchor" id="a41f59111f35f92d0c3b99942606b234e"></a><!-- doxytag: member="ObjCryst::PowderPatternBackground::XMLOutput" ref="a41f59111f35f92d0c3b99942606b234e" args="(ostream &amp;os, int indent=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="a00063.html#a41f59111f35f92d0c3b99942606b234e">ObjCryst::PowderPatternBackground::XMLOutput</a> </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>indent</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Output to stream in well-formed XML. </p>
<dl class="todo"><dt><b><a class="el" href="a00222.html#_todo000026">Todo:</a></b></dt><dd>Use inheritance.. as for XMLInputTag()... </dd></dl>

<p>Reimplemented from <a class="el" href="a00071.html#a7b9b6ed0f8dcf753d398c35e073de973">ObjCryst::RefinableObj</a>.</p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="aca05bc94a86a737d8b744704478c2c24"></a><!-- doxytag: member="ObjCryst::PowderPatternBackground::mMaxSinThetaOvLambda" ref="aca05bc94a86a737d8b744704478c2c24" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">REAL <a class="el" href="a00063.html#aca05bc94a86a737d8b744704478c2c24">ObjCryst::PowderPatternBackground::mMaxSinThetaOvLambda</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Maximum sin(theta)/lambda for all calculations (10 by default). </p>
<p>This keeps all data in memory, but only the part which is below the max is calculated. </p>

</div>
</div>
<a class="anchor" id="a1280a4f46ff6ba37182878507fab21f4"></a><!-- doxytag: member="ObjCryst::PowderPatternBackground::mPointOrder" ref="a1280a4f46ff6ba37182878507fab21f4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CrystVector_long <a class="el" href="a00063.html#a1280a4f46ff6ba37182878507fab21f4">ObjCryst::PowderPatternBackground::mPointOrder</a><code> [mutable, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Subscript of the points, sorted the correct order, taking into account the type of radiation (monochromatic/TOF). </p>

</div>
</div>
<a class="anchor" id="a671b5004d363af3cd7efbe97b488ac33"></a><!-- doxytag: member="ObjCryst::PowderPatternBackground::mvSpline" ref="a671b5004d363af3cd7efbe97b488ac33" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00025.html">CubicSpline</a> <a class="el" href="a00063.html#a671b5004d363af3cd7efbe97b488ac33">ObjCryst::PowderPatternBackground::mvSpline</a><code> [mutable, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Spline used for interpolation. </p>
<p>Mutable since it copies information from mBackgroundInterpPointX and mBackgroundInterpPointIntensity. </p>

</div>
</div>
<a class="anchor" id="a16f3af868232f0bbe8c4884ec1676518"></a><!-- doxytag: member="ObjCryst::PowderPatternBackground::mvSplinePixel" ref="a16f3af868232f0bbe8c4884ec1676518" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CrystVector_REAL <a class="el" href="a00063.html#a16f3af868232f0bbe8c4884ec1676518">ObjCryst::PowderPatternBackground::mvSplinePixel</a><code> [mutable, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Vector of pixel values between each interval, for faster <a class="el" href="a00025.html" title="Cubic spline interpolation.">CubicSpline</a> calculations. </p>
<p>Mutable since it copies information from mBackgroundInterpPointX. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>PowderPattern.h</li>
</ul>
</div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Sat Jan 28 2012 12:38:55 for ObjCryst++ by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
