<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>ObjCryst++: The Design of ObjCryst++</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.2-20100208 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">


<h1><a class="anchor" id="page_design">The Design of ObjCryst++ </a></h1><p>If you have any comment or suggestion about this you can <a href="mailto:vincefn@users.sourceforge.net">drop me an email</a>.</p>
<p>Also read <a class="el" href="a00003.html">Why is Object Oriented Programming good for Crystallographic Computing ?</a>.</p>
<h2><a class="anchor" id="overview">
Overview of the Library (Crystallographic classes)</a></h2>
<dl class="user"><dt><b>Scatterer</b></dt><dd>A Scatterer is the common denominator for any scattering object: all it includes is a function which gives a list of positions in fractional coordinates, with a scattering power associated to each position (Scatterer::GetScatteringComponentList()). It also includes a few functions for the display (3D) of the object. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>All Scatterer can be derived from such a class: Atom, ZScatterer. The advantage of using inheritance is that all derived classes <b>must</b> re-use the functions declared in the base class, so that <em>any</em> function which knows what a generic 'Scatterer' object (but does not know what an Atom or ZScatterer is) can still use any derived class. </dd></dl>
<dl class="user"><dt><b></b></dt><dd><em>Further</em> <em>development</em> <em>example:</em> currently there is no 'rigid body' object: if any developper wants to create such an object, he just needs to make sure he rewrites the function GetScatteringComponentList(). Thus without any modification, the Crystal and ScatteringData classes will automatically be able to use this new object... since this RigidBody object is derived from the Scatterer class (which Crystal and ScatteringData know).</dd></dl>
<dl class="user"><dt><b>ScatteringPower</b></dt><dd>This class can compute the scattering, resonant and thermic factor for any ScatteringData object (eg a list of reflections with some metric information). The three member function GetScatteringFactor(), GetTemperatureFactor(),GetResonantScattFactReal(), and GetResonantScattFactImag() can be used to get the corresponding factors for a list of reflections (and wavelengths for resonant terms) in a ScatteringData object. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The base class is designed to handle anisotropic factors: for this the index of the symetric position in the Spacegroup must be given. </dd></dl>
<dl class="user"><dt><b></b></dt><dd><em>Further</em> <em>development</em> <em>example:</em> currently only the interface to handle anisotropy has been written, but no code or derived class. But no matter what kind of anisotropy is added, it will always work with the base class interface. </dd></dl>
<dl class="user"><dt><b></b></dt><dd><em>Note:</em> why always use a ScatteringData object as input (to compute scattering factors, for example), rather than, say, a list of HKL or a list of sin(theta/lambda) ? The first reason is that from a ScatteringData you can extract all these hkl's and sin(theta)/lambda. The second reason is that with such an approach, no matter how complex the derived classes are, you can always use the same interface (for isotropic thermic factors as well as anharmonic !), so that any function written with only the knowledge of the base class can use any derived class.</dd></dl>
<dl class="user"><dt><b>Crystal</b></dt><dd>a Crystal is a unit cell with an associated SpaceGroup with a list of Scatterer.</dd></dl>
<dl class="user"><dt><b>ScatteringData</b></dt><dd>The ScatteringData is a base class which is basically a list of reflections with the ability to compute structure factors. The DiffractionDataSingleCrystal and PowderPatternDiffraction classes are derived from it.</dd></dl>
<h2><a class="anchor" id="optim">
Optimization design</a></h2>
<dl class="user"><dt><b>RefinableObj</b></dt><dd>The RefinableObj is the base class for almost all objects in the library. The advantage of such a design (see the inheritance tree on the <a class="el" href="a00070.html" title="Generic Refinable Object.">ObjCryst::RefinableObj</a> page) is that when you design an algorithm, you do not need to know what kind of object is refined. All you need to know is (i) how many parameters there are (ii) how to move these parameters (iii) how to access one or several 'cost function' for the optimized object (to characterize 'how good' the current configuration is). Indeed, the global optimization class (for simulated annealing and parallel tempering) does not include any of the crystallographic headers, and yet it can refine the crystal structures... </dd></dl>
<dl class="user"><dt><b></b></dt><dd>This design does not mean that only 'stupid' algorithms can be handled. Since the 'random moves' are handled by the refined objects, this 'random moves' can be very non-random (for example in the Crystal object, permutation of Scatterers is made from time to time...). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>What if you are <em>not</em> interested in the RefinableObj functionnality ? You can simply ignore it, it will not do any harm. You can do other crystallographic work by 'forgetting' that a Crystal, PowderPattern, Atom is a RefinableObj. Even new derived objects do not have to declare their parameters as 'RefinablePar', if you want to save some memory. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>what is currently lacking in RefinableObj is (i) a way to set constraints/restraints (currently there are only limits for individual parameters), the ability to have arrays of RefinablePar (to handle large structure without a significant memory penalty), and a design for analytical derivatives (well I've got a few ideas about this but this is not a priority yet...). </dd></dl>
</div>
<hr class="footer"/><address style="text-align: right;"><small>Generated by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2-20100208 </small></address>
</body>
</html>
