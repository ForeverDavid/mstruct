<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>ObjCryst++: ObjCryst::SpaceGroup Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">ObjCryst++
   &#160;<span id="projectnumber">1.5CVS</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="a00178.html">ObjCryst</a></li><li class="navelem"><a class="el" href="a00102.html">SpaceGroup</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="a00312.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ObjCryst::SpaceGroup Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The crystallographic space group, and the cell choice.  
 <a href="a00102.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00101.html">SMx</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct to store rot+trans matrix.  <a href="a00101.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00116.html">TRx</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct to store trans matrix.  <a href="a00116.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5f5f5b814480e6ab109c22926cc359ca"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00102.html#a5f5f5b814480e6ab109c22926cc359ca">SpaceGroup</a> ()</td></tr>
<tr class="memdesc:a5f5f5b814480e6ab109c22926cc359ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default Constructor (initializes in P1)  <a href="#a5f5f5b814480e6ab109c22926cc359ca">More...</a><br/></td></tr>
<tr class="separator:a5f5f5b814480e6ab109c22926cc359ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5db1daaae23fab45637555f74c705b3e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00102.html#a5db1daaae23fab45637555f74c705b3e">SpaceGroup</a> (const string &amp;spgId)</td></tr>
<tr class="memdesc:a5db1daaae23fab45637555f74c705b3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor with a specified spacegroup symbol or number.  <a href="#a5db1daaae23fab45637555f74c705b3e">More...</a><br/></td></tr>
<tr class="separator:a5db1daaae23fab45637555f74c705b3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dfc390a5e455426c323ee7a8d6ced10"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9dfc390a5e455426c323ee7a8d6ced10"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00102.html#a9dfc390a5e455426c323ee7a8d6ced10">~SpaceGroup</a> ()</td></tr>
<tr class="memdesc:a9dfc390a5e455426c323ee7a8d6ced10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br/></td></tr>
<tr class="separator:a9dfc390a5e455426c323ee7a8d6ced10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af592aa42f04d02e4caecbf2b93031be8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af592aa42f04d02e4caecbf2b93031be8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00102.html#af592aa42f04d02e4caecbf2b93031be8">ChangeSpaceGroup</a> (const string &amp;spgId)</td></tr>
<tr class="memdesc:af592aa42f04d02e4caecbf2b93031be8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the Spacegroup. <br/></td></tr>
<tr class="separator:af592aa42f04d02e4caecbf2b93031be8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a633e6ba97400f7b4f7d3887c94dce2c0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a633e6ba97400f7b4f7d3887c94dce2c0"></a>
const string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00102.html#a633e6ba97400f7b4f7d3887c94dce2c0">GetName</a> () const </td></tr>
<tr class="memdesc:a633e6ba97400f7b4f7d3887c94dce2c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of this spacegroup (its name, as supplied initially by the calling program or user) <br/></td></tr>
<tr class="separator:a633e6ba97400f7b4f7d3887c94dce2c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accd8f865d9cbb12e420a6737fe50bc06"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="accd8f865d9cbb12e420a6737fe50bc06"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00102.html#accd8f865d9cbb12e420a6737fe50bc06">IsInAsymmetricUnit</a> (const REAL x, const REAL y, const REAL z) const </td></tr>
<tr class="memdesc:accd8f865d9cbb12e420a6737fe50bc06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if a given scatterer at (x,y,z) is in the asymmetric unit. <br/></td></tr>
<tr class="separator:accd8f865d9cbb12e420a6737fe50bc06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc3c511d36ad707690ca4f9c0154a8a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00102.html#adc3c511d36ad707690ca4f9c0154a8a0">ChangeToAsymmetricUnit</a> (REAL x, REAL y, REAL z) const </td></tr>
<tr class="memdesc:adc3c511d36ad707690ca4f9c0154a8a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move (x,y,z) coordinates to their equivalent in the asym unit.  <a href="#adc3c511d36ad707690ca4f9c0154a8a0">More...</a><br/></td></tr>
<tr class="separator:adc3c511d36ad707690ca4f9c0154a8a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf14567efef1b6031df146a3f8b7b9a2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaf14567efef1b6031df146a3f8b7b9a2"></a>
const <a class="el" href="a00014.html">AsymmetricUnit</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00102.html#aaf14567efef1b6031df146a3f8b7b9a2">GetAsymUnit</a> () const </td></tr>
<tr class="memdesc:aaf14567efef1b6031df146a3f8b7b9a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="a00014.html" title="The basic description of spacegroup asymmetric unit. ">AsymmetricUnit</a> for this spacegroup. <br/></td></tr>
<tr class="separator:aaf14567efef1b6031df146a3f8b7b9a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add04f45fac118cc9c235a6a6270d12c7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="add04f45fac118cc9c235a6a6270d12c7"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00102.html#add04f45fac118cc9c235a6a6270d12c7">GetSpaceGroupNumber</a> () const </td></tr>
<tr class="memdesc:add04f45fac118cc9c235a6a6270d12c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Id number of the spacegroup. <br/></td></tr>
<tr class="separator:add04f45fac118cc9c235a6a6270d12c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f2bc9f6351fcde894338cad26d5617e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0f2bc9f6351fcde894338cad26d5617e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00102.html#a0f2bc9f6351fcde894338cad26d5617e">IsCentrosymmetric</a> () const </td></tr>
<tr class="memdesc:a0f2bc9f6351fcde894338cad26d5617e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the crystal centrosymmetric ? <br/></td></tr>
<tr class="separator:a0f2bc9f6351fcde894338cad26d5617e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83b6cae3a3b76abc0a25a89cecf43ee1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00102.html#a83b6cae3a3b76abc0a25a89cecf43ee1">GetNbTranslationVectors</a> () const </td></tr>
<tr class="memdesc:a83b6cae3a3b76abc0a25a89cecf43ee1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of translation vectors (1 for 'P' cells, 2 for 'I', 4 for 'F',etc..)  <a href="#a83b6cae3a3b76abc0a25a89cecf43ee1">More...</a><br/></td></tr>
<tr class="separator:a83b6cae3a3b76abc0a25a89cecf43ee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a763a2f9e54363c2134a92beed214bbe2"><td class="memItemLeft" align="right" valign="top">const std::vector<br class="typebreak"/>
&lt; <a class="el" href="a00116.html">SpaceGroup::TRx</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00102.html#a763a2f9e54363c2134a92beed214bbe2">GetTranslationVectors</a> () const </td></tr>
<tr class="memdesc:a763a2f9e54363c2134a92beed214bbe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return all Translation Vectors, as a 3 columns-array.  <a href="#a763a2f9e54363c2134a92beed214bbe2">More...</a><br/></td></tr>
<tr class="separator:a763a2f9e54363c2134a92beed214bbe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c547bc807cc28143b92b0ed4834581e"><td class="memItemLeft" align="right" valign="top">CrystMatrix_REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00102.html#a1c547bc807cc28143b92b0ed4834581e">GetAllSymmetrics</a> (const REAL x, const REAL y, const REAL z, const bool noCenter=false, const bool noTransl=false, const bool noIdentical=false) const </td></tr>
<tr class="memdesc:a1c547bc807cc28143b92b0ed4834581e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all equivalent positions of a (xyz) position.  <a href="#a1c547bc807cc28143b92b0ed4834581e">More...</a><br/></td></tr>
<tr class="separator:a1c547bc807cc28143b92b0ed4834581e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bf3ff968700527947d0a134b8058a85"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00102.html#a1bf3ff968700527947d0a134b8058a85">GetNbSymmetrics</a> (const bool noCenter=false, const bool noTransl=false) const </td></tr>
<tr class="memdesc:a1bf3ff968700527947d0a134b8058a85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of equivalent positions in the spacegroup, ie the multilicity of the general position.  <a href="#a1bf3ff968700527947d0a134b8058a85">More...</a><br/></td></tr>
<tr class="separator:a1bf3ff968700527947d0a134b8058a85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c3746694fb9a6dbe3f258febb858744"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00102.html#a7c3746694fb9a6dbe3f258febb858744">Print</a> () const </td></tr>
<tr class="memdesc:a7c3746694fb9a6dbe3f258febb858744"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints a description of the spacegroup (symbol, properties).  <a href="#a7c3746694fb9a6dbe3f258febb858744">More...</a><br/></td></tr>
<tr class="separator:a7c3746694fb9a6dbe3f258febb858744"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68ea2fc39bfa77cf615c438df4bd9a77"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a68ea2fc39bfa77cf615c438df4bd9a77"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00102.html#a68ea2fc39bfa77cf615c438df4bd9a77">HasInversionCenter</a> () const </td></tr>
<tr class="memdesc:a68ea2fc39bfa77cf615c438df4bd9a77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is centrosymmetric ? <br/></td></tr>
<tr class="separator:a68ea2fc39bfa77cf615c438df4bd9a77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a9e27fc72c881e415c2f56b1ec24d17"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9a9e27fc72c881e415c2f56b1ec24d17"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00102.html#a9a9e27fc72c881e415c2f56b1ec24d17">IsInversionCenterAtOrigin</a> () const </td></tr>
<tr class="memdesc:a9a9e27fc72c881e415c2f56b1ec24d17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the center of symmetry at the origin ? <br/></td></tr>
<tr class="separator:a9a9e27fc72c881e415c2f56b1ec24d17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4b7f4d59b0f85c63f5400771c4ef3b8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad4b7f4d59b0f85c63f5400771c4ef3b8"></a>
const cctbx::sgtbx::space_group &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00102.html#ad4b7f4d59b0f85c63f5400771c4ef3b8">GetCCTbxSpg</a> () const </td></tr>
<tr class="memdesc:ad4b7f4d59b0f85c63f5400771c4ef3b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the underlying cctbx Spacegroup object. <br/></td></tr>
<tr class="separator:ad4b7f4d59b0f85c63f5400771c4ef3b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23a802d400f7a4eddbedc6ba2116a0e5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a23a802d400f7a4eddbedc6ba2116a0e5"></a>
const <a class="el" href="a00079.html">RefinableObjClock</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00102.html#a23a802d400f7a4eddbedc6ba2116a0e5">GetClockSpaceGroup</a> () const </td></tr>
<tr class="memdesc:a23a802d400f7a4eddbedc6ba2116a0e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="a00102.html" title="The crystallographic space group, and the cell choice. ">SpaceGroup</a> Clock (corresponding to the time of the initialization of the <a class="el" href="a00102.html" title="The crystallographic space group, and the cell choice. ">SpaceGroup</a>) <br/></td></tr>
<tr class="separator:a23a802d400f7a4eddbedc6ba2116a0e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6d4d7e6522df61f418005455fff30d0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa6d4d7e6522df61f418005455fff30d0"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00102.html#aa6d4d7e6522df61f418005455fff30d0">GetUniqueAxis</a> () const </td></tr>
<tr class="memdesc:aa6d4d7e6522df61f418005455fff30d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Which is the unique axis (for monoclinic space groups ) <br/></td></tr>
<tr class="separator:aa6d4d7e6522df61f418005455fff30d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a1a325a3722f85549d99c12821269f0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7a1a325a3722f85549d99c12821269f0"></a>
char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00102.html#a7a1a325a3722f85549d99c12821269f0">GetExtension</a> () const </td></tr>
<tr class="memdesc:a7a1a325a3722f85549d99c12821269f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extension to space group symbol ('1','2':origin choice ; 'R','H'=rhomboedral/hexagonal) <br/></td></tr>
<tr class="separator:a7a1a325a3722f85549d99c12821269f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc388337be91c9ae1bee5cc13ffc1aa4"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00102.html#abc388337be91c9ae1bee5cc13ffc1aa4">AreReflEquiv</a> (const REAL h1, const REAL k1, const REAL l1, const REAL h2, const REAL k2, const REAL l2) const </td></tr>
<tr class="memdesc:abc388337be91c9ae1bee5cc13ffc1aa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Are these reflections equivalent ?  <a href="#abc388337be91c9ae1bee5cc13ffc1aa4">More...</a><br/></td></tr>
<tr class="separator:abc388337be91c9ae1bee5cc13ffc1aa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63733aec55c2f6dc07c9d88a56f38238"><td class="memItemLeft" align="right" valign="top">CrystMatrix_REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00102.html#a63733aec55c2f6dc07c9d88a56f38238">GetAllEquivRefl</a> (const REAL h, const REAL k, const REAL l, const bool excludeFriedelMate=false, const bool forceFriedelLaw=false, const REAL sf_re=0, const REAL sf_im=0) const </td></tr>
<tr class="memdesc:a63733aec55c2f6dc07c9d88a56f38238"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the list of all equivalent reflections.  <a href="#a63733aec55c2f6dc07c9d88a56f38238">More...</a><br/></td></tr>
<tr class="separator:a63733aec55c2f6dc07c9d88a56f38238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a913dcf7cca770f37da93e0baf49b93f5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a913dcf7cca770f37da93e0baf49b93f5"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00102.html#a913dcf7cca770f37da93e0baf49b93f5">IsReflSystematicAbsent</a> (const REAL h, const REAL k, const REAL l) const </td></tr>
<tr class="memdesc:a913dcf7cca770f37da93e0baf49b93f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the reflection systematically absent ? <br/></td></tr>
<tr class="separator:a913dcf7cca770f37da93e0baf49b93f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28297c63dbb762b89d6cb63d37fe12b1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a28297c63dbb762b89d6cb63d37fe12b1"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00102.html#a28297c63dbb762b89d6cb63d37fe12b1">IsReflCentric</a> (const REAL h, const REAL k, const REAL l) const </td></tr>
<tr class="memdesc:a28297c63dbb762b89d6cb63d37fe12b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the reflection centric ? <br/></td></tr>
<tr class="separator:a28297c63dbb762b89d6cb63d37fe12b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add3a6c0f649b952225fd7ef07b9e02d7"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00102.html#add3a6c0f649b952225fd7ef07b9e02d7">GetExpectedIntensityFactor</a> (const REAL h, const REAL k, const REAL l) const </td></tr>
<tr class="memdesc:add3a6c0f649b952225fd7ef07b9e02d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the "expected intensity factor" for a given reflection.  <a href="#add3a6c0f649b952225fd7ef07b9e02d7">More...</a><br/></td></tr>
<tr class="separator:add3a6c0f649b952225fd7ef07b9e02d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a4e3c79f1baccc4436dc0792d5489a821"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00102.html#a4e3c79f1baccc4436dc0792d5489a821">InitSpaceGroup</a> (const string &amp;spgId)</td></tr>
<tr class="memdesc:a4e3c79f1baccc4436dc0792d5489a821"><td class="mdescLeft">&#160;</td><td class="mdescRight">Init the spaceGroup object from its name.  <a href="#a4e3c79f1baccc4436dc0792d5489a821">More...</a><br/></td></tr>
<tr class="separator:a4e3c79f1baccc4436dc0792d5489a821"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a5b8633c14cba4ab300327163b6fb2cdc"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00102.html#a5b8633c14cba4ab300327163b6fb2cdc">mId</a></td></tr>
<tr class="memdesc:a5b8633c14cba4ab300327163b6fb2cdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spacegroup's name ( 'I422', 'D2^8','230') Maybe we should only store the Hermann-Mauguin symbol, rather than storing the string which was initially given by the user/program for the initialization.  <a href="#a5b8633c14cba4ab300327163b6fb2cdc">More...</a><br/></td></tr>
<tr class="separator:a5b8633c14cba4ab300327163b6fb2cdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8964d9e944d964dcc122adae63ac9d81"><td class="memItemLeft" align="right" valign="top">cctbx::sgtbx::space_group *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00102.html#a8964d9e944d964dcc122adae63ac9d81">mpCCTbxSpaceGroup</a></td></tr>
<tr class="memdesc:a8964d9e944d964dcc122adae63ac9d81"><td class="mdescLeft">&#160;</td><td class="mdescRight">SgOps structure for this spacegroup.  <a href="#a8964d9e944d964dcc122adae63ac9d81">More...</a><br/></td></tr>
<tr class="separator:a8964d9e944d964dcc122adae63ac9d81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c78b80ee241395b34f156cbe3b42261"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00102.html#a1c78b80ee241395b34f156cbe3b42261">mHasInversionCenter</a></td></tr>
<tr class="memdesc:a1c78b80ee241395b34f156cbe3b42261"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is spacegroup centrosymmetric ?  <a href="#a1c78b80ee241395b34f156cbe3b42261">More...</a><br/></td></tr>
<tr class="separator:a1c78b80ee241395b34f156cbe3b42261"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81e299e91344679806f1aecd5118a509"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00102.html#a81e299e91344679806f1aecd5118a509">mIsInversionCenterAtOrigin</a></td></tr>
<tr class="memdesc:a81e299e91344679806f1aecd5118a509"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is center of symmetry at the origin ?  <a href="#a81e299e91344679806f1aecd5118a509">More...</a><br/></td></tr>
<tr class="separator:a81e299e91344679806f1aecd5118a509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afab66408e77f673c763759a6b711a171"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afab66408e77f673c763759a6b711a171"></a>
<a class="el" href="a00014.html">AsymmetricUnit</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00102.html#afab66408e77f673c763759a6b711a171">mAsymmetricUnit</a></td></tr>
<tr class="memdesc:afab66408e77f673c763759a6b711a171"><td class="mdescLeft">&#160;</td><td class="mdescRight">The spacegroup asymmetric unit. <br/></td></tr>
<tr class="separator:afab66408e77f673c763759a6b711a171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc6df7cab781386adbf925e2db531a50"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adc6df7cab781386adbf925e2db531a50"></a>
<a class="el" href="a00079.html">RefinableObjClock</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00102.html#adc6df7cab781386adbf925e2db531a50">mClock</a></td></tr>
<tr class="memdesc:adc6df7cab781386adbf925e2db531a50"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Spacegroup clock. <br/></td></tr>
<tr class="separator:adc6df7cab781386adbf925e2db531a50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae893aec7a2f92d875c69df9c02224510"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae893aec7a2f92d875c69df9c02224510"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00102.html#ae893aec7a2f92d875c69df9c02224510">mUniqueAxisId</a></td></tr>
<tr class="memdesc:ae893aec7a2f92d875c69df9c02224510"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unique axis number (0=a,1=b,2=c) <br/></td></tr>
<tr class="separator:ae893aec7a2f92d875c69df9c02224510"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecfbdf6789b8d2630231ba260bcad1d2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aecfbdf6789b8d2630231ba260bcad1d2"></a>
unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00102.html#aecfbdf6789b8d2630231ba260bcad1d2">mNbSym</a></td></tr>
<tr class="memdesc:aecfbdf6789b8d2630231ba260bcad1d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of symmetry operations (excluding center, and translations). <br/></td></tr>
<tr class="separator:aecfbdf6789b8d2630231ba260bcad1d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a818fda764b1ca81deb48112c11616e67"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a818fda764b1ca81deb48112c11616e67"></a>
unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00102.html#a818fda764b1ca81deb48112c11616e67">mNbTrans</a></td></tr>
<tr class="memdesc:a818fda764b1ca81deb48112c11616e67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of lattice translations, including (0,0,0). <br/></td></tr>
<tr class="separator:a818fda764b1ca81deb48112c11616e67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2921d4275e42e989bba01e569d25fd06"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2921d4275e42e989bba01e569d25fd06"></a>
unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00102.html#a2921d4275e42e989bba01e569d25fd06">mSpgNumber</a></td></tr>
<tr class="memdesc:a2921d4275e42e989bba01e569d25fd06"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a00102.html" title="The crystallographic space group, and the cell choice. ">SpaceGroup</a> Number. <br/></td></tr>
<tr class="separator:a2921d4275e42e989bba01e569d25fd06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe396f7dc29a70c460f606461a849278"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afe396f7dc29a70c460f606461a849278"></a>
char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00102.html#afe396f7dc29a70c460f606461a849278">mExtension</a></td></tr>
<tr class="memdesc:afe396f7dc29a70c460f606461a849278"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extension to space group symbol (1,2:origin choice ; R,H=rhomboedral/hexagonal) <br/></td></tr>
<tr class="separator:afe396f7dc29a70c460f606461a849278"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a312ef11d6802deb621501f5f7e67ee50"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a312ef11d6802deb621501f5f7e67ee50"></a>
std::vector&lt; <a class="el" href="a00101.html">SMx</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00102.html#a312ef11d6802deb621501f5f7e67ee50">mvSym</a></td></tr>
<tr class="memdesc:a312ef11d6802deb621501f5f7e67ee50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store floating-point matrices for faster use. <br/></td></tr>
<tr class="separator:a312ef11d6802deb621501f5f7e67ee50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad32dcbecd3a115f4d0ab395a47331a3d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad32dcbecd3a115f4d0ab395a47331a3d"></a>
std::vector&lt; <a class="el" href="a00116.html">TRx</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00102.html#ad32dcbecd3a115f4d0ab395a47331a3d">mvTrans</a></td></tr>
<tr class="memdesc:ad32dcbecd3a115f4d0ab395a47331a3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store floating-point translation vectors for faster use. <br/></td></tr>
<tr class="separator:ad32dcbecd3a115f4d0ab395a47331a3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The crystallographic space group, and the cell choice. </p>
<p>This class includes functions to get basic information about the symmetries, as well as getting all symmetrics for a given position in a unit cell.</p>
<p>This class included a pointer to a function calculating the "geometrical
 structure factor" (ie the sum of sin() and cos() for all symetrics, as could be found in the old version of the (red) International Tables), which was used to speed up computation of structure factors by using pre-factorised formulas. This is not used anymore, since methods can be used to speed up computations.</p>
<p>This class uses R. Grosse-Kunstleve 'SgLite' package, which is part of the Pymol package : <a href="http://pymol.sourceforge.net/">http://pymol.sourceforge.net/</a></p>
<dl class="section warning"><dt>Warning</dt><dd>: the interface of the class will somewhat change when switching from sgLite to cctbx (<a href="http://cctbx.sourceforge.net">http://cctbx.sourceforge.net</a>). Particularly functions Spacegroup::GetSgOps() and Spacegroup::GetHM_as_Hall() will be removed. </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a5f5f5b814480e6ab109c22926cc359ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ObjCryst::SpaceGroup::SpaceGroup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default Constructor (initializes in P1) </p>
<p>You can use later <a class="el" href="a00102.html#af592aa42f04d02e4caecbf2b93031be8" title="Change the Spacegroup. ">SpaceGroup::ChangeSpaceGroup()</a> to set the spacegroup. </p>

</div>
</div>
<a class="anchor" id="a5db1daaae23fab45637555f74c705b3e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ObjCryst::SpaceGroup::SpaceGroup </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>spgId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor with a specified spacegroup symbol or number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spgId</td><td>The space group identifier, either an Hermann-Maugin, or Hall, or Schonflies symbol. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="abc388337be91c9ae1bee5cc13ffc1aa4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ObjCryst::SpaceGroup::AreReflEquiv </td>
          <td>(</td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>h1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>k1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>l1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>h2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>k2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>l2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Are these reflections equivalent ? </p>
<dl class="section return"><dt>Returns</dt><dd>1 if they are equivalent, 2 if they are Friedel/Bijvoet mates, and else 0. </dd></dl>

</div>
</div>
<a class="anchor" id="adc3c511d36ad707690ca4f9c0154a8a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ObjCryst::SpaceGroup::ChangeToAsymmetricUnit </td>
          <td>(</td>
          <td class="paramtype">REAL&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">REAL&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">REAL&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move (x,y,z) coordinates to their equivalent in the asym unit. </p>
<dl class="section warning"><dt>Warning</dt><dd>Not implemented yet. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="a00229.html#_todo000015">Todo:</a></b></dt><dd><a class="el" href="a00102.html#accd8f865d9cbb12e420a6737fe50bc06" title="Test if a given scatterer at (x,y,z) is in the asymmetric unit. ">SpaceGroup::IsInAsymmetricUnit()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a63733aec55c2f6dc07c9d88a56f38238"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CrystMatrix_REAL ObjCryst::SpaceGroup::GetAllEquivRefl </td>
          <td>(</td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>excludeFriedelMate</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>forceFriedelLaw</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>sf_re</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>sf_im</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the list of all equivalent reflections. </p>
<dl class="section return"><dt>Returns</dt><dd>a matrix with 5 columns for h,k,l,Re(F),Im(F) and as many rows as there are reflections (the input reflection is included), with the associated structure factor, from the structure factor of the input reflection. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">excludeFriedelMate</td><td>if true, then Friedel mates of reflections will not be listed, even if there is a center of symmetry. </td></tr>
    <tr><td class="paramname">forceFriedelLaw</td><td>if true, a center of symmetry will be added (to force considering Friedel mates as equivalent). This as no effect if excludeFriedelMate=true</td></tr>
    <tr><td class="paramname">sf_re,sf_im,:</td><td>the real &amp; imaginary part of the structure factor of the original reflection </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1c547bc807cc28143b92b0ed4834581e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CrystMatrix_REAL ObjCryst::SpaceGroup::GetAllSymmetrics </td>
          <td>(</td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>noCenter</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>noTransl</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>noIdentical</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all equivalent positions of a (xyz) position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x,y,z</td><td>fractional coordinates of the position </td></tr>
    <tr><td class="paramname">noCenter</td><td>if set to 'false' (the default), then the center of symmetry (if any) is used to generate ALL positions. If 'true', then only one half of equivalent positions are generated. This has no influence if the group is not centrosymmetric. (<b>note</b> Not generating symmetrical positions from center of symmetry is useful to speed up computation of structure factor, but is a bit tricky if the inversion is not at the origin. This is taken into account) </td></tr>
    <tr><td class="paramname">noTransl</td><td>if set to 'false' (the default), then translation are taken into account to generate all atom positions. This affect only body or face(s)-centered spacegroups. </td></tr>
    <tr><td class="paramname">noIdentical</td><td>if set to true, then atom in special positions will only return the distinct atomic positions. Currently two atoms are considered distinct if the difference for all of their fractionnal coordinates is less than 1e-5 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a 3-column (x,y,z) matrix with as many rows as symmetric atoms </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>'special' positions are not taken into account. (ie an atom in special position will return duplicate entries. This may be corrected automatically later.) You can use the 'noIdentical' option for that, </dd></dl>

</div>
</div>
<a class="anchor" id="add3a6c0f649b952225fd7ef07b9e02d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ObjCryst::SpaceGroup::GetExpectedIntensityFactor </td>
          <td>(</td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the "expected intensity factor" for a given reflection. </p>
<p>This is the number of times the reflection is identical to the reflections deduced by the symmetry operators, under all distinct pure rotationnal symmetry operations of the space group.</p>
<p>This is used for the probability distribution of reflection intensities.</p>
<p>See:</p>
<ul>
<li>Stewart &amp; Karle, Acta. Cryst 132 (1976), 1005</li>
<li>Wilson, Acta Cryst 3 (1950), 258 </li>
</ul>

</div>
</div>
<a class="anchor" id="a1bf3ff968700527947d0a134b8058a85"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ObjCryst::SpaceGroup::GetNbSymmetrics </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>noCenter</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>noTransl</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of equivalent positions in the spacegroup, ie the multilicity of the general position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">noCenter</td><td>if 'true', do not take into account the center of symmetry </td></tr>
    <tr><td class="paramname">noTransl</td><td>if 'true', do not take into account translations </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a83b6cae3a3b76abc0a25a89cecf43ee1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ObjCryst::SpaceGroup::GetNbTranslationVectors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of translation vectors (1 for 'P' cells, 2 for 'I', 4 for 'F',etc..) </p>

</div>
</div>
<a class="anchor" id="a763a2f9e54363c2134a92beed214bbe2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="a00116.html">SpaceGroup::TRx</a>&gt;&amp; ObjCryst::SpaceGroup::GetTranslationVectors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return all Translation Vectors, as a 3 columns-array. </p>
<p>The first vector is always [0,0,0] </p>
<dl class="section return"><dt>Returns</dt><dd><img class="formulaInl" alt="$ \left[ \begin {array}{ccc} 0 &amp; 0 &amp; 0 \end{array} \right] $" src="form_32.png"/> for a 'P' Cell, <img class="formulaInl" alt="$ \left[ \begin {array}{ccc} 0 &amp; 0 &amp; 0 \\ \frac{1}{2} &amp; \frac{1}{2} &amp; \frac{1}{2} \\ \end{array} \right] $" src="form_33.png"/> for a 'I' cell, and <img class="formulaInl" alt="$ \left[ \begin {array}{ccc} 0 &amp; 0 &amp; 0 \\ \frac{1}{2} &amp; \frac{1}{2} &amp; 0 \\ \frac{1}{2} &amp; 0 &amp; \frac{1}{2} \\ 0 &amp; \frac{1}{2} &amp; \frac{1}{2} \\ \end{array} \right] $" src="form_34.png"/> for a 'F' cell,etc... </dd></dl>

</div>
</div>
<a class="anchor" id="a4e3c79f1baccc4436dc0792d5489a821"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ObjCryst::SpaceGroup::InitSpaceGroup </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>spgId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Init the spaceGroup object from its name. </p>
<p>Initialize the SgOps &amp; HM_as_Hall structures (SgLite), and set the function pointers to the functions used to compute the geometrical structure factors. </p>

</div>
</div>
<a class="anchor" id="a7c3746694fb9a6dbe3f258febb858744"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ObjCryst::SpaceGroup::Print </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints a description of the spacegroup (symbol, properties). </p>
<dl class="todo"><dt><b><a class="el" href="a00229.html#_todo000016">Todo:</a></b></dt><dd></dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a1c78b80ee241395b34f156cbe3b42261"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ObjCryst::SpaceGroup::mHasInversionCenter</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is spacegroup centrosymmetric ? </p>

</div>
</div>
<a class="anchor" id="a5b8633c14cba4ab300327163b6fb2cdc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string ObjCryst::SpaceGroup::mId</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Spacegroup's name ( 'I422', 'D2^8','230') Maybe we should only store the Hermann-Mauguin symbol, rather than storing the string which was initially given by the user/program for the initialization. </p>

</div>
</div>
<a class="anchor" id="a81e299e91344679806f1aecd5118a509"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ObjCryst::SpaceGroup::mIsInversionCenterAtOrigin</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is center of symmetry at the origin ? </p>

</div>
</div>
<a class="anchor" id="a8964d9e944d964dcc122adae63ac9d81"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cctbx::sgtbx::space_group* ObjCryst::SpaceGroup::mpCCTbxSpaceGroup</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SgOps structure for this spacegroup. </p>
<p>(Symmetry operations)</p>
<p>See sglite subdirectory for more information. This is (c) R. Gross-Kunstleve, part of PyMol software <a href="http://pymol.sourceforge.net/">http://pymol.sourceforge.net/</a> </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>SpaceGroup.h</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Dec 11 2013 15:36:08 for ObjCryst++ by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
