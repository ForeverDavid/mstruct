<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>ObjCryst++: ObjCryst::MonteCarloObj Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">ObjCryst++
   &#160;<span id="projectnumber">1.5CVS</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="a00171.html">ObjCryst</a></li><li class="navelem"><a class="el" href="a00050.html">MonteCarloObj</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="a00315.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ObjCryst::MonteCarloObj Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Base object for Monte-Carlo Global Optimization methods.  
 <a href="a00050.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for ObjCryst::MonteCarloObj:</div>
<div class="dyncontent">
 <div class="center">
  <img src="a00050.png" usemap="#ObjCryst::MonteCarloObj_map" alt=""/>
  <map id="ObjCryst::MonteCarloObj_map" name="ObjCryst::MonteCarloObj_map">
<area href="a00055.html" title="Base object for Optimization methods." alt="ObjCryst::OptimizationObj" shape="rect" coords="0,0,156,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6ef446b8361a8c53d016f213f0d1e17f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6ef446b8361a8c53d016f213f0d1e17f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#a6ef446b8361a8c53d016f213f0d1e17f">MonteCarloObj</a> (const string name=&quot;&quot;)</td></tr>
<tr class="memdesc:a6ef446b8361a8c53d016f213f0d1e17f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br/></td></tr>
<tr class="memitem:a503419b4b79fdb5ae41928656a888ec8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#a503419b4b79fdb5ae41928656a888ec8">MonteCarloObj</a> (const bool internalUseOnly)</td></tr>
<tr class="memdesc:a503419b4b79fdb5ae41928656a888ec8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#a503419b4b79fdb5ae41928656a888ec8"></a><br/></td></tr>
<tr class="memitem:a7f928d56e60a279085c67e78dc334f39"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7f928d56e60a279085c67e78dc334f39"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#a7f928d56e60a279085c67e78dc334f39">~MonteCarloObj</a> ()</td></tr>
<tr class="memdesc:a7f928d56e60a279085c67e78dc334f39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br/></td></tr>
<tr class="memitem:ac094251dbd02a4709dd4afb29d8454e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#ac094251dbd02a4709dd4afb29d8454e5">SetAlgorithmSimulAnnealing</a> (const <a class="el" href="a00171.html#a6ad2a3db75ca198897ce05b6e561eeca">AnnealingSchedule</a> scheduleTemp, const REAL tMax, const REAL tMin, const <a class="el" href="a00171.html#a6ad2a3db75ca198897ce05b6e561eeca">AnnealingSchedule</a> scheduleMutation=ANNEALING_CONSTANT, const REAL mutMax=16., const REAL mutMin=.125, const long nbTrialRetry=0, const REAL minCostRetry=0.)</td></tr>
<tr class="memdesc:ac094251dbd02a4709dd4afb29d8454e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the refinement method to simulated Annealing.  <a href="#ac094251dbd02a4709dd4afb29d8454e5"></a><br/></td></tr>
<tr class="memitem:a54c7ad3cb78846c82c65d6a6db27801a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#a54c7ad3cb78846c82c65d6a6db27801a">SetAlgorithmParallTempering</a> (const <a class="el" href="a00171.html#a6ad2a3db75ca198897ce05b6e561eeca">AnnealingSchedule</a> scheduleTemp, const REAL tMax, const REAL tMin, const <a class="el" href="a00171.html#a6ad2a3db75ca198897ce05b6e561eeca">AnnealingSchedule</a> scheduleMutation=ANNEALING_CONSTANT, const REAL mutMax=16., const REAL mutMin=.125)</td></tr>
<tr class="memdesc:a54c7ad3cb78846c82c65d6a6db27801a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the refinement method to Parallel Tempering.  <a href="#a54c7ad3cb78846c82c65d6a6db27801a"></a><br/></td></tr>
<tr class="memitem:aef060de8a302fb8c4e607e00667d7b49"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#aef060de8a302fb8c4e607e00667d7b49">Optimize</a> (long &amp;nbSteps, const bool silent=false, const REAL finalcost=0, const REAL maxTime=-1)</td></tr>
<tr class="memdesc:aef060de8a302fb8c4e607e00667d7b49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Launch optimization (a single run) for N steps.  <a href="#aef060de8a302fb8c4e607e00667d7b49"></a><br/></td></tr>
<tr class="memitem:ae1689aa2dd5867499768328df935334d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#ae1689aa2dd5867499768328df935334d">MultiRunOptimize</a> (long &amp;nbCycle, long &amp;nbSteps, const bool silent=false, const REAL finalcost=0, const REAL maxTime=-1)</td></tr>
<tr class="memdesc:ae1689aa2dd5867499768328df935334d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Launch optimization for multiple runs of N steps.  <a href="#ae1689aa2dd5867499768328df935334d"></a><br/></td></tr>
<tr class="memitem:a80c15a8ba385e2e0f3e8a52451898fde"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#a80c15a8ba385e2e0f3e8a52451898fde">RunSimulatedAnnealing</a> (long &amp;nbSteps, const bool silent=false, const REAL finalcost=0, const REAL maxTime=-1)</td></tr>
<tr class="memitem:a707045b814adb938fa5a1d8485074d21"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#a707045b814adb938fa5a1d8485074d21">RunParallelTempering</a> (long &amp;nbSteps, const bool silent=false, const REAL finalcost=0, const REAL maxTime=-1)</td></tr>
<tr class="memitem:a619eb171e5fe384be4d37f999dde8e0f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#a619eb171e5fe384be4d37f999dde8e0f">XMLOutput</a> (ostream &amp;os, int indent=0) const </td></tr>
<tr class="memdesc:a619eb171e5fe384be4d37f999dde8e0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output a description of the object in XML format to a stream.  <a href="#a619eb171e5fe384be4d37f999dde8e0f"></a><br/></td></tr>
<tr class="memitem:a2f9428857b1d26bbdac08d59debb9f52"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#a2f9428857b1d26bbdac08d59debb9f52">XMLInput</a> (istream &amp;is, const <a class="el" href="a00151.html">XMLCrystTag</a> &amp;tag)</td></tr>
<tr class="memdesc:a2f9428857b1d26bbdac08d59debb9f52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Input in XML format from a stream, restoring the set of refined objects and the associated cost functions.  <a href="#a2f9428857b1d26bbdac08d59debb9f52"></a><br/></td></tr>
<tr class="memitem:a8093d58ee8d609cf89a52455df240882"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8093d58ee8d609cf89a52455df240882"></a>
virtual const string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#a8093d58ee8d609cf89a52455df240882">GetClassName</a> () const </td></tr>
<tr class="memdesc:a8093d58ee8d609cf89a52455df240882"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name for this class type. <br/></td></tr>
<tr class="memitem:a517ee30d65b11c5172f4643aac8a8128"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a517ee30d65b11c5172f4643aac8a8128"></a>
<a class="el" href="a00039.html">LSQNumObj</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#a517ee30d65b11c5172f4643aac8a8128">GetLSQObj</a> ()</td></tr>
<tr class="memdesc:a517ee30d65b11c5172f4643aac8a8128"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to the builtin LSQ optimization object. <br/></td></tr>
<tr class="memitem:a695d603e54e12bbf9cd6efa6282ee948"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a695d603e54e12bbf9cd6efa6282ee948"></a>
const <a class="el" href="a00039.html">LSQNumObj</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#a695d603e54e12bbf9cd6efa6282ee948">GetLSQObj</a> () const </td></tr>
<tr class="memdesc:a695d603e54e12bbf9cd6efa6282ee948"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to the builtin LSQ optimization object. <br/></td></tr>
<tr class="inherit_header pub_methods_a00055"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_a00055')"><img src="closed.png" alt="-"/>&nbsp;Public Member Functions inherited from <a class="el" href="a00055.html">ObjCryst::OptimizationObj</a></td></tr>
<tr class="memitem:a939444ac47768e16d205bebbc247cc12 inherit pub_methods_a00055"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a939444ac47768e16d205bebbc247cc12"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00055.html#a939444ac47768e16d205bebbc247cc12">OptimizationObj</a> (const string name=&quot;&quot;)</td></tr>
<tr class="memdesc:a939444ac47768e16d205bebbc247cc12 inherit pub_methods_a00055"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br/></td></tr>
<tr class="memitem:a6fdf1e7158254a3c0a21b33e6ed5ffb5 inherit pub_methods_a00055"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6fdf1e7158254a3c0a21b33e6ed5ffb5"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00055.html#a6fdf1e7158254a3c0a21b33e6ed5ffb5">~OptimizationObj</a> ()</td></tr>
<tr class="memdesc:a6fdf1e7158254a3c0a21b33e6ed5ffb5 inherit pub_methods_a00055"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br/></td></tr>
<tr class="memitem:a04ac9f4d67eb8823b78b00f222a5a29c inherit pub_methods_a00055"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00055.html#a04ac9f4d67eb8823b78b00f222a5a29c">RandomizeStartingConfig</a> ()</td></tr>
<tr class="memdesc:a04ac9f4d67eb8823b78b00f222a5a29c inherit pub_methods_a00055"><td class="mdescLeft">&#160;</td><td class="mdescRight">Randomize starting configuration.  <a href="#a04ac9f4d67eb8823b78b00f222a5a29c"></a><br/></td></tr>
<tr class="memitem:af8b3cef84c6bcca37cdc4bfde9ecde45 inherit pub_methods_a00055"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af8b3cef84c6bcca37cdc4bfde9ecde45"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00055.html#af8b3cef84c6bcca37cdc4bfde9ecde45">FixAllPar</a> ()</td></tr>
<tr class="memdesc:af8b3cef84c6bcca37cdc4bfde9ecde45 inherit pub_methods_a00055"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fix all parameters. <br/></td></tr>
<tr class="memitem:aca3e1d2c6ace92f1a3a67da2455eac39 inherit pub_methods_a00055"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aca3e1d2c6ace92f1a3a67da2455eac39"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00055.html#aca3e1d2c6ace92f1a3a67da2455eac39">SetParIsFixed</a> (const string &amp;parName, const bool fix)</td></tr>
<tr class="memdesc:aca3e1d2c6ace92f1a3a67da2455eac39 inherit pub_methods_a00055"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fix one parameter. <br/></td></tr>
<tr class="memitem:a12a66416a701cbf0db17de3bfafdec99 inherit pub_methods_a00055"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a12a66416a701cbf0db17de3bfafdec99"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00055.html#a12a66416a701cbf0db17de3bfafdec99">SetParIsFixed</a> (const <a class="el" href="a00080.html">RefParType</a> *type, const bool fix)</td></tr>
<tr class="memdesc:a12a66416a701cbf0db17de3bfafdec99 inherit pub_methods_a00055"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fix one family of parameters. <br/></td></tr>
<tr class="memitem:adb016adacaa7a2a15e40cfb746705bdd inherit pub_methods_a00055"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adb016adacaa7a2a15e40cfb746705bdd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00055.html#adb016adacaa7a2a15e40cfb746705bdd">UnFixAllPar</a> ()</td></tr>
<tr class="memdesc:adb016adacaa7a2a15e40cfb746705bdd inherit pub_methods_a00055"><td class="mdescLeft">&#160;</td><td class="mdescRight">UnFix All parameters. <br/></td></tr>
<tr class="memitem:ab2f87becfb73eb00d8f7c3ff25435c0d inherit pub_methods_a00055"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab2f87becfb73eb00d8f7c3ff25435c0d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00055.html#ab2f87becfb73eb00d8f7c3ff25435c0d">SetParIsUsed</a> (const string &amp;parName, const bool use)</td></tr>
<tr class="memdesc:ab2f87becfb73eb00d8f7c3ff25435c0d inherit pub_methods_a00055"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a parameter to be used. <br/></td></tr>
<tr class="memitem:a73c29f094ad0a4923a2873388fc1eb93 inherit pub_methods_a00055"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a73c29f094ad0a4923a2873388fc1eb93"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00055.html#a73c29f094ad0a4923a2873388fc1eb93">SetParIsUsed</a> (const <a class="el" href="a00080.html">RefParType</a> *type, const bool use)</td></tr>
<tr class="memdesc:a73c29f094ad0a4923a2873388fc1eb93 inherit pub_methods_a00055"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a family of parameters to be used. <br/></td></tr>
<tr class="memitem:a78113a7741eeda2263a27adcc24497c0 inherit pub_methods_a00055"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a78113a7741eeda2263a27adcc24497c0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00055.html#a78113a7741eeda2263a27adcc24497c0">SetLimitsRelative</a> (const string &amp;parName, const REAL min, const REAL max)</td></tr>
<tr class="memdesc:a78113a7741eeda2263a27adcc24497c0 inherit pub_methods_a00055"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the relative limits for a parameter from its name. <br/></td></tr>
<tr class="memitem:a0437fb441bebe91879de98efcb82865e inherit pub_methods_a00055"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0437fb441bebe91879de98efcb82865e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00055.html#a0437fb441bebe91879de98efcb82865e">SetLimitsRelative</a> (const <a class="el" href="a00080.html">RefParType</a> *type, const REAL min, const REAL max)</td></tr>
<tr class="memdesc:a0437fb441bebe91879de98efcb82865e inherit pub_methods_a00055"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the relative limits for a family of parameter. <br/></td></tr>
<tr class="memitem:ad0bc0b36d1525526c55dc6642109d0b4 inherit pub_methods_a00055"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad0bc0b36d1525526c55dc6642109d0b4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00055.html#ad0bc0b36d1525526c55dc6642109d0b4">SetLimitsAbsolute</a> (const string &amp;parName, const REAL min, const REAL max)</td></tr>
<tr class="memdesc:ad0bc0b36d1525526c55dc6642109d0b4 inherit pub_methods_a00055"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the absolute limits for a parameter from its name. <br/></td></tr>
<tr class="memitem:ade59b2e1d698ff7ba93ac5aa88187c58 inherit pub_methods_a00055"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ade59b2e1d698ff7ba93ac5aa88187c58"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00055.html#ade59b2e1d698ff7ba93ac5aa88187c58">SetLimitsAbsolute</a> (const <a class="el" href="a00080.html">RefParType</a> *type, const REAL min, const REAL max)</td></tr>
<tr class="memdesc:ade59b2e1d698ff7ba93ac5aa88187c58 inherit pub_methods_a00055"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the absolute limits for a family of parameter. <br/></td></tr>
<tr class="memitem:a0f317f235e6e5cb1867cc7c5870f510f inherit pub_methods_a00055"><td class="memItemLeft" align="right" valign="top">virtual REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00055.html#a0f317f235e6e5cb1867cc7c5870f510f">GetLogLikelihood</a> () const </td></tr>
<tr class="memdesc:a0f317f235e6e5cb1867cc7c5870f510f inherit pub_methods_a00055"><td class="mdescLeft">&#160;</td><td class="mdescRight">The optimized (minimized, actually) function.  <a href="#a0f317f235e6e5cb1867cc7c5870f510f"></a><br/></td></tr>
<tr class="memitem:a288306acc3189c4fcaca398d11b32e4e inherit pub_methods_a00055"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a288306acc3189c4fcaca398d11b32e4e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00055.html#a288306acc3189c4fcaca398d11b32e4e">StopAfterCycle</a> ()</td></tr>
<tr class="memdesc:a288306acc3189c4fcaca398d11b32e4e inherit pub_methods_a00055"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop after the current cycle. USed for interactive refinement. <br/></td></tr>
<tr class="memitem:af09e8a9cd1b7f7f29bf57d027e08fc54 inherit pub_methods_a00055"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af09e8a9cd1b7f7f29bf57d027e08fc54"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00055.html#af09e8a9cd1b7f7f29bf57d027e08fc54">DisplayReport</a> ()</td></tr>
<tr class="memdesc:af09e8a9cd1b7f7f29bf57d027e08fc54 inherit pub_methods_a00055"><td class="mdescLeft">&#160;</td><td class="mdescRight">Show report to the user during refinement. Used for GUI update. <br/></td></tr>
<tr class="memitem:a05e7019188763202126f9f83a31e1673 inherit pub_methods_a00055"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a05e7019188763202126f9f83a31e1673"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00055.html#a05e7019188763202126f9f83a31e1673">AddRefinableObj</a> (<a class="el" href="a00071.html">RefinableObj</a> &amp;)</td></tr>
<tr class="memdesc:a05e7019188763202126f9f83a31e1673 inherit pub_methods_a00055"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a refined object. All sub-objects are also added. <br/></td></tr>
<tr class="memitem:afef162d94382a93fe037fac1b5d3ef03 inherit pub_methods_a00055"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00071.html">RefinableObj</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00055.html#afef162d94382a93fe037fac1b5d3ef03">GetFullRefinableObj</a> (const bool rebuild=true)</td></tr>
<tr class="memdesc:afef162d94382a93fe037fac1b5d3ef03 inherit pub_methods_a00055"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="a00071.html" title="Generic Refinable Object.">RefinableObj</a> with all the parameters from all refined objects.  <a href="#afef162d94382a93fe037fac1b5d3ef03"></a><br/></td></tr>
<tr class="memitem:af595745274e554956834f885d7a1dc71 inherit pub_methods_a00055"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af595745274e554956834f885d7a1dc71"></a>
const string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00055.html#af595745274e554956834f885d7a1dc71">GetName</a> () const </td></tr>
<tr class="memdesc:af595745274e554956834f885d7a1dc71 inherit pub_methods_a00055"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name for this object. <br/></td></tr>
<tr class="memitem:a076dc80d878fc4ab5e5491f54642382e inherit pub_methods_a00055"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a076dc80d878fc4ab5e5491f54642382e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00055.html#a076dc80d878fc4ab5e5491f54642382e">SetName</a> (const string &amp;)</td></tr>
<tr class="memdesc:a076dc80d878fc4ab5e5491f54642382e inherit pub_methods_a00055"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the name for this object. <br/></td></tr>
<tr class="memitem:a55e92db45821ed13288d6852055c0003 inherit pub_methods_a00055"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a55e92db45821ed13288d6852055c0003"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00055.html#a55e92db45821ed13288d6852055c0003">Print</a> () const </td></tr>
<tr class="memdesc:a55e92db45821ed13288d6852055c0003 inherit pub_methods_a00055"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print some information about this object. <br/></td></tr>
<tr class="memitem:a25a4ea1cf717a7d62ecf2cdbee87fa7a inherit pub_methods_a00055"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a25a4ea1cf717a7d62ecf2cdbee87fa7a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00055.html#a25a4ea1cf717a7d62ecf2cdbee87fa7a">RestoreBestConfiguration</a> ()</td></tr>
<tr class="memdesc:a25a4ea1cf717a7d62ecf2cdbee87fa7a inherit pub_methods_a00055"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore the Best configuration. <br/></td></tr>
<tr class="memitem:a02d12183cd9d167358717b87ada6ba1f inherit pub_methods_a00055"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a02d12183cd9d167358717b87ada6ba1f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00055.html#a02d12183cd9d167358717b87ada6ba1f">IsOptimizing</a> () const </td></tr>
<tr class="memdesc:a02d12183cd9d167358717b87ada6ba1f inherit pub_methods_a00055"><td class="mdescLeft">&#160;</td><td class="mdescRight">Are we busy optimizing ? <br/></td></tr>
<tr class="memitem:a99ca4e2216b0fd93ab335c35a99ca895 inherit pub_methods_a00055"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a99ca4e2216b0fd93ab335c35a99ca895"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00055.html#a99ca4e2216b0fd93ab335c35a99ca895">TagNewBestConfig</a> ()</td></tr>
<tr class="memdesc:a99ca4e2216b0fd93ab335c35a99ca895 inherit pub_methods_a00055"><td class="mdescLeft">&#160;</td><td class="mdescRight">During a global optimization, tell all objects that the current config is the latest "best" config. <br/></td></tr>
<tr class="memitem:af9bb37804ee3012cb05ffc217584db42 inherit pub_methods_a00055"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af9bb37804ee3012cb05ffc217584db42"></a>
REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00055.html#af9bb37804ee3012cb05ffc217584db42">GetLastOptimElapsedTime</a> () const </td></tr>
<tr class="memdesc:af9bb37804ee3012cb05ffc217584db42 inherit pub_methods_a00055"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the elapsed time (in seconds) during the last optimization. <br/></td></tr>
<tr class="memitem:af8328b810bc37e45881e19948da7d2d7 inherit pub_methods_a00055"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af8328b810bc37e45881e19948da7d2d7"></a>
<a class="el" href="a00041.html">MainTracker</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00055.html#af8328b810bc37e45881e19948da7d2d7">GetMainTracker</a> ()</td></tr>
<tr class="memdesc:af8328b810bc37e45881e19948da7d2d7 inherit pub_methods_a00055"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="a00041.html" title="A class to hold all trackers.">MainTracker</a>. <br/></td></tr>
<tr class="memitem:a737490fc1ac0b30fc3bb3a5bb8061a8b inherit pub_methods_a00055"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a737490fc1ac0b30fc3bb3a5bb8061a8b"></a>
const <a class="el" href="a00041.html">MainTracker</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00055.html#a737490fc1ac0b30fc3bb3a5bb8061a8b">GetMainTracker</a> () const </td></tr>
<tr class="memdesc:a737490fc1ac0b30fc3bb3a5bb8061a8b inherit pub_methods_a00055"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="a00041.html" title="A class to hold all trackers.">MainTracker</a>. <br/></td></tr>
<tr class="memitem:a82e4adbc7b5d3374f7c414a0e89c25fd inherit pub_methods_a00055"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a82e4adbc7b5d3374f7c414a0e89c25fd"></a>
<a class="el" href="a00078.html">RefObjOpt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>GetXMLAutoSaveOption</b> ()</td></tr>
<tr class="memitem:a0a37e6bcce21926e13a3f57882e971b0 inherit pub_methods_a00055"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0a37e6bcce21926e13a3f57882e971b0"></a>
const <a class="el" href="a00078.html">RefObjOpt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>GetXMLAutoSaveOption</b> () const </td></tr>
<tr class="memitem:a56c9ec94e7632c8b3f36e3a837c02594 inherit pub_methods_a00055"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a56c9ec94e7632c8b3f36e3a837c02594"></a>
const REAL &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00055.html#a56c9ec94e7632c8b3f36e3a837c02594">GetBestCost</a> () const </td></tr>
<tr class="memdesc:a56c9ec94e7632c8b3f36e3a837c02594 inherit pub_methods_a00055"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to current best cost. <br/></td></tr>
<tr class="memitem:a894882f10bd768e3e57ffdfa9f9df7fe inherit pub_methods_a00055"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a894882f10bd768e3e57ffdfa9f9df7fe"></a>
REAL &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00055.html#a894882f10bd768e3e57ffdfa9f9df7fe">GetBestCost</a> ()</td></tr>
<tr class="memdesc:a894882f10bd768e3e57ffdfa9f9df7fe inherit pub_methods_a00055"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to current best cost. <br/></td></tr>
<tr class="memitem:a13c12dbdc72825f892c3d48dd2b6cfe3 inherit pub_methods_a00055"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a13c12dbdc72825f892c3d48dd2b6cfe3"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00055.html#a13c12dbdc72825f892c3d48dd2b6cfe3">BeginOptimization</a> (const bool allowApproximations=false, const bool enableRestraints=false)</td></tr>
<tr class="memdesc:a13c12dbdc72825f892c3d48dd2b6cfe3 inherit pub_methods_a00055"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begin optimization for all objects. <br/></td></tr>
<tr class="memitem:a37c2335ad867152121253996daaebc6e inherit pub_methods_a00055"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a37c2335ad867152121253996daaebc6e"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00055.html#a37c2335ad867152121253996daaebc6e">EndOptimization</a> ()</td></tr>
<tr class="memdesc:a37c2335ad867152121253996daaebc6e inherit pub_methods_a00055"><td class="mdescLeft">&#160;</td><td class="mdescRight">End optimization for all objects. <br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a8f177c8ada9f3cf392f8e8706eeae28b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#a8f177c8ada9f3cf392f8e8706eeae28b">NewConfiguration</a> (const <a class="el" href="a00080.html">RefParType</a> *type=<a class="el" href="a00171.html#a92ed37a804903dfb302d70309b7bc474">gpRefParTypeObjCryst</a>)</td></tr>
<tr class="memdesc:a8f177c8ada9f3cf392f8e8706eeae28b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a random change in the configuration.  <a href="#a8f177c8ada9f3cf392f8e8706eeae28b"></a><br/></td></tr>
<tr class="memitem:aa9c005fcbe5c600efe2dee1a2c7697a4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa9c005fcbe5c600efe2dee1a2c7697a4"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#aa9c005fcbe5c600efe2dee1a2c7697a4">InitOptions</a> ()</td></tr>
<tr class="memdesc:aa9c005fcbe5c600efe2dee1a2c7697a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialization of options. <br/></td></tr>
<tr class="memitem:abe55c9dd193cca72bf5b947a6eaf7fdd"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#abe55c9dd193cca72bf5b947a6eaf7fdd">InitLSQ</a> (const bool useFullPowderPatternProfile=true)</td></tr>
<tr class="memdesc:abe55c9dd193cca72bf5b947a6eaf7fdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare mLSQ for least-squares refinement during the global optimization.  <a href="#abe55c9dd193cca72bf5b947a6eaf7fdd"></a><br/></td></tr>
<tr class="inherit_header pro_methods_a00055"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_a00055')"><img src="closed.png" alt="-"/>&nbsp;Protected Member Functions inherited from <a class="el" href="a00055.html">ObjCryst::OptimizationObj</a></td></tr>
<tr class="memitem:a2f11f520bc1bd0b70f8aea98d3f8224c inherit pro_methods_a00055"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00055.html#a2f11f520bc1bd0b70f8aea98d3f8224c">PrepareRefParList</a> ()</td></tr>
<tr class="memitem:a3658f0e6232756d68b8b17256f27a9bd inherit pro_methods_a00055"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00055.html#a3658f0e6232756d68b8b17256f27a9bd">UpdateDisplay</a> ()</td></tr>
<tr class="memdesc:a3658f0e6232756d68b8b17256f27a9bd inherit pro_methods_a00055"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update Display (if any display is available), when a new 'relevant' configuration is reached.  <a href="#a3658f0e6232756d68b8b17256f27a9bd"></a><br/></td></tr>
<tr class="memitem:a7c819c5f8fc52caafd97ea9d468da2be inherit pro_methods_a00055"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00055.html#a7c819c5f8fc52caafd97ea9d468da2be">BuildRecursiveRefObjList</a> ()</td></tr>
<tr class="memdesc:a7c819c5f8fc52caafd97ea9d468da2be inherit pro_methods_a00055"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Re)build <a class="el" href="a00055.html#a0e6a9e9d4d12ed73c582da36190f110f" title="The refined objects, recursively including all sub-objects.">OptimizationObj::mRecursiveRefinedObjList</a>, if an object has been added or modified.  <a href="#a7c819c5f8fc52caafd97ea9d468da2be"></a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:af5ab36ab840b6654f6738c30712b2f95"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00078.html">RefObjOpt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#af5ab36ab840b6654f6738c30712b2f95">mGlobalOptimType</a></td></tr>
<tr class="memdesc:af5ab36ab840b6654f6738c30712b2f95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method used for the global optimization.  <a href="#af5ab36ab840b6654f6738c30712b2f95"></a><br/></td></tr>
<tr class="memitem:a96805488cd133249ec1c24c67d3a2dda"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a96805488cd133249ec1c24c67d3a2dda"></a>
REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#a96805488cd133249ec1c24c67d3a2dda">mCurrentCost</a></td></tr>
<tr class="memdesc:a96805488cd133249ec1c24c67d3a2dda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current value of the cost function. <br/></td></tr>
<tr class="memitem:ac782f38b1343464aa3db886873798107"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac782f38b1343464aa3db886873798107"></a>
<a class="el" href="a00078.html">RefObjOpt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#ac782f38b1343464aa3db886873798107">mSaveTrackedData</a></td></tr>
<tr class="memdesc:ac782f38b1343464aa3db886873798107"><td class="mdescLeft">&#160;</td><td class="mdescRight">Option to save the evolution of tracked data (cost functions, likelihhod, individual parameters,...) <br/></td></tr>
<tr class="memitem:a17997726361536481a041fb5736fedb9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a17997726361536481a041fb5736fedb9"></a>
REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#a17997726361536481a041fb5736fedb9">mTemperature</a></td></tr>
<tr class="memdesc:a17997726361536481a041fb5736fedb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current temperature for annealing. <br/></td></tr>
<tr class="memitem:a1256bc3d6ceae83f8b36de6141a8945d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1256bc3d6ceae83f8b36de6141a8945d"></a>
REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#a1256bc3d6ceae83f8b36de6141a8945d">mTemperatureMax</a></td></tr>
<tr class="memdesc:a1256bc3d6ceae83f8b36de6141a8945d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Beginning temperature for annealing. <br/></td></tr>
<tr class="memitem:a8ba61158d22cd66be193aabcd41dd9f6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8ba61158d22cd66be193aabcd41dd9f6"></a>
REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#a8ba61158d22cd66be193aabcd41dd9f6">mTemperatureMin</a></td></tr>
<tr class="memdesc:a8ba61158d22cd66be193aabcd41dd9f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lower temperature. <br/></td></tr>
<tr class="memitem:ae630f1608e3be9b01159d0780980eb08"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae630f1608e3be9b01159d0780980eb08"></a>
<a class="el" href="a00078.html">RefObjOpt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#ae630f1608e3be9b01159d0780980eb08">mAnnealingScheduleTemp</a></td></tr>
<tr class="memdesc:ae630f1608e3be9b01159d0780980eb08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule for the annealing. <br/></td></tr>
<tr class="memitem:af1a7aeb7079f01175fbef95b31ca47af"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af1a7aeb7079f01175fbef95b31ca47af"></a>
REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#af1a7aeb7079f01175fbef95b31ca47af">mTemperatureGamma</a></td></tr>
<tr class="memdesc:af1a7aeb7079f01175fbef95b31ca47af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gamma for the 'gamma' temperature schedule. <br/></td></tr>
<tr class="memitem:afb02263e40ec89621bffe34ca859be96"><td class="memItemLeft" align="right" valign="top">REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#afb02263e40ec89621bffe34ca859be96">mMutationAmplitude</a></td></tr>
<tr class="memdesc:afb02263e40ec89621bffe34ca859be96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutation amplitude.  <a href="#afb02263e40ec89621bffe34ca859be96"></a><br/></td></tr>
<tr class="memitem:ae56181bde6b87eeeb24a6fdd1428a0b9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae56181bde6b87eeeb24a6fdd1428a0b9"></a>
REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#ae56181bde6b87eeeb24a6fdd1428a0b9">mMutationAmplitudeMax</a></td></tr>
<tr class="memdesc:ae56181bde6b87eeeb24a6fdd1428a0b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutation amplitude at the beginning of the optimization. <br/></td></tr>
<tr class="memitem:a6f4e6631d2079c0ac3f82a271a6ad3ec"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6f4e6631d2079c0ac3f82a271a6ad3ec"></a>
REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#a6f4e6631d2079c0ac3f82a271a6ad3ec">mMutationAmplitudeMin</a></td></tr>
<tr class="memdesc:a6f4e6631d2079c0ac3f82a271a6ad3ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutation amplitude at the end of the optimization. <br/></td></tr>
<tr class="memitem:a5bb4e03ae2221be34131f4c0f108271e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5bb4e03ae2221be34131f4c0f108271e"></a>
<a class="el" href="a00078.html">RefObjOpt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#a5bb4e03ae2221be34131f4c0f108271e">mAnnealingScheduleMutation</a></td></tr>
<tr class="memdesc:a5bb4e03ae2221be34131f4c0f108271e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule for the annealing. <br/></td></tr>
<tr class="memitem:a1cfbd1b4fc984a06a02c5102a9dcfcd3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1cfbd1b4fc984a06a02c5102a9dcfcd3"></a>
REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#a1cfbd1b4fc984a06a02c5102a9dcfcd3">mMutationAmplitudeGamma</a></td></tr>
<tr class="memdesc:a1cfbd1b4fc984a06a02c5102a9dcfcd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gamma for the 'gamma' Mutation amplitude schedule. <br/></td></tr>
<tr class="memitem:a22e972f1cb525f9dc5336fd1f47fa93b"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#a22e972f1cb525f9dc5336fd1f47fa93b">mNbTrialRetry</a></td></tr>
<tr class="memdesc:a22e972f1cb525f9dc5336fd1f47fa93b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of trials before testing if we are below the given minimum cost.  <a href="#a22e972f1cb525f9dc5336fd1f47fa93b"></a><br/></td></tr>
<tr class="memitem:a9a45d65ee6522c4dc159a91fdb4c1661"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9a45d65ee6522c4dc159a91fdb4c1661"></a>
REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#a9a45d65ee6522c4dc159a91fdb4c1661">mMinCostRetry</a></td></tr>
<tr class="memdesc:a9a45d65ee6522c4dc159a91fdb4c1661"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cost to reach unless an automatic randomization and retry is done. <br/></td></tr>
<tr class="memitem:a36b4c13151172e24108d6578d63d1125"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a36b4c13151172e24108d6578d63d1125"></a>
<a class="el" href="a00039.html">LSQNumObj</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#a36b4c13151172e24108d6578d63d1125">mLSQ</a></td></tr>
<tr class="memdesc:a36b4c13151172e24108d6578d63d1125"><td class="mdescLeft">&#160;</td><td class="mdescRight">Least squares object. <br/></td></tr>
<tr class="memitem:a3d6e159362a2f93d5a2883e60f1710d8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3d6e159362a2f93d5a2883e60f1710d8"></a>
<a class="el" href="a00078.html">RefObjOpt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#a3d6e159362a2f93d5a2883e60f1710d8">mAutoLSQ</a></td></tr>
<tr class="memdesc:a3d6e159362a2f93d5a2883e60f1710d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Option to run automatic least-squares refinements. <br/></td></tr>
<tr class="inherit_header pro_attribs_a00055"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_a00055')"><img src="closed.png" alt="-"/>&nbsp;Protected Attributes inherited from <a class="el" href="a00055.html">ObjCryst::OptimizationObj</a></td></tr>
<tr class="memitem:a9cf13c38f24b4b2ddd6cb239286053af inherit pro_attribs_a00055"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00071.html">RefinableObj</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00055.html#a9cf13c38f24b4b2ddd6cb239286053af">mRefParList</a></td></tr>
<tr class="memdesc:a9cf13c38f24b4b2ddd6cb239286053af inherit pro_attribs_a00055"><td class="mdescLeft">&#160;</td><td class="mdescRight">The refinable par list used during refinement.  <a href="#a9cf13c38f24b4b2ddd6cb239286053af"></a><br/></td></tr>
<tr class="memitem:a9fa42c95df26834a9f369af61eb10ea6 inherit pro_attribs_a00055"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9fa42c95df26834a9f369af61eb10ea6"></a>
string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00055.html#a9fa42c95df26834a9f369af61eb10ea6">mName</a></td></tr>
<tr class="memdesc:a9fa42c95df26834a9f369af61eb10ea6 inherit pro_attribs_a00055"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name of the GlobalOptimization object. <br/></td></tr>
<tr class="memitem:a2694dd9fc6ab088e3d79e0c9e0358311 inherit pro_attribs_a00055"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2694dd9fc6ab088e3d79e0c9e0358311"></a>
string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00055.html#a2694dd9fc6ab088e3d79e0c9e0358311">mSaveFileName</a></td></tr>
<tr class="memdesc:a2694dd9fc6ab088e3d79e0c9e0358311 inherit pro_attribs_a00055"><td class="mdescLeft">&#160;</td><td class="mdescRight">File name where refinement info is saved (NOT USED so far...) <br/></td></tr>
<tr class="memitem:af47650ca783520dd0100077b08271c79 inherit pro_attribs_a00055"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af47650ca783520dd0100077b08271c79"></a>
long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00055.html#af47650ca783520dd0100077b08271c79">mNbTrial</a></td></tr>
<tr class="memdesc:af47650ca783520dd0100077b08271c79 inherit pro_attribs_a00055"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of trials so far. <br/></td></tr>
<tr class="memitem:a495926a48dd408a3b92de8a6b33f815a inherit pro_attribs_a00055"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a495926a48dd408a3b92de8a6b33f815a"></a>
REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00055.html#a495926a48dd408a3b92de8a6b33f815a">mBestCost</a></td></tr>
<tr class="memdesc:a495926a48dd408a3b92de8a6b33f815a inherit pro_attribs_a00055"><td class="mdescLeft">&#160;</td><td class="mdescRight">Best value of the cost function so far. <br/></td></tr>
<tr class="memitem:aa9c2d238f7b60c7ea3bd715bf145b5d3 inherit pro_attribs_a00055"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa9c2d238f7b60c7ea3bd715bf145b5d3"></a>
long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00055.html#aa9c2d238f7b60c7ea3bd715bf145b5d3">mBestParSavedSetIndex</a></td></tr>
<tr class="memdesc:aa9c2d238f7b60c7ea3bd715bf145b5d3 inherit pro_attribs_a00055"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of the 'best' saved parameter set. <br/></td></tr>
<tr class="memitem:a7139f75c5b214ea00f99c2e4c25b2b34 inherit pro_attribs_a00055"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7139f75c5b214ea00f99c2e4c25b2b34"></a>
unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00055.html#a7139f75c5b214ea00f99c2e4c25b2b34">mContext</a></td></tr>
<tr class="memdesc:a7139f75c5b214ea00f99c2e4c25b2b34 inherit pro_attribs_a00055"><td class="mdescLeft">&#160;</td><td class="mdescRight">The current 'context', in the case the optimization is run in different parallel contexts. <br/></td></tr>
<tr class="memitem:a1b33baa71f4e0b182bae66766608425f inherit pro_attribs_a00055"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1b33baa71f4e0b182bae66766608425f"></a>
map&lt; unsigned long, map&lt; const <br class="typebreak"/>
<a class="el" href="a00071.html">RefinableObj</a> <br class="typebreak"/>
*, <a class="el" href="a00037.html">LogLikelihoodStats</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00055.html#a1b33baa71f4e0b182bae66766608425f">mvContextObjStats</a></td></tr>
<tr class="memdesc:a1b33baa71f4e0b182bae66766608425f inherit pro_attribs_a00055"><td class="mdescLeft">&#160;</td><td class="mdescRight">Statistics for each context (mutable for dynamic update during optimization) <br/></td></tr>
<tr class="memitem:a4b1120b0a6fc24c82c273152722f672c inherit pro_attribs_a00055"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4b1120b0a6fc24c82c273152722f672c"></a>
map&lt; const <a class="el" href="a00071.html">RefinableObj</a> <br class="typebreak"/>
*, DynamicObjWeight &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00055.html#a4b1120b0a6fc24c82c273152722f672c">mvObjWeight</a></td></tr>
<tr class="memdesc:a4b1120b0a6fc24c82c273152722f672c inherit pro_attribs_a00055"><td class="mdescLeft">&#160;</td><td class="mdescRight">Weights for each objects in each context (mutable for dynamic update during optimization) <br/></td></tr>
<tr class="memitem:a9063bb2fa6a6f0938295be2ffe2bfe84 inherit pro_attribs_a00055"><td class="memItemLeft" align="right" valign="top">std::vector&lt; pair&lt; long, REAL &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00055.html#a9063bb2fa6a6f0938295be2ffe2bfe84">mvSavedParamSet</a></td></tr>
<tr class="memdesc:a9063bb2fa6a6f0938295be2ffe2bfe84 inherit pro_attribs_a00055"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of saved parameter sets.  <a href="#a9063bb2fa6a6f0938295be2ffe2bfe84"></a><br/></td></tr>
<tr class="memitem:a712048cd592825ce31ced1120733345b inherit pro_attribs_a00055"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a712048cd592825ce31ced1120733345b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00055.html#a712048cd592825ce31ced1120733345b">mIsOptimizing</a></td></tr>
<tr class="memdesc:a712048cd592825ce31ced1120733345b inherit pro_attribs_a00055"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if a refinement is being done. For multi-threaded environment. <br/></td></tr>
<tr class="memitem:abec493a46c9e57c7e71e886bcae601fb inherit pro_attribs_a00055"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abec493a46c9e57c7e71e886bcae601fb"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00055.html#abec493a46c9e57c7e71e886bcae601fb">mStopAfterCycle</a></td></tr>
<tr class="memdesc:abec493a46c9e57c7e71e886bcae601fb inherit pro_attribs_a00055"><td class="mdescLeft">&#160;</td><td class="mdescRight">If true, then stop at the end of the cycle. Used in multi-threaded environment. <br/></td></tr>
<tr class="memitem:a73f491b5c8a0ae5f087e496916f76016 inherit pro_attribs_a00055"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a73f491b5c8a0ae5f087e496916f76016"></a>
<a class="el" href="a00054.html">ObjRegistry</a>&lt; <a class="el" href="a00071.html">RefinableObj</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00055.html#a73f491b5c8a0ae5f087e496916f76016">mRefinedObjList</a></td></tr>
<tr class="memdesc:a73f491b5c8a0ae5f087e496916f76016 inherit pro_attribs_a00055"><td class="mdescLeft">&#160;</td><td class="mdescRight">The refined objects. <br/></td></tr>
<tr class="memitem:a0e6a9e9d4d12ed73c582da36190f110f inherit pro_attribs_a00055"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00054.html">ObjRegistry</a>&lt; <a class="el" href="a00071.html">RefinableObj</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00055.html#a0e6a9e9d4d12ed73c582da36190f110f">mRecursiveRefinedObjList</a></td></tr>
<tr class="memdesc:a0e6a9e9d4d12ed73c582da36190f110f inherit pro_attribs_a00055"><td class="mdescLeft">&#160;</td><td class="mdescRight">The refined objects, recursively including all sub-objects.  <a href="#a0e6a9e9d4d12ed73c582da36190f110f"></a><br/></td></tr>
<tr class="memitem:a94038e1c477b1efa6417c13106d6bc89 inherit pro_attribs_a00055"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a94038e1c477b1efa6417c13106d6bc89"></a>
<a class="el" href="a00078.html">RefObjOpt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00055.html#a94038e1c477b1efa6417c13106d6bc89">mXMLAutoSave</a></td></tr>
<tr class="memdesc:a94038e1c477b1efa6417c13106d6bc89 inherit pro_attribs_a00055"><td class="mdescLeft">&#160;</td><td class="mdescRight">Periodic save of complete environment as an xml file. <br/></td></tr>
<tr class="memitem:abf309e1b2248a7e1d3744d4b20d15bfd inherit pro_attribs_a00055"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abf309e1b2248a7e1d3744d4b20d15bfd"></a>
REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00055.html#abf309e1b2248a7e1d3744d4b20d15bfd">mLastOptimTime</a></td></tr>
<tr class="memdesc:abf309e1b2248a7e1d3744d4b20d15bfd inherit pro_attribs_a00055"><td class="mdescLeft">&#160;</td><td class="mdescRight">The time elapsed after the last optimization, in seconds. <br/></td></tr>
<tr class="memitem:abe2f9a9812abe0f4a6c414457b5b2967 inherit pro_attribs_a00055"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00041.html">MainTracker</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00055.html#abe2f9a9812abe0f4a6c414457b5b2967">mMainTracker</a></td></tr>
<tr class="memdesc:abe2f9a9812abe0f4a6c414457b5b2967 inherit pro_attribs_a00055"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a00041.html" title="A class to hold all trackers.">MainTracker</a> object to track the evolution of cost functions, likelihood, and individual parameters.  <a href="#abe2f9a9812abe0f4a6c414457b5b2967"></a><br/></td></tr>
</table>
<a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Base object for Monte-Carlo Global Optimization methods. </p>
<p>The algorithm is quite simple, whith two type of optimizations, either simulated Annealing or Parallel Tempering, the latter being recommanded for most real-world optimizations. </p>
</div><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a503419b4b79fdb5ae41928656a888ec8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ObjCryst::MonteCarloObj::MonteCarloObj </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>internalUseOnly</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<p>Using internalUseOnly=true will avoid registering the the object to any registry, and thus (for example) no display will be created, nor will this object be automatically be saved. </p>

</div>
</div>
<h2>Member Function Documentation</h2>
<a class="anchor" id="abe55c9dd193cca72bf5b947a6eaf7fdd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ObjCryst::MonteCarloObj::InitLSQ </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>useFullPowderPatternProfile</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prepare mLSQ for least-squares refinement during the global optimization. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">useFullPowderPatternProfile,:</td><td>if true, the refinement will use the full profile version of powder patterns, otherwise only the integrated powder pattern will be used (faster). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae1689aa2dd5867499768328df935334d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ObjCryst::MonteCarloObj::MultiRunOptimize </td>
          <td>(</td>
          <td class="paramtype">long &amp;&#160;</td>
          <td class="paramname"><em>nbCycle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long &amp;&#160;</td>
          <td class="paramname"><em>nbSteps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>silent</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>finalcost</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>maxTime</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Launch optimization for multiple runs of N steps. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nbCycle,:</td><td>the number of runs (cycles) to perform. The structure is randomized at the beginning of each cycle. If nbCycle==-1, this will run indefinitely. The nbCycle parameter is decreased after each run. </td></tr>
    <tr><td class="paramname">nbSteps,:</td><td>the number of steps to go. This number is modified (decreases!) as the refinement goes on. </td></tr>
    <tr><td class="paramname">silent</td><td>: if true, absolutely no message should be printed (except debugging) </td></tr>
    <tr><td class="paramname">finalcost,:</td><td>the optimization will stop if overall cost fallse below this value </td></tr>
    <tr><td class="paramname">maxTime,:</td><td>the optimization will stop after the given number of seconds has been spent optimizing (ignored if &lt;0). </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="a00055.html#aa53575dbda2ec3f561bed934beb4ca6f">ObjCryst::OptimizationObj</a>.</p>

</div>
</div>
<a class="anchor" id="a8f177c8ada9f3cf392f8e8706eeae28b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ObjCryst::MonteCarloObj::NewConfiguration </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00080.html">RefParType</a> *&#160;</td>
          <td class="paramname"><em>type</em> = <code><a class="el" href="a00171.html#a92ed37a804903dfb302d70309b7bc474">gpRefParTypeObjCryst</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a random change in the configuration. </p>
<p>This just generates a new configuration with random changes (according to current parameters). The new configuration is <em>not</em> tested <em>in</em> <em>this</em> <em>function</em> vs temperature: this should be done in the <a class="el" href="a00055.html#a08c77dc6ec80f63bf067ef2968a0b6dc" title="Launch optimization (a single run) for N steps.">OptimizationObj::Optimize()</a> function, which also chooses whether to revert to the previous configuration.</p>
<p>Random moves are made by the objects and not by this function, because the new configuration can be specific (like, for example, permutations between some of the parameters (atoms)).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type,:</td><td>can be used to restrict the move to a given category of parameters. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aef060de8a302fb8c4e607e00667d7b49"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ObjCryst::MonteCarloObj::Optimize </td>
          <td>(</td>
          <td class="paramtype">long &amp;&#160;</td>
          <td class="paramname"><em>nbSteps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>silent</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>finalcost</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>maxTime</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Launch optimization (a single run) for N steps. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nbSteps,:</td><td>the number of steps to go. This number is modified (decreases!) as the refinement goes on. </td></tr>
    <tr><td class="paramname">silent</td><td>: if true, absolutely no message should be printed (except debugging) </td></tr>
    <tr><td class="paramname">finalcost,:</td><td>the optimization will stop if overall cost fallse below this value </td></tr>
    <tr><td class="paramname">maxTime,:</td><td>the optimization will stop after the given number of seconds has been spent optimizing (ignored if &lt;0). </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="a00055.html#a08c77dc6ec80f63bf067ef2968a0b6dc">ObjCryst::OptimizationObj</a>.</p>

</div>
</div>
<a class="anchor" id="a707045b814adb938fa5a1d8485074d21"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ObjCryst::MonteCarloObj::RunParallelTempering </td>
          <td>(</td>
          <td class="paramtype">long &amp;&#160;</td>
          <td class="paramname"><em>nbSteps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>silent</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>finalcost</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>maxTime</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Do a single Parallel Tempering run. This is called by Optimize(...) and <a class="el" href="a00050.html#ae1689aa2dd5867499768328df935334d" title="Launch optimization for multiple runs of N steps.">MultiRunOptimize()</a>, which must also prepare the optimization (<a class="el" href="a00055.html#a2f11f520bc1bd0b70f8aea98d3f8224c">PrepareRefParList()</a>, etc..). </p>

</div>
</div>
<a class="anchor" id="a80c15a8ba385e2e0f3e8a52451898fde"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ObjCryst::MonteCarloObj::RunSimulatedAnnealing </td>
          <td>(</td>
          <td class="paramtype">long &amp;&#160;</td>
          <td class="paramname"><em>nbSteps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>silent</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>finalcost</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>maxTime</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Do a single simulated annealing run. This is called by Optimize(...) and <a class="el" href="a00050.html#ae1689aa2dd5867499768328df935334d" title="Launch optimization for multiple runs of N steps.">MultiRunOptimize()</a>, which must also prepare the optimization (<a class="el" href="a00055.html#a2f11f520bc1bd0b70f8aea98d3f8224c">PrepareRefParList()</a>, etc..). </p>

</div>
</div>
<a class="anchor" id="a54c7ad3cb78846c82c65d6a6db27801a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ObjCryst::MonteCarloObj::SetAlgorithmParallTempering </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00171.html#a6ad2a3db75ca198897ce05b6e561eeca">AnnealingSchedule</a>&#160;</td>
          <td class="paramname"><em>scheduleTemp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>tMax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>tMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00171.html#a6ad2a3db75ca198897ce05b6e561eeca">AnnealingSchedule</a>&#160;</td>
          <td class="paramname"><em>scheduleMutation</em> = <code>ANNEALING_CONSTANT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>mutMax</em> = <code>16.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>mutMin</em> = <code>.125</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the refinement method to Parallel Tempering. </p>
<p>The refinement begins at max and finishes at min temperature.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scheduleTemp,:</td><td>temperature schedule </td></tr>
    <tr><td class="paramname">tMax,tMin,:</td><td>Max and Min temperatures. See AnnealingSchedule. </td></tr>
    <tr><td class="paramname">scheduleMutation,:</td><td>the mutation schedule. For each new configuration, the variation of each refinable parameter is less than its RefinablePar::GlobalOptimStep(), multiplied by the current mutation amplitude. By default this mutation is equal to 1., but making bigger steps can be a good idea at the beginning of the refinement. Thus you can choose a schedule for the amplitude, exactly like for the temperature. </td></tr>
    <tr><td class="paramname">mutMax,mutMin,:</td><td>Max and Min mutation amplitudes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>do not use the 'smart' option for the temperature schedule, it is not yet implemented. Later it will be used to set the temperatures as a function of the amplitude schedule, so that we keep accepted move between 30% and 70%. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>this will be removed when we separate the different algorithms in different classes. </dd></dl>

</div>
</div>
<a class="anchor" id="ac094251dbd02a4709dd4afb29d8454e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ObjCryst::MonteCarloObj::SetAlgorithmSimulAnnealing </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00171.html#a6ad2a3db75ca198897ce05b6e561eeca">AnnealingSchedule</a>&#160;</td>
          <td class="paramname"><em>scheduleTemp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>tMax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>tMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00171.html#a6ad2a3db75ca198897ce05b6e561eeca">AnnealingSchedule</a>&#160;</td>
          <td class="paramname"><em>scheduleMutation</em> = <code>ANNEALING_CONSTANT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>mutMax</em> = <code>16.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>mutMin</em> = <code>.125</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long&#160;</td>
          <td class="paramname"><em>nbTrialRetry</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>minCostRetry</em> = <code>0.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the refinement method to simulated Annealing. </p>
<p>Note that Parellel Tempering is more efficient to get out of local minima, so you sould rather use that method.</p>
<p>The refinement begins at max and finishes at min temperature.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scheduleTemp,:</td><td>temperature schedule. See AnnealingSchedule. </td></tr>
    <tr><td class="paramname">tMax,tMin,:</td><td>Max and Min temperatures. </td></tr>
    <tr><td class="paramname">scheduleMutation,:</td><td>the mutation schedule. For each new configuration, the variation of each refinable parameter is less than its RefinablePar::GlobalOptimStep(), multiplied by the current mutation amplitude. By default this mutation is equal to 1., but making bigger steps is a good idea at the beginning of the refinement (for higher temperatures). See AnnealingSchedule. See AnnealingSchedule. </td></tr>
    <tr><td class="paramname">mutMax,mutMin,:</td><td>Max and Min mutation amplitudes. </td></tr>
    <tr><td class="paramname">minCostRetry,nbTrialRetry,:</td><td>if after nbTrialRetry, the cost function is still above minCostRetry, then start again from a random configuration. No randomization is made if nbTrialRetry &lt;= 0. </td></tr>
    <tr><td class="paramname">maxNbTrialSinceBest,:</td><td>if more than maxNbTrialSinceBest trials have been made since the best configuration was recorded, then revert to that configuration. This should be large enough to have an ergodic search (the default is never to revert..)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>do not use the 'smart' option for the temperature schedule, it is not yet implemented. Later it will be used to set the temperatures as a function of the amplitude schedule, so that we accept between 30% and 70% moves. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>this will be removed when we separate the different algorithms in different classes. </dd></dl>

</div>
</div>
<a class="anchor" id="a2f9428857b1d26bbdac08d59debb9f52"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ObjCryst::MonteCarloObj::XMLInput </td>
          <td>(</td>
          <td class="paramtype">istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00151.html">XMLCrystTag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Input in XML format from a stream, restoring the set of refined objects and the associated cost functions. </p>
<p>Note that the corresponding objects must have been loaded in memory before, else shit happens. </p>

<p>Implements <a class="el" href="a00055.html#aa07aee60f56780e2c56fb20f4a5f48a8">ObjCryst::OptimizationObj</a>.</p>

</div>
</div>
<a class="anchor" id="a619eb171e5fe384be4d37f999dde8e0f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ObjCryst::MonteCarloObj::XMLOutput </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>indent</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Output a description of the object in XML format to a stream. </p>
<p>This saves the list of refined object and the cost functions, as well as options for the refinement. The refined objects are <b>not</b> saved, so this must be done somewhere else (they must be reloaded before this object). </p>

<p>Implements <a class="el" href="a00055.html#a6b7726159bb0d5dad1c7eebaee78f53a">ObjCryst::OptimizationObj</a>.</p>

</div>
</div>
<h2>Member Data Documentation</h2>
<a class="anchor" id="af5ab36ab840b6654f6738c30712b2f95"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00078.html">RefObjOpt</a> ObjCryst::MonteCarloObj::mGlobalOptimType</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Method used for the global optimization. </p>
<p>Should be removed when we switch to using several classes for different algorithms. </p>

</div>
</div>
<a class="anchor" id="afb02263e40ec89621bffe34ca859be96"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">REAL ObjCryst::MonteCarloObj::mMutationAmplitude</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mutation amplitude. </p>
<p>From .25 to 64. Random moves will have a maximum amplitude equal to this amplitude multiplied by the Global optimization step defined for each <a class="el" href="a00073.html" title="Generic class for parameters of refinable objects.">RefinablePar</a>. Large amplitude should be used at the beginning of the refinement (high temeratures). </p>

</div>
</div>
<a class="anchor" id="a22e972f1cb525f9dc5336fd1f47fa93b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long ObjCryst::MonteCarloObj::mNbTrialRetry</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of trials before testing if we are below the given minimum cost. </p>
<p>If &lt;=0, this will be ignored. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>GlobalOptimObj.h</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue May 7 2013 20:03:34 for ObjCryst++ by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.2
</small></address>
</body>
</html>
