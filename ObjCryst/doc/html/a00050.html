<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>ObjCryst++: ObjCryst::MonteCarloObj Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">ObjCryst++
   &#160;<span id="projectnumber">1.5CVS</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="a00171.html">ObjCryst</a>      </li>
      <li class="navelem"><a class="el" href="a00050.html">MonteCarloObj</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<div class="title">ObjCryst::MonteCarloObj Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="ObjCryst::MonteCarloObj" --><!-- doxytag: inherits="ObjCryst::OptimizationObj" -->
<p>Base object for Monte-Carlo Global Optimization methods.  
 <a href="a00050.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for ObjCryst::MonteCarloObj:</div>
<div class="dyncontent">
 <div class="center">
  <img src="a00050.png" usemap="#ObjCryst::MonteCarloObj_map" alt=""/>
  <map id="ObjCryst::MonteCarloObj_map" name="ObjCryst::MonteCarloObj_map">
<area href="a00055.html" title="Base object for Optimization methods." alt="ObjCryst::OptimizationObj" shape="rect" coords="0,0,156,24"/>
</map>
 </div></div>

<p><a href="a00315.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6ef446b8361a8c53d016f213f0d1e17f"></a><!-- doxytag: member="ObjCryst::MonteCarloObj::MonteCarloObj" ref="a6ef446b8361a8c53d016f213f0d1e17f" args="(const string name=&quot;&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#a6ef446b8361a8c53d016f213f0d1e17f">MonteCarloObj</a> (const string name=&quot;&quot;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#a503419b4b79fdb5ae41928656a888ec8">MonteCarloObj</a> (const bool internalUseOnly)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#a503419b4b79fdb5ae41928656a888ec8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7f928d56e60a279085c67e78dc334f39"></a><!-- doxytag: member="ObjCryst::MonteCarloObj::~MonteCarloObj" ref="a7f928d56e60a279085c67e78dc334f39" args="()" -->
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#a7f928d56e60a279085c67e78dc334f39">~MonteCarloObj</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#ac094251dbd02a4709dd4afb29d8454e5">SetAlgorithmSimulAnnealing</a> (const <a class="el" href="a00171.html#a6ad2a3db75ca198897ce05b6e561eeca">AnnealingSchedule</a> scheduleTemp, const REAL tMax, const REAL tMin, const <a class="el" href="a00171.html#a6ad2a3db75ca198897ce05b6e561eeca">AnnealingSchedule</a> scheduleMutation=ANNEALING_CONSTANT, const REAL mutMax=16., const REAL mutMin=.125, const long nbTrialRetry=0, const REAL minCostRetry=0.)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the refinement method to simulated Annealing.  <a href="#ac094251dbd02a4709dd4afb29d8454e5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#a54c7ad3cb78846c82c65d6a6db27801a">SetAlgorithmParallTempering</a> (const <a class="el" href="a00171.html#a6ad2a3db75ca198897ce05b6e561eeca">AnnealingSchedule</a> scheduleTemp, const REAL tMax, const REAL tMin, const <a class="el" href="a00171.html#a6ad2a3db75ca198897ce05b6e561eeca">AnnealingSchedule</a> scheduleMutation=ANNEALING_CONSTANT, const REAL mutMax=16., const REAL mutMin=.125)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the refinement method to Parallel Tempering.  <a href="#a54c7ad3cb78846c82c65d6a6db27801a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#aef060de8a302fb8c4e607e00667d7b49">Optimize</a> (long &amp;nbSteps, const bool silent=false, const REAL finalcost=0, const REAL maxTime=-1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Launch optimization (a single run) for N steps.  <a href="#aef060de8a302fb8c4e607e00667d7b49"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#ae1689aa2dd5867499768328df935334d">MultiRunOptimize</a> (long &amp;nbCycle, long &amp;nbSteps, const bool silent=false, const REAL finalcost=0, const REAL maxTime=-1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Launch optimization for multiple runs of N steps.  <a href="#ae1689aa2dd5867499768328df935334d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#a80c15a8ba385e2e0f3e8a52451898fde">RunSimulatedAnnealing</a> (long &amp;nbSteps, const bool silent=false, const REAL finalcost=0, const REAL maxTime=-1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#a707045b814adb938fa5a1d8485074d21">RunParallelTempering</a> (long &amp;nbSteps, const bool silent=false, const REAL finalcost=0, const REAL maxTime=-1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#a619eb171e5fe384be4d37f999dde8e0f">XMLOutput</a> (ostream &amp;os, int indent=0) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Output a description of the object in XML format to a stream.  <a href="#a619eb171e5fe384be4d37f999dde8e0f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#a2f9428857b1d26bbdac08d59debb9f52">XMLInput</a> (istream &amp;is, const <a class="el" href="a00151.html">XMLCrystTag</a> &amp;tag)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Input in XML format from a stream, restoring the set of refined objects and the associated cost functions.  <a href="#a2f9428857b1d26bbdac08d59debb9f52"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8093d58ee8d609cf89a52455df240882"></a><!-- doxytag: member="ObjCryst::MonteCarloObj::GetClassName" ref="a8093d58ee8d609cf89a52455df240882" args="() const " -->
virtual const string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#a8093d58ee8d609cf89a52455df240882">GetClassName</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name for this class type. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a517ee30d65b11c5172f4643aac8a8128"></a><!-- doxytag: member="ObjCryst::MonteCarloObj::GetLSQObj" ref="a517ee30d65b11c5172f4643aac8a8128" args="()" -->
<a class="el" href="a00039.html">LSQNumObj</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#a517ee30d65b11c5172f4643aac8a8128">GetLSQObj</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to the builtin LSQ optimization object. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a695d603e54e12bbf9cd6efa6282ee948"></a><!-- doxytag: member="ObjCryst::MonteCarloObj::GetLSQObj" ref="a695d603e54e12bbf9cd6efa6282ee948" args="() const " -->
const <a class="el" href="a00039.html">LSQNumObj</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#a695d603e54e12bbf9cd6efa6282ee948">GetLSQObj</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to the builtin LSQ optimization object. <br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#a8f177c8ada9f3cf392f8e8706eeae28b">NewConfiguration</a> (const <a class="el" href="a00080.html">RefParType</a> *type=<a class="el" href="a00171.html#a92ed37a804903dfb302d70309b7bc474">gpRefParTypeObjCryst</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a random change in the configuration.  <a href="#a8f177c8ada9f3cf392f8e8706eeae28b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa9c005fcbe5c600efe2dee1a2c7697a4"></a><!-- doxytag: member="ObjCryst::MonteCarloObj::InitOptions" ref="aa9c005fcbe5c600efe2dee1a2c7697a4" args="()" -->
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#aa9c005fcbe5c600efe2dee1a2c7697a4">InitOptions</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialization of options. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#abe55c9dd193cca72bf5b947a6eaf7fdd">InitLSQ</a> (const bool useFullPowderPatternProfile=true)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare mLSQ for least-squares refinement during the global optimization.  <a href="#abe55c9dd193cca72bf5b947a6eaf7fdd"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00078.html">RefObjOpt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#af5ab36ab840b6654f6738c30712b2f95">mGlobalOptimType</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Method used for the global optimization.  <a href="#af5ab36ab840b6654f6738c30712b2f95"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a96805488cd133249ec1c24c67d3a2dda"></a><!-- doxytag: member="ObjCryst::MonteCarloObj::mCurrentCost" ref="a96805488cd133249ec1c24c67d3a2dda" args="" -->
REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#a96805488cd133249ec1c24c67d3a2dda">mCurrentCost</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Current value of the cost function. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac782f38b1343464aa3db886873798107"></a><!-- doxytag: member="ObjCryst::MonteCarloObj::mSaveTrackedData" ref="ac782f38b1343464aa3db886873798107" args="" -->
<a class="el" href="a00078.html">RefObjOpt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#ac782f38b1343464aa3db886873798107">mSaveTrackedData</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Option to save the evolution of tracked data (cost functions, likelihhod, individual parameters,...) <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a17997726361536481a041fb5736fedb9"></a><!-- doxytag: member="ObjCryst::MonteCarloObj::mTemperature" ref="a17997726361536481a041fb5736fedb9" args="" -->
REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#a17997726361536481a041fb5736fedb9">mTemperature</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Current temperature for annealing. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1256bc3d6ceae83f8b36de6141a8945d"></a><!-- doxytag: member="ObjCryst::MonteCarloObj::mTemperatureMax" ref="a1256bc3d6ceae83f8b36de6141a8945d" args="" -->
REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#a1256bc3d6ceae83f8b36de6141a8945d">mTemperatureMax</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Beginning temperature for annealing. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8ba61158d22cd66be193aabcd41dd9f6"></a><!-- doxytag: member="ObjCryst::MonteCarloObj::mTemperatureMin" ref="a8ba61158d22cd66be193aabcd41dd9f6" args="" -->
REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#a8ba61158d22cd66be193aabcd41dd9f6">mTemperatureMin</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Lower temperature. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae630f1608e3be9b01159d0780980eb08"></a><!-- doxytag: member="ObjCryst::MonteCarloObj::mAnnealingScheduleTemp" ref="ae630f1608e3be9b01159d0780980eb08" args="" -->
<a class="el" href="a00078.html">RefObjOpt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#ae630f1608e3be9b01159d0780980eb08">mAnnealingScheduleTemp</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule for the annealing. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af1a7aeb7079f01175fbef95b31ca47af"></a><!-- doxytag: member="ObjCryst::MonteCarloObj::mTemperatureGamma" ref="af1a7aeb7079f01175fbef95b31ca47af" args="" -->
REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#af1a7aeb7079f01175fbef95b31ca47af">mTemperatureGamma</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gamma for the 'gamma' temperature schedule. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#afb02263e40ec89621bffe34ca859be96">mMutationAmplitude</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutation amplitude.  <a href="#afb02263e40ec89621bffe34ca859be96"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae56181bde6b87eeeb24a6fdd1428a0b9"></a><!-- doxytag: member="ObjCryst::MonteCarloObj::mMutationAmplitudeMax" ref="ae56181bde6b87eeeb24a6fdd1428a0b9" args="" -->
REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#ae56181bde6b87eeeb24a6fdd1428a0b9">mMutationAmplitudeMax</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutation amplitude at the beginning of the optimization. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6f4e6631d2079c0ac3f82a271a6ad3ec"></a><!-- doxytag: member="ObjCryst::MonteCarloObj::mMutationAmplitudeMin" ref="a6f4e6631d2079c0ac3f82a271a6ad3ec" args="" -->
REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#a6f4e6631d2079c0ac3f82a271a6ad3ec">mMutationAmplitudeMin</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutation amplitude at the end of the optimization. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5bb4e03ae2221be34131f4c0f108271e"></a><!-- doxytag: member="ObjCryst::MonteCarloObj::mAnnealingScheduleMutation" ref="a5bb4e03ae2221be34131f4c0f108271e" args="" -->
<a class="el" href="a00078.html">RefObjOpt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#a5bb4e03ae2221be34131f4c0f108271e">mAnnealingScheduleMutation</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule for the annealing. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1cfbd1b4fc984a06a02c5102a9dcfcd3"></a><!-- doxytag: member="ObjCryst::MonteCarloObj::mMutationAmplitudeGamma" ref="a1cfbd1b4fc984a06a02c5102a9dcfcd3" args="" -->
REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#a1cfbd1b4fc984a06a02c5102a9dcfcd3">mMutationAmplitudeGamma</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gamma for the 'gamma' Mutation amplitude schedule. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#a22e972f1cb525f9dc5336fd1f47fa93b">mNbTrialRetry</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of trials before testing if we are below the given minimum cost.  <a href="#a22e972f1cb525f9dc5336fd1f47fa93b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9a45d65ee6522c4dc159a91fdb4c1661"></a><!-- doxytag: member="ObjCryst::MonteCarloObj::mMinCostRetry" ref="a9a45d65ee6522c4dc159a91fdb4c1661" args="" -->
REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#a9a45d65ee6522c4dc159a91fdb4c1661">mMinCostRetry</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Cost to reach unless an automatic randomization and retry is done. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a36b4c13151172e24108d6578d63d1125"></a><!-- doxytag: member="ObjCryst::MonteCarloObj::mLSQ" ref="a36b4c13151172e24108d6578d63d1125" args="" -->
<a class="el" href="a00039.html">LSQNumObj</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#a36b4c13151172e24108d6578d63d1125">mLSQ</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Least squares object. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3d6e159362a2f93d5a2883e60f1710d8"></a><!-- doxytag: member="ObjCryst::MonteCarloObj::mAutoLSQ" ref="a3d6e159362a2f93d5a2883e60f1710d8" args="" -->
<a class="el" href="a00078.html">RefObjOpt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#a3d6e159362a2f93d5a2883e60f1710d8">mAutoLSQ</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Option to run automatic least-squares refinements. <br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Base object for Monte-Carlo Global Optimization methods. </p>
<p>The algorithm is quite simple, whith two type of optimizations, either simulated Annealing or Parallel Tempering, the latter being recommanded for most real-world optimizations. </p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a503419b4b79fdb5ae41928656a888ec8"></a><!-- doxytag: member="ObjCryst::MonteCarloObj::MonteCarloObj" ref="a503419b4b79fdb5ae41928656a888ec8" args="(const bool internalUseOnly)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00050.html#a6ef446b8361a8c53d016f213f0d1e17f">ObjCryst::MonteCarloObj::MonteCarloObj</a> </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>internalUseOnly</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor. </p>
<p>Using internalUseOnly=true will avoid registering the the object to any registry, and thus (for example) no display will be created, nor will this object be automatically be saved. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="abe55c9dd193cca72bf5b947a6eaf7fdd"></a><!-- doxytag: member="ObjCryst::MonteCarloObj::InitLSQ" ref="abe55c9dd193cca72bf5b947a6eaf7fdd" args="(const bool useFullPowderPatternProfile=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="a00050.html#abe55c9dd193cca72bf5b947a6eaf7fdd">ObjCryst::MonteCarloObj::InitLSQ</a> </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>useFullPowderPatternProfile</em> = <code>true</code></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prepare mLSQ for least-squares refinement during the global optimization. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">useFullPowderPatternProfile,:</td><td>if true, the refinement will use the full profile version of powder patterns, otherwise only the integrated powder pattern will be used (faster). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae1689aa2dd5867499768328df935334d"></a><!-- doxytag: member="ObjCryst::MonteCarloObj::MultiRunOptimize" ref="ae1689aa2dd5867499768328df935334d" args="(long &amp;nbCycle, long &amp;nbSteps, const bool silent=false, const REAL finalcost=0, const REAL maxTime=&#45;1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="a00050.html#ae1689aa2dd5867499768328df935334d">ObjCryst::MonteCarloObj::MultiRunOptimize</a> </td>
          <td>(</td>
          <td class="paramtype">long &amp;&#160;</td>
          <td class="paramname"><em>nbCycle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long &amp;&#160;</td>
          <td class="paramname"><em>nbSteps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>silent</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>finalcost</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>maxTime</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Launch optimization for multiple runs of N steps. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">nbCycle,:</td><td>the number of runs (cycles) to perform. The structure is randomized at the beginning of each cycle. If nbCycle==-1, this will run indefinitely. The nbCycle parameter is decreased after each run. </td></tr>
    <tr><td class="paramname">nbSteps,:</td><td>the number of steps to go. This number is modified (decreases!) as the refinement goes on. </td></tr>
    <tr><td class="paramname">silent</td><td>: if true, absolutely no message should be printed (except debugging) </td></tr>
    <tr><td class="paramname">finalcost,:</td><td>the optimization will stop if overall cost fallse below this value </td></tr>
    <tr><td class="paramname">maxTime,:</td><td>the optimization will stop after the given number of seconds has been spent optimizing (ignored if &lt;0). </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="a00055.html#aa53575dbda2ec3f561bed934beb4ca6f">ObjCryst::OptimizationObj</a>.</p>

</div>
</div>
<a class="anchor" id="a8f177c8ada9f3cf392f8e8706eeae28b"></a><!-- doxytag: member="ObjCryst::MonteCarloObj::NewConfiguration" ref="a8f177c8ada9f3cf392f8e8706eeae28b" args="(const RefParType *type=gpRefParTypeObjCryst)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="a00050.html#a8f177c8ada9f3cf392f8e8706eeae28b">ObjCryst::MonteCarloObj::NewConfiguration</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00080.html">RefParType</a> *&#160;</td>
          <td class="paramname"><em>type</em> = <code><a class="el" href="a00171.html#a92ed37a804903dfb302d70309b7bc474">gpRefParTypeObjCryst</a></code></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Make a random change in the configuration. </p>
<p>This just generates a new configuration with random changes (according to current parameters). The new configuration is <em>not</em> tested <em>in</em> <em>this</em> <em>function</em> vs temperature: this should be done in the <a class="el" href="a00055.html#a08c77dc6ec80f63bf067ef2968a0b6dc" title="Launch optimization (a single run) for N steps.">OptimizationObj::Optimize()</a> function, which also chooses whether to revert to the previous configuration.</p>
<p>Random moves are made by the objects and not by this function, because the new configuration can be specific (like, for example, permutations between some of the parameters (atoms)).</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">type,:</td><td>can be used to restrict the move to a given category of parameters. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aef060de8a302fb8c4e607e00667d7b49"></a><!-- doxytag: member="ObjCryst::MonteCarloObj::Optimize" ref="aef060de8a302fb8c4e607e00667d7b49" args="(long &amp;nbSteps, const bool silent=false, const REAL finalcost=0, const REAL maxTime=&#45;1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="a00050.html#aef060de8a302fb8c4e607e00667d7b49">ObjCryst::MonteCarloObj::Optimize</a> </td>
          <td>(</td>
          <td class="paramtype">long &amp;&#160;</td>
          <td class="paramname"><em>nbSteps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>silent</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>finalcost</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>maxTime</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Launch optimization (a single run) for N steps. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">nbSteps,:</td><td>the number of steps to go. This number is modified (decreases!) as the refinement goes on. </td></tr>
    <tr><td class="paramname">silent</td><td>: if true, absolutely no message should be printed (except debugging) </td></tr>
    <tr><td class="paramname">finalcost,:</td><td>the optimization will stop if overall cost fallse below this value </td></tr>
    <tr><td class="paramname">maxTime,:</td><td>the optimization will stop after the given number of seconds has been spent optimizing (ignored if &lt;0). </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="a00055.html#a08c77dc6ec80f63bf067ef2968a0b6dc">ObjCryst::OptimizationObj</a>.</p>

</div>
</div>
<a class="anchor" id="a707045b814adb938fa5a1d8485074d21"></a><!-- doxytag: member="ObjCryst::MonteCarloObj::RunParallelTempering" ref="a707045b814adb938fa5a1d8485074d21" args="(long &amp;nbSteps, const bool silent=false, const REAL finalcost=0, const REAL maxTime=&#45;1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00050.html#a707045b814adb938fa5a1d8485074d21">ObjCryst::MonteCarloObj::RunParallelTempering</a> </td>
          <td>(</td>
          <td class="paramtype">long &amp;&#160;</td>
          <td class="paramname"><em>nbSteps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>silent</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>finalcost</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>maxTime</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Do a single Parallel Tempering run. This is called by Optimize(...) and <a class="el" href="a00050.html#ae1689aa2dd5867499768328df935334d" title="Launch optimization for multiple runs of N steps.">MultiRunOptimize()</a>, which must also prepare the optimization (<a class="el" href="a00055.html#a2f11f520bc1bd0b70f8aea98d3f8224c">PrepareRefParList()</a>, etc..). </p>

</div>
</div>
<a class="anchor" id="a80c15a8ba385e2e0f3e8a52451898fde"></a><!-- doxytag: member="ObjCryst::MonteCarloObj::RunSimulatedAnnealing" ref="a80c15a8ba385e2e0f3e8a52451898fde" args="(long &amp;nbSteps, const bool silent=false, const REAL finalcost=0, const REAL maxTime=&#45;1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00050.html#a80c15a8ba385e2e0f3e8a52451898fde">ObjCryst::MonteCarloObj::RunSimulatedAnnealing</a> </td>
          <td>(</td>
          <td class="paramtype">long &amp;&#160;</td>
          <td class="paramname"><em>nbSteps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>silent</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>finalcost</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>maxTime</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Do a single simulated annealing run. This is called by Optimize(...) and <a class="el" href="a00050.html#ae1689aa2dd5867499768328df935334d" title="Launch optimization for multiple runs of N steps.">MultiRunOptimize()</a>, which must also prepare the optimization (<a class="el" href="a00055.html#a2f11f520bc1bd0b70f8aea98d3f8224c">PrepareRefParList()</a>, etc..). </p>

</div>
</div>
<a class="anchor" id="a54c7ad3cb78846c82c65d6a6db27801a"></a><!-- doxytag: member="ObjCryst::MonteCarloObj::SetAlgorithmParallTempering" ref="a54c7ad3cb78846c82c65d6a6db27801a" args="(const AnnealingSchedule scheduleTemp, const REAL tMax, const REAL tMin, const AnnealingSchedule scheduleMutation=ANNEALING_CONSTANT, const REAL mutMax=16., const REAL mutMin=.125)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00050.html#a54c7ad3cb78846c82c65d6a6db27801a">ObjCryst::MonteCarloObj::SetAlgorithmParallTempering</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00171.html#a6ad2a3db75ca198897ce05b6e561eeca">AnnealingSchedule</a>&#160;</td>
          <td class="paramname"><em>scheduleTemp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>tMax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>tMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00171.html#a6ad2a3db75ca198897ce05b6e561eeca">AnnealingSchedule</a>&#160;</td>
          <td class="paramname"><em>scheduleMutation</em> = <code>ANNEALING_CONSTANT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>mutMax</em> = <code>16.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>mutMin</em> = <code>.125</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the refinement method to Parallel Tempering. </p>
<p>The refinement begins at max and finishes at min temperature.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">scheduleTemp,:</td><td>temperature schedule </td></tr>
    <tr><td class="paramname">tMax,tMin,:</td><td>Max and Min temperatures. See AnnealingSchedule. </td></tr>
    <tr><td class="paramname">scheduleMutation,:</td><td>the mutation schedule. For each new configuration, the variation of each refinable parameter is less than its RefinablePar::GlobalOptimStep(), multiplied by the current mutation amplitude. By default this mutation is equal to 1., but making bigger steps can be a good idea at the beginning of the refinement. Thus you can choose a schedule for the amplitude, exactly like for the temperature. </td></tr>
    <tr><td class="paramname">mutMax,mutMin,:</td><td>Max and Min mutation amplitudes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>do not use the 'smart' option for the temperature schedule, it is not yet implemented. Later it will be used to set the temperatures as a function of the amplitude schedule, so that we keep accepted move between 30% and 70%. </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>this will be removed when we separate the different algorithms in different classes. </dd></dl>

</div>
</div>
<a class="anchor" id="ac094251dbd02a4709dd4afb29d8454e5"></a><!-- doxytag: member="ObjCryst::MonteCarloObj::SetAlgorithmSimulAnnealing" ref="ac094251dbd02a4709dd4afb29d8454e5" args="(const AnnealingSchedule scheduleTemp, const REAL tMax, const REAL tMin, const AnnealingSchedule scheduleMutation=ANNEALING_CONSTANT, const REAL mutMax=16., const REAL mutMin=.125, const long nbTrialRetry=0, const REAL minCostRetry=0.)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00050.html#ac094251dbd02a4709dd4afb29d8454e5">ObjCryst::MonteCarloObj::SetAlgorithmSimulAnnealing</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00171.html#a6ad2a3db75ca198897ce05b6e561eeca">AnnealingSchedule</a>&#160;</td>
          <td class="paramname"><em>scheduleTemp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>tMax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>tMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00171.html#a6ad2a3db75ca198897ce05b6e561eeca">AnnealingSchedule</a>&#160;</td>
          <td class="paramname"><em>scheduleMutation</em> = <code>ANNEALING_CONSTANT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>mutMax</em> = <code>16.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>mutMin</em> = <code>.125</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long&#160;</td>
          <td class="paramname"><em>nbTrialRetry</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>minCostRetry</em> = <code>0.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the refinement method to simulated Annealing. </p>
<p>Note that Parellel Tempering is more efficient to get out of local minima, so you sould rather use that method.</p>
<p>The refinement begins at max and finishes at min temperature.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">scheduleTemp,:</td><td>temperature schedule. See AnnealingSchedule. </td></tr>
    <tr><td class="paramname">tMax,tMin,:</td><td>Max and Min temperatures. </td></tr>
    <tr><td class="paramname">scheduleMutation,:</td><td>the mutation schedule. For each new configuration, the variation of each refinable parameter is less than its RefinablePar::GlobalOptimStep(), multiplied by the current mutation amplitude. By default this mutation is equal to 1., but making bigger steps is a good idea at the beginning of the refinement (for higher temperatures). See AnnealingSchedule. See AnnealingSchedule. </td></tr>
    <tr><td class="paramname">mutMax,mutMin,:</td><td>Max and Min mutation amplitudes. </td></tr>
    <tr><td class="paramname">minCostRetry,nbTrialRetry,:</td><td>if after nbTrialRetry, the cost function is still above minCostRetry, then start again from a random configuration. No randomization is made if nbTrialRetry &lt;= 0. </td></tr>
    <tr><td class="paramname">maxNbTrialSinceBest,:</td><td>if more than maxNbTrialSinceBest trials have been made since the best configuration was recorded, then revert to that configuration. This should be large enough to have an ergodic search (the default is never to revert..)</td></tr>
  </table>
  </dd>
</dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>do not use the 'smart' option for the temperature schedule, it is not yet implemented. Later it will be used to set the temperatures as a function of the amplitude schedule, so that we accept between 30% and 70% moves. </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>this will be removed when we separate the different algorithms in different classes. </dd></dl>

</div>
</div>
<a class="anchor" id="a2f9428857b1d26bbdac08d59debb9f52"></a><!-- doxytag: member="ObjCryst::MonteCarloObj::XMLInput" ref="a2f9428857b1d26bbdac08d59debb9f52" args="(istream &amp;is, const XMLCrystTag &amp;tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="a00050.html#a2f9428857b1d26bbdac08d59debb9f52">ObjCryst::MonteCarloObj::XMLInput</a> </td>
          <td>(</td>
          <td class="paramtype">istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00151.html">XMLCrystTag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Input in XML format from a stream, restoring the set of refined objects and the associated cost functions. </p>
<p>Note that the corresponding objects must have been loaded in memory before, else shit happens. </p>

<p>Implements <a class="el" href="a00055.html#aa07aee60f56780e2c56fb20f4a5f48a8">ObjCryst::OptimizationObj</a>.</p>

</div>
</div>
<a class="anchor" id="a619eb171e5fe384be4d37f999dde8e0f"></a><!-- doxytag: member="ObjCryst::MonteCarloObj::XMLOutput" ref="a619eb171e5fe384be4d37f999dde8e0f" args="(ostream &amp;os, int indent=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="a00050.html#a619eb171e5fe384be4d37f999dde8e0f">ObjCryst::MonteCarloObj::XMLOutput</a> </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>indent</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Output a description of the object in XML format to a stream. </p>
<p>This saves the list of refined object and the cost functions, as well as options for the refinement. The refined objects are <b>not</b> saved, so this must be done somewhere else (they must be reloaded before this object). </p>

<p>Implements <a class="el" href="a00055.html#a6b7726159bb0d5dad1c7eebaee78f53a">ObjCryst::OptimizationObj</a>.</p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="af5ab36ab840b6654f6738c30712b2f95"></a><!-- doxytag: member="ObjCryst::MonteCarloObj::mGlobalOptimType" ref="af5ab36ab840b6654f6738c30712b2f95" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00078.html">RefObjOpt</a> <a class="el" href="a00050.html#af5ab36ab840b6654f6738c30712b2f95">ObjCryst::MonteCarloObj::mGlobalOptimType</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Method used for the global optimization. </p>
<p>Should be removed when we switch to using several classes for different algorithms. </p>

</div>
</div>
<a class="anchor" id="afb02263e40ec89621bffe34ca859be96"></a><!-- doxytag: member="ObjCryst::MonteCarloObj::mMutationAmplitude" ref="afb02263e40ec89621bffe34ca859be96" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">REAL <a class="el" href="a00050.html#afb02263e40ec89621bffe34ca859be96">ObjCryst::MonteCarloObj::mMutationAmplitude</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Mutation amplitude. </p>
<p>From .25 to 64. Random moves will have a maximum amplitude equal to this amplitude multiplied by the Global optimization step defined for each <a class="el" href="a00073.html" title="Generic class for parameters of refinable objects.">RefinablePar</a>. Large amplitude should be used at the beginning of the refinement (high temeratures). </p>

</div>
</div>
<a class="anchor" id="a22e972f1cb525f9dc5336fd1f47fa93b"></a><!-- doxytag: member="ObjCryst::MonteCarloObj::mNbTrialRetry" ref="a22e972f1cb525f9dc5336fd1f47fa93b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long <a class="el" href="a00050.html#a22e972f1cb525f9dc5336fd1f47fa93b">ObjCryst::MonteCarloObj::mNbTrialRetry</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Number of trials before testing if we are below the given minimum cost. </p>
<p>If &lt;=0, this will be ignored. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>GlobalOptimObj.h</li>
</ul>
</div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Sat Jan 28 2012 12:39:00 for ObjCryst++ by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
