<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>ObjCryst++: ObjCryst::ScatteringPowerSphere Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.2-20100208 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="a00170.html">ObjCryst</a>::<a class="el" href="a00091.html">ScatteringPowerSphere</a>
  </div>
</div>
<div class="contents">
<h1>ObjCryst::ScatteringPowerSphere Class Reference</h1><!-- doxytag: class="ObjCryst::ScatteringPowerSphere" --><!-- doxytag: inherits="ObjCryst::ScatteringPower" -->
<p>\ brief <a class="el" href="a00089.html" title="Abstract Base Class to describe the scattering power of any Scatterer component in...">ScatteringPower</a> for a spherical particule  
<a href="#_details">More...</a></p>
<div class="dynheader">
Inheritance diagram for ObjCryst::ScatteringPowerSphere:</div>
<div class="dynsection">
 <div class="center">
  <img src="a00091.png" usemap="#ObjCryst::ScatteringPowerSphere_map" alt=""/>
  <map id="ObjCryst::ScatteringPowerSphere_map" name="ObjCryst::ScatteringPowerSphere_map">
<area href="a00089.html" alt="ObjCryst::ScatteringPower" shape="rect" coords="0,56,202,80"/>
<area href="a00070.html" alt="ObjCryst::RefinableObj" shape="rect" coords="0,0,202,24"/>
</map>
 </div>
</div>

<p><a href="a00299.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2d28cd4a75be9b4f9f784329ed2401d6"></a><!-- doxytag: member="ObjCryst::ScatteringPowerSphere::ScatteringPowerSphere" ref="a2d28cd4a75be9b4f9f784329ed2401d6" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00091.html#a2d28cd4a75be9b4f9f784329ed2401d6">ScatteringPowerSphere</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default constructor. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00091.html#a2d50cba1b4405f52f1dd4148907a88c5">ScatteringPowerSphere</a> (const string &amp;name, const REAL radius, const REAL bIso=1.0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">constructor  <a href="#a2d50cba1b4405f52f1dd4148907a88c5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad5b2d4703250ae10fb27f8929a904d47"></a><!-- doxytag: member="ObjCryst::ScatteringPowerSphere::ScatteringPowerSphere" ref="ad5b2d4703250ae10fb27f8929a904d47" args="(const ScatteringPowerSphere &amp;old)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><b>ScatteringPowerSphere</b> (const <a class="el" href="a00091.html">ScatteringPowerSphere</a> &amp;old)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa6795f9a244597425863c410e40153f5"></a><!-- doxytag: member="ObjCryst::ScatteringPowerSphere::Init" ref="aa6795f9a244597425863c410e40153f5" args="(const string &amp;name, const REAL radius, const REAL bIso=1.0)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>Init</b> (const string &amp;name, const REAL radius, const REAL bIso=1.0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00091.html#a57e85d29926fe93da66041a43583e893">GetClassName</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Name for this class ("RefinableObj", "Crystal",.  <a href="#a57e85d29926fe93da66041a43583e893"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual CrystVector_REAL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00091.html#a073f08b17ba89e0ac5ed8e1a61cb04fe">GetScatteringFactor</a> (const <a class="el" href="a00088.html">ScatteringData</a> &amp;data, const int spgSymPosIndex=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the Scattering factor for all reflections of a given <a class="el" href="a00088.html" title="Class to compute structure factors for a set of reflections and a Crystal.">ScatteringData</a> object.  <a href="#a073f08b17ba89e0ac5ed8e1a61cb04fe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual REAL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00091.html#a9bd142cc8112495d41393b4faffc4fcd">GetForwardScatteringFactor</a> (const <a class="el" href="a00170.html#a48fe50a094c607f8897378934d3d73ef">RadiationType</a>) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the scattering factor at (0,0,0).  <a href="#a9bd142cc8112495d41393b4faffc4fcd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual CrystVector_REAL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00091.html#a3927291a20f5807c2ec6a9ae3627005d">GetTemperatureFactor</a> (const <a class="el" href="a00088.html">ScatteringData</a> &amp;data, const int spgSymPosIndex=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the temperature factor for all reflections of a given <a class="el" href="a00088.html" title="Class to compute structure factors for a set of reflections and a Crystal.">ScatteringData</a> object.  <a href="#a3927291a20f5807c2ec6a9ae3627005d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual CrystMatrix_REAL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00091.html#a064671bfd711ef108be7a1528e52cd46">GetResonantScattFactReal</a> (const <a class="el" href="a00088.html">ScatteringData</a> &amp;data, const int spgSymPosIndex=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the real part of the resonant scattering factor.  <a href="#a064671bfd711ef108be7a1528e52cd46"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual CrystMatrix_REAL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00091.html#aee221744487a1c29023399b71e855c06">GetResonantScattFactImag</a> (const <a class="el" href="a00088.html">ScatteringData</a> &amp;data, const int spgSymPosIndex=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the imaginary part of the resonant scattering factor.  <a href="#aee221744487a1c29023399b71e855c06"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">REAL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00091.html#a1f4b091f0990b959acb0645fd575a080">GetRadius</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the physical radius of this type of scatterer (for 3D display purposes).  <a href="#a1f4b091f0990b959acb0645fd575a080"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7e57e15bff5886955532dcacae65cf6c"></a><!-- doxytag: member="ObjCryst::ScatteringPowerSphere::Print" ref="a7e57e15bff5886955532dcacae65cf6c" args="() const " -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>Print</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00091.html#a050e8e8b21857ec0593bbb41fd123e39">XMLOutput</a> (ostream &amp;os, int indent=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Output to stream in well-formed XML.  <a href="#a050e8e8b21857ec0593bbb41fd123e39"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00091.html#aaaf687a105e65c6522521a0f01a98acf">XMLInput</a> (istream &amp;is, const <a class="el" href="a00150.html">XMLCrystTag</a> &amp;tag)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Input From stream.  <a href="#aaaf687a105e65c6522521a0f01a98acf"></a><br/></td></tr>
<tr><td colspan="2"><h2>Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab586ccb9566d5bc1d2d952eded4e1979"></a><!-- doxytag: member="ObjCryst::ScatteringPowerSphere::InitRefParList" ref="ab586ccb9566d5bc1d2d952eded4e1979" args="()" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>InitRefParList</b> ()</td></tr>
<tr><td colspan="2"><h2>Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a258a4384486392c2019a1e0ee83c1408"></a><!-- doxytag: member="ObjCryst::ScatteringPowerSphere::mBiso" ref="a258a4384486392c2019a1e0ee83c1408" args="" -->
REAL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00091.html#a258a4384486392c2019a1e0ee83c1408">mBiso</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Isotropic temperature B-factor. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a21d5b0449cb5c76b90f224cdacf3dc0d"></a><!-- doxytag: member="ObjCryst::ScatteringPowerSphere::mRadius" ref="a21d5b0449cb5c76b90f224cdacf3dc0d" args="" -->
REAL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00091.html#a21d5b0449cb5c76b90f224cdacf3dc0d">mRadius</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Radius of the sphere. <br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>\ brief <a class="el" href="a00089.html" title="Abstract Base Class to describe the scattering power of any Scatterer component in...">ScatteringPower</a> for a spherical particule </p>
<p>This can be used to modelize the form factor of disordered (or low-resolution) of fullerene-type compounds, where all atoms are located on a sphere.</p>
<p>This actually modelizes a spherical distribution of a <em>single</em> electron, so to modelize C60 the occupancy must be set to 60*6. </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a2d50cba1b4405f52f1dd4148907a88c5"></a><!-- doxytag: member="ObjCryst::ScatteringPowerSphere::ScatteringPowerSphere" ref="a2d50cba1b4405f52f1dd4148907a88c5" args="(const string &amp;name, const REAL radius, const REAL bIso=1.0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ObjCryst::ScatteringPowerSphere::ScatteringPowerSphere </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&nbsp;</td>
          <td class="paramname"> <em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&nbsp;</td>
          <td class="paramname"> <em>bIso</em> = <code>1.0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>constructor </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>: name of the <a class="el" href="a00089.html" title="Abstract Base Class to describe the scattering power of any Scatterer component in...">ScatteringPower</a> ('C60','France 98'...). The name can have <em>any</em> format </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nbAtom,:</em>&nbsp;</td><td>the number of atoms </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>biso</em>&nbsp;</td><td>: Isotropic thermic coefficient </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>AxisLengthX,AxisLengthY,AxisLengthZ,:</em>&nbsp;</td><td>length of the different main axis of the ellipsoid </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>symbol,:</em>&nbsp;</td><td>the symbol of the element associated to this fullerene. By default it is assumed to be carbon </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a57e85d29926fe93da66041a43583e893"></a><!-- doxytag: member="ObjCryst::ScatteringPowerSphere::GetClassName" ref="a57e85d29926fe93da66041a43583e893" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const string&amp; ObjCryst::ScatteringPowerSphere::GetClassName </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Name for this class ("RefinableObj", "Crystal",. </p>
<p>..). This is only useful to distinguish different classes when picking up objects from the <a class="el" href="a00070.html" title="Generic Refinable Object.">RefinableObj</a> Global Registry </p>

<p>Reimplemented from <a class="el" href="a00089.html#ac31cc4135011046f93d49f4173aee3ee">ObjCryst::ScatteringPower</a>.</p>

</div>
</div>
<a class="anchor" id="a9bd142cc8112495d41393b4faffc4fcd"></a><!-- doxytag: member="ObjCryst::ScatteringPowerSphere::GetForwardScatteringFactor" ref="a9bd142cc8112495d41393b4faffc4fcd" args="(const RadiationType) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual REAL ObjCryst::ScatteringPowerSphere::GetForwardScatteringFactor </td>
          <td>(</td>
          <td class="paramtype">const &nbsp;</td>
          <td class="paramname"> <em>RadiationType</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the scattering factor at (0,0,0). </p>
<p>Used for scatterer (electron, nucleus) density generation. </p>

<p>Implements <a class="el" href="a00089.html#a854b51b9b08e96af0fe7986fe372c50c">ObjCryst::ScatteringPower</a>.</p>

</div>
</div>
<a class="anchor" id="a1f4b091f0990b959acb0645fd575a080"></a><!-- doxytag: member="ObjCryst::ScatteringPowerSphere::GetRadius" ref="a1f4b091f0990b959acb0645fd575a080" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">REAL ObjCryst::ScatteringPowerSphere::GetRadius </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the physical radius of this type of scatterer (for 3D display purposes). </p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>this may be removed later. </dd></dl>

<p>Implements <a class="el" href="a00089.html#ac44860aca21734844379ddec87622f7b">ObjCryst::ScatteringPower</a>.</p>

</div>
</div>
<a class="anchor" id="aee221744487a1c29023399b71e855c06"></a><!-- doxytag: member="ObjCryst::ScatteringPowerSphere::GetResonantScattFactImag" ref="aee221744487a1c29023399b71e855c06" args="(const ScatteringData &amp;data, const int spgSymPosIndex=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual CrystMatrix_REAL ObjCryst::ScatteringPowerSphere::GetResonantScattFactImag </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00088.html">ScatteringData</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>spgSymPosIndex</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the imaginary part of the resonant scattering factor. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a matrix where each row corresponds to each wavelength (currently only monochromatic experiments are made so there is only one row), and each column corresponds to each reflection <em>only</em> if the scattering term is anisotropic, which is not the case so far... </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>data,:</em>&nbsp;</td><td>the <a class="el" href="a00088.html" title="Class to compute structure factors for a set of reflections and a Crystal.">ScatteringData</a> object, giving access to all the reflections, and a list of wavelengths. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>spgSymPosIndex,:</em>&nbsp;</td><td>if the <a class="el" href="a00089.html" title="Abstract Base Class to describe the scattering power of any Scatterer component in...">ScatteringPower</a> is anisotropic, then the different symmetrics will not have the same scattering power for all reflections. This parameter is the index of the symmetric position in the Spacegroup. If spgSymPosIndex=-1, the isotropic values are returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>There is no anisotropic code yet, so spgSymPosIndex is simply ignored so far , but the design of this function is general for any anisotropic scattering. </dd></dl>

<p>Implements <a class="el" href="a00089.html#a9bc5d86bf76116f645b43d46f2a9771c">ObjCryst::ScatteringPower</a>.</p>

</div>
</div>
<a class="anchor" id="a064671bfd711ef108be7a1528e52cd46"></a><!-- doxytag: member="ObjCryst::ScatteringPowerSphere::GetResonantScattFactReal" ref="a064671bfd711ef108be7a1528e52cd46" args="(const ScatteringData &amp;data, const int spgSymPosIndex=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual CrystMatrix_REAL ObjCryst::ScatteringPowerSphere::GetResonantScattFactReal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00088.html">ScatteringData</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>spgSymPosIndex</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the real part of the resonant scattering factor. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a matrix where each row corresponds to each wavelength (currently only monochromatic experiments are made so there is only one row), and each column corresponds to each reflection <em>only</em> if the scattering term is anisotropic, which is not the case so far... </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>data,:</em>&nbsp;</td><td>the <a class="el" href="a00088.html" title="Class to compute structure factors for a set of reflections and a Crystal.">ScatteringData</a> object, giving access to all the reflections and a list of wavelengths). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>spgSymPosIndex,:</em>&nbsp;</td><td>if the <a class="el" href="a00089.html" title="Abstract Base Class to describe the scattering power of any Scatterer component in...">ScatteringPower</a> is anisotropic, then the different symmetrics will not have the same scattering power for all reflections. This parameter is the index of the symmetric position in the Spacegroup. If spgSymPosIndex=-1, the isotropic values are returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>There is no anisotropic code yet, so spgSymPosIndex is simply ignored so far , but the design of this function is general for any anisotropic scattering. </dd></dl>

<p>Implements <a class="el" href="a00089.html#a42c1302254787d13b9e0f2210315291a">ObjCryst::ScatteringPower</a>.</p>

</div>
</div>
<a class="anchor" id="a073f08b17ba89e0ac5ed8e1a61cb04fe"></a><!-- doxytag: member="ObjCryst::ScatteringPowerSphere::GetScatteringFactor" ref="a073f08b17ba89e0ac5ed8e1a61cb04fe" args="(const ScatteringData &amp;data, const int spgSymPosIndex=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual CrystVector_REAL ObjCryst::ScatteringPowerSphere::GetScatteringFactor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00088.html">ScatteringData</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>spgSymPosIndex</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the Scattering factor for all reflections of a given <a class="el" href="a00088.html" title="Class to compute structure factors for a set of reflections and a Crystal.">ScatteringData</a> object. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a vector with the scattering factor for all reflections, in the same order as in the <a class="el" href="a00088.html" title="Class to compute structure factors for a set of reflections and a Crystal.">ScatteringData</a> object. This format is independent of the radiation type (X-Ray, neutron..). </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>data,:</em>&nbsp;</td><td>the <a class="el" href="a00088.html" title="Class to compute structure factors for a set of reflections and a Crystal.">ScatteringData</a> object, giving access to all the reflections. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>spgSymPosIndex,:</em>&nbsp;</td><td>if the <a class="el" href="a00089.html" title="Abstract Base Class to describe the scattering power of any Scatterer component in...">ScatteringPower</a> is anisotropic, then the different symmetrics will not have the same scattering power for all reflections. This parameter is the index of the symmetric position in the Spacegroup. If spgSymPosIndex=-1, the isotropic values are returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>There is no anisotropic code yet, so spgSymPosIndex is simply ignored so far , but the design of this function is general for any anisotropic scattering. </dd></dl>

<p>Implements <a class="el" href="a00089.html#af18f3eaaf45af87bc3a2a0ff21bc34b6">ObjCryst::ScatteringPower</a>.</p>

</div>
</div>
<a class="anchor" id="a3927291a20f5807c2ec6a9ae3627005d"></a><!-- doxytag: member="ObjCryst::ScatteringPowerSphere::GetTemperatureFactor" ref="a3927291a20f5807c2ec6a9ae3627005d" args="(const ScatteringData &amp;data, const int spgSymPosIndex=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual CrystVector_REAL ObjCryst::ScatteringPowerSphere::GetTemperatureFactor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00088.html">ScatteringData</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>spgSymPosIndex</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the temperature factor for all reflections of a given <a class="el" href="a00088.html" title="Class to compute structure factors for a set of reflections and a Crystal.">ScatteringData</a> object. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a vector with the temperature factor for all reflections, in the same order as in the <a class="el" href="a00088.html" title="Class to compute structure factors for a set of reflections and a Crystal.">ScatteringData</a> object. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>data,:</em>&nbsp;</td><td>the <a class="el" href="a00088.html" title="Class to compute structure factors for a set of reflections and a Crystal.">ScatteringData</a> object, giving access to all the reflections. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>spgSymPosIndex,:</em>&nbsp;</td><td>if the <a class="el" href="a00089.html" title="Abstract Base Class to describe the scattering power of any Scatterer component in...">ScatteringPower</a> is anisotropic, then the different symmetrics will not have the same scattering power for all reflections. This parameter is the index of the symmetric position in the Spacegroup. If spgSymPosIndex=-1, the isotropic values are returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>There is no anisotropic code yet, so spgSymPosIndex is simply ignored so far , but the design of this function is general for any anisotropic scattering. </dd></dl>

<p>Implements <a class="el" href="a00089.html#a3df723db77380c82ecff5f7050490255">ObjCryst::ScatteringPower</a>.</p>

</div>
</div>
<a class="anchor" id="aaaf687a105e65c6522521a0f01a98acf"></a><!-- doxytag: member="ObjCryst::ScatteringPowerSphere::XMLInput" ref="aaaf687a105e65c6522521a0f01a98acf" args="(istream &amp;is, const XMLCrystTag &amp;tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ObjCryst::ScatteringPowerSphere::XMLInput </td>
          <td>(</td>
          <td class="paramtype">istream &amp;&nbsp;</td>
          <td class="paramname"> <em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00150.html">XMLCrystTag</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>tag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Input From stream. </p>
<dl class="todo"><dt><b><a class="el" href="a00221.html#_todo000027">Todo:</a></b></dt><dd>Add an bool XMLInputTag(is,tag) function to recognize all the tags from the stream. So that each inherited class can use the XMLInputTag function from its parent (ie take advantage of inheritance). The children class would first try to interpret the tag, then if unsuccessful would pass it to its parent (thus allowing overloading), etc... </dd></dl>

<p>Reimplemented from <a class="el" href="a00070.html#ac13a4045c3f187879443c8615c38d623">ObjCryst::RefinableObj</a>.</p>

</div>
</div>
<a class="anchor" id="a050e8e8b21857ec0593bbb41fd123e39"></a><!-- doxytag: member="ObjCryst::ScatteringPowerSphere::XMLOutput" ref="a050e8e8b21857ec0593bbb41fd123e39" args="(ostream &amp;os, int indent=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ObjCryst::ScatteringPowerSphere::XMLOutput </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>indent</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Output to stream in well-formed XML. </p>
<dl class="todo"><dt><b><a class="el" href="a00221.html#_todo000026">Todo:</a></b></dt><dd>Use inheritance.. as for XMLInputTag()... </dd></dl>

<p>Reimplemented from <a class="el" href="a00070.html#a7b9b6ed0f8dcf753d398c35e073de973">ObjCryst::RefinableObj</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>ScatteringPowerSphere.h</li>
</ul>
</div>
<hr class="footer"/><address style="text-align: right;"><small>Generated by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2-20100208 </small></address>
</body>
</html>
