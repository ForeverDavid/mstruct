<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>ObjCryst++: ObjCryst::Crystal Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">ObjCryst++
   &#160;<span id="projectnumber">1.5CVS</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="a00171.html">ObjCryst</a>      </li>
      <li class="navelem"><a class="el" href="a00020.html">Crystal</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a>  </div>
  <div class="headertitle">
<div class="title">ObjCryst::Crystal Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="ObjCryst::Crystal" --><!-- doxytag: inherits="ObjCryst::UnitCell" -->
<p><a class="el" href="a00020.html" title="Crystal class: Unit cell, spacegroup, scatterers.">Crystal</a> class: Unit cell, spacegroup, scatterers.  
 <a href="a00020.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for ObjCryst::Crystal:</div>
<div class="dyncontent">
 <div class="center">
  <img src="a00020.png" usemap="#ObjCryst::Crystal_map" alt=""/>
  <map id="ObjCryst::Crystal_map" name="ObjCryst::Crystal_map">
<area href="a00110.html" title="Unit Cell class: Unit cell with spacegroup information." alt="ObjCryst::UnitCell" shape="rect" coords="0,56,141,80"/>
<area href="a00071.html" title="Generic Refinable Object." alt="ObjCryst::RefinableObj" shape="rect" coords="0,0,141,24"/>
</map>
 </div></div>

<p><a href="a00242.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html">BumpMergePar</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage for anti-bump/merge parameters.  <a href="a00009.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00051.html">Neighbour</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Interatomic distance for a given neighbour.  <a href="a00051.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00052.html">NeighbourHood</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Table of neighbours for a given unique atom.  <a href="a00052.html#details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::map&lt; pair&lt; const <br class="typebreak"/>
<a class="el" href="a00090.html">ScatteringPower</a> *, const <br class="typebreak"/>
<a class="el" href="a00090.html">ScatteringPower</a> * &gt;<br class="typebreak"/>
, <a class="el" href="a00009.html">Crystal::BumpMergePar</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#af57b44b799f164dbc86227f555a5eee5">VBumpMergePar</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Anti-bump parameters.  <a href="#af57b44b799f164dbc86227f555a5eee5"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4d9c152db2dfcea3c849d0a7ae547a2e"></a><!-- doxytag: member="ObjCryst::Crystal::Crystal" ref="a4d9c152db2dfcea3c849d0a7ae547a2e" args="()" -->
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#a4d9c152db2dfcea3c849d0a7ae547a2e">Crystal</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Default Constructor. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#af4476f2fa29985667c19dc14dcc1efc9">Crystal</a> (const REAL a, const REAL b, const REAL c, const string &amp;SpaceGroupId)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a00020.html" title="Crystal class: Unit cell, spacegroup, scatterers.">Crystal</a> Constructor (orthorombic)  <a href="#af4476f2fa29985667c19dc14dcc1efc9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#a5bb224d9b91463fb5748d76a2bcd6949">Crystal</a> (const REAL a, const REAL b, const REAL c, const REAL alpha, const REAL beta, const REAL gamma, const string &amp;SpaceGroupId)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a00020.html" title="Crystal class: Unit cell, spacegroup, scatterers.">Crystal</a> Constructor (triclinic)  <a href="#a5bb224d9b91463fb5748d76a2bcd6949"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4fd1bac8dbb8c119077f3b1f3d19153f"></a><!-- doxytag: member="ObjCryst::Crystal::Crystal" ref="a4fd1bac8dbb8c119077f3b1f3d19153f" args="(const Crystal &amp;oldCryst)" -->
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#a4fd1bac8dbb8c119077f3b1f3d19153f">Crystal</a> (const <a class="el" href="a00020.html">Crystal</a> &amp;oldCryst)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a00020.html" title="Crystal class: Unit cell, spacegroup, scatterers.">Crystal</a> copy constructor. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a13a9e007a57aeb11a5d808099c56c2b5"></a><!-- doxytag: member="ObjCryst::Crystal::~Crystal" ref="a13a9e007a57aeb11a5d808099c56c2b5" args="()" -->
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#a13a9e007a57aeb11a5d808099c56c2b5">~Crystal</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a00020.html" title="Crystal class: Unit cell, spacegroup, scatterers.">Crystal</a> destructor. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#ad1f69a5fb8981a2cf0eeb6245728af6d">GetClassName</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Name for this class ("RefinableObj", "Crystal",...).  <a href="#ad1f69a5fb8981a2cf0eeb6245728af6d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#acee480ad824aa0eedf78a4fa414cf347">AddScatterer</a> (<a class="el" href="a00085.html">Scatterer</a> *scatt)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a scatterer to the crystal.  <a href="#acee480ad824aa0eedf78a4fa414cf347"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac2755d27280cfa572aa334e6e596da98"></a><!-- doxytag: member="ObjCryst::Crystal::RemoveScatterer" ref="ac2755d27280cfa572aa334e6e596da98" args="(Scatterer *scatt, const bool del=true)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#ac2755d27280cfa572aa334e6e596da98">RemoveScatterer</a> (<a class="el" href="a00085.html">Scatterer</a> *scatt, const bool del=true)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a <a class="el" href="a00085.html" title="Generic type of scatterer: can be an atom, or a more complex assembly of atoms.">Scatterer</a>. This also deletes the scatterer unless del=false. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5fb1f327104bd5cf5550265b1453a639"></a><!-- doxytag: member="ObjCryst::Crystal::GetNbScatterer" ref="a5fb1f327104bd5cf5550265b1453a639" args="() const " -->
long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#a5fb1f327104bd5cf5550265b1453a639">GetNbScatterer</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of scatterers in the crystal. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00085.html">Scatterer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#a19bb22e923b0155d6de0f7585d467e51">GetScatt</a> (const string &amp;scattName)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides an access to the scatterers.  <a href="#a19bb22e923b0155d6de0f7585d467e51"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00085.html">Scatterer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#aaf80c4ddd329baf30d4391e37e8b40f5">GetScatt</a> (const string &amp;scattName) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a const access to the scatterers.  <a href="#aaf80c4ddd329baf30d4391e37e8b40f5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00085.html">Scatterer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#a4cebd2f318d525d2850c713a43d4dc4d">GetScatt</a> (const long scattIndex)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides an access to the scatterers.  <a href="#a4cebd2f318d525d2850c713a43d4dc4d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00085.html">Scatterer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#a2c5648ab7734b0d865869ea2ee3a8256">GetScatt</a> (const long scattIndex) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a const access to the scatterers.  <a href="#a2c5648ab7734b0d865869ea2ee3a8256"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad2e15e119a2cfc4104efd46672c63b64"></a><!-- doxytag: member="ObjCryst::Crystal::GetScattererRegistry" ref="ad2e15e119a2cfc4104efd46672c63b64" args="()" -->
<a class="el" href="a00054.html">ObjRegistry</a>&lt; <a class="el" href="a00085.html">Scatterer</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#ad2e15e119a2cfc4104efd46672c63b64">GetScattererRegistry</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the registry of scatterers. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac93eb73b0194e1550a0d6eb5b313ab44"></a><!-- doxytag: member="ObjCryst::Crystal::GetScattererRegistry" ref="ac93eb73b0194e1550a0d6eb5b313ab44" args="() const " -->
const <a class="el" href="a00054.html">ObjRegistry</a>&lt; <a class="el" href="a00085.html">Scatterer</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#ac93eb73b0194e1550a0d6eb5b313ab44">GetScattererRegistry</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the registry of scatterers. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a53d6f239dbfae0040c900e4d4e120e73"></a><!-- doxytag: member="ObjCryst::Crystal::GetScatteringPowerRegistry" ref="a53d6f239dbfae0040c900e4d4e120e73" args="()" -->
<a class="el" href="a00054.html">ObjRegistry</a>&lt; <a class="el" href="a00090.html">ScatteringPower</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#a53d6f239dbfae0040c900e4d4e120e73">GetScatteringPowerRegistry</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the registry of <a class="el" href="a00090.html" title="Abstract Base Class to describe the scattering power of any Scatterer component in a crystal...">ScatteringPower</a> included in this <a class="el" href="a00020.html" title="Crystal class: Unit cell, spacegroup, scatterers.">Crystal</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abcc623c63dfe1085d28e7d73811fff16"></a><!-- doxytag: member="ObjCryst::Crystal::GetScatteringPowerRegistry" ref="abcc623c63dfe1085d28e7d73811fff16" args="() const " -->
const <a class="el" href="a00054.html">ObjRegistry</a><br class="typebreak"/>
&lt; <a class="el" href="a00090.html">ScatteringPower</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#abcc623c63dfe1085d28e7d73811fff16">GetScatteringPowerRegistry</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the registry of <a class="el" href="a00090.html" title="Abstract Base Class to describe the scattering power of any Scatterer component in a crystal...">ScatteringPower</a> included in this <a class="el" href="a00020.html" title="Crystal class: Unit cell, spacegroup, scatterers.">Crystal</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#a76d2d19234fbc5733f5c565a4bf9a1c7">AddScatteringPower</a> (<a class="el" href="a00090.html">ScatteringPower</a> *scattPow)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a <a class="el" href="a00090.html" title="Abstract Base Class to describe the scattering power of any Scatterer component in a crystal...">ScatteringPower</a> for this <a class="el" href="a00020.html" title="Crystal class: Unit cell, spacegroup, scatterers.">Crystal</a>.  <a href="#a76d2d19234fbc5733f5c565a4bf9a1c7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#aba839003a614634d7d6d9217379ae692">RemoveScatteringPower</a> (<a class="el" href="a00090.html">ScatteringPower</a> *scattPow, const bool del=true)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a <a class="el" href="a00090.html" title="Abstract Base Class to describe the scattering power of any Scatterer component in a crystal...">ScatteringPower</a> for this <a class="el" href="a00020.html" title="Crystal class: Unit cell, spacegroup, scatterers.">Crystal</a>.  <a href="#aba839003a614634d7d6d9217379ae692"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3a71094a078502bbb73f811f895cb438"></a><!-- doxytag: member="ObjCryst::Crystal::GetScatteringPower" ref="a3a71094a078502bbb73f811f895cb438" args="(const string &amp;name)" -->
<a class="el" href="a00090.html">ScatteringPower</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#a3a71094a078502bbb73f811f895cb438">GetScatteringPower</a> (const string &amp;name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a <a class="el" href="a00090.html" title="Abstract Base Class to describe the scattering power of any Scatterer component in a crystal...">ScatteringPower</a> from its name. Names must be unique in a given <a class="el" href="a00020.html" title="Crystal class: Unit cell, spacegroup, scatterers.">Crystal</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5622a2ef63f40084527626c94085f90a"></a><!-- doxytag: member="ObjCryst::Crystal::GetScatteringPower" ref="a5622a2ef63f40084527626c94085f90a" args="(const string &amp;name) const " -->
const <a class="el" href="a00090.html">ScatteringPower</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#a5622a2ef63f40084527626c94085f90a">GetScatteringPower</a> (const string &amp;name) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a <a class="el" href="a00090.html" title="Abstract Base Class to describe the scattering power of any Scatterer component in a crystal...">ScatteringPower</a> from its name. Names must be unique in a given <a class="el" href="a00020.html" title="Crystal class: Unit cell, spacegroup, scatterers.">Crystal</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3b583a9655a174de9c21e139eea709dc"></a><!-- doxytag: member="ObjCryst::Crystal::GetMasterClockScatteringPower" ref="a3b583a9655a174de9c21e139eea709dc" args="() const " -->
const <a class="el" href="a00072.html">RefinableObjClock</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#a3b583a9655a174de9c21e139eea709dc">GetMasterClockScatteringPower</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the clock which reports all changes in ScatteringPowers. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a748d335480c372c5ef6cdf8716d9dd1a"></a><!-- doxytag: member="ObjCryst::Crystal::GetScatteringComponentList" ref="a748d335480c372c5ef6cdf8716d9dd1a" args="() const " -->
virtual const <br class="typebreak"/>
<a class="el" href="a00087.html">ScatteringComponentList</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#a748d335480c372c5ef6cdf8716d9dd1a">GetScatteringComponentList</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the list of all scattering components. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1deb673a7f01f6a71c659f28ddf5cd21"></a><!-- doxytag: member="ObjCryst::Crystal::GetClockScattCompList" ref="a1deb673a7f01f6a71c659f28ddf5cd21" args="() const " -->
const <a class="el" href="a00072.html">RefinableObjClock</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#a1deb673a7f01f6a71c659f28ddf5cd21">GetClockScattCompList</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the list of all scattering components. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#ac4a7086d3757be4bbe2484f549a1b0fc">Print</a> (ostream &amp;os=cout) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints some info about the crystal.  <a href="#ac4a7086d3757be4bbe2484f549a1b0fc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CrystMatrix_REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#ae9f3f6ba4945942bda42af5150ed2948">GetMinDistanceTable</a> (const REAL minDistance=0.1) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum interatomic distance between all scattering components (atoms) in the crystal.  <a href="#ae9f3f6ba4945942bda42af5150ed2948"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#a152d60cb30353b9a54ad34e291f4b6f3">PrintMinDistanceTable</a> (const REAL minDistance=0.1, ostream &amp;os=cout) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the minimum distance table between all scattering centers (atoms) in the crystal.  <a href="#a152d60cb30353b9a54ad34e291f4b6f3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#a925f91bd3da4c189bc288047454bb864">POVRayDescription</a> (ostream &amp;os, const <a class="el" href="a00021.html">CrystalPOVRayOptions</a> &amp;options) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">XMLOutput POV-Ray Description for this <a class="el" href="a00020.html" title="Crystal class: Unit cell, spacegroup, scatterers.">Crystal</a>.  <a href="#a925f91bd3da4c189bc288047454bb864"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#af63e9925212657a2912d59c2f8c2d34c">GLInitDisplayList</a> (const bool onlyIndependentAtoms=false, const REAL xMin=-.1, const REAL xMax=1.1, const REAL yMin=-.1, const REAL yMax=1.1, const REAL zMin=-.1, const REAL zMax=1.1, const bool displayNames=false) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an OpenGL DisplayList of the crystal.  <a href="#af63e9925212657a2912d59c2f8c2d34c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#a69975008974c9603ebb794bb6bb20fe8">CalcDynPopCorr</a> (const REAL overlapDist=1., const REAL mergeDist=.0) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the 'Dynamical population correction for all atoms. Atoms which are considered "equivalent" (ie currently with the same Z number) and which are overlapping see their Dynamical occupancy changed so that when they fully overlap, they are equivalent to 1 atom.  <a href="#a69975008974c9603ebb794bb6bb20fe8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9230b222fe2cde018c6b08fab6d5da8b"></a><!-- doxytag: member="ObjCryst::Crystal::ResetDynPopCorr" ref="a9230b222fe2cde018c6b08fab6d5da8b" args="() const " -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#a9230b222fe2cde018c6b08fab6d5da8b">ResetDynPopCorr</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset Dynamical Population Correction factors (ie set it to 1) <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#a511c3fcea43446634232eb6df345db9d">SetUseDynPopCorr</a> (const int use)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the use of dynamical population correction (<a class="el" href="a00020.html#aa75ade2fea9a50b3e6fb08773f607a13" title="Use Dynamical population correction (ScatteringComponent::mDynPopCorr) during Structure factor calcul...">Crystal::mUseDynPopCorr</a>).  <a href="#a511c3fcea43446634232eb6df345db9d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#a4206c09ce323f74534fec77eb29dc246">GetBumpMergeCost</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Anti-bumping/pro-Merging cost function.  <a href="#a4206c09ce323f74534fec77eb29dc246"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#ad77bfe72588a64e306a5514535ed7404">SetBumpMergeDistance</a> (const <a class="el" href="a00090.html">ScatteringPower</a> &amp;scatt1, const <a class="el" href="a00090.html">ScatteringPower</a> &amp;scatt2, const REAL dist=1.5)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the Anti-bumping distance between two scattering types.  <a href="#ad77bfe72588a64e306a5514535ed7404"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a74a095efbf1f414a0707532cb51f78ca"></a><!-- doxytag: member="ObjCryst::Crystal::SetBumpMergeDistance" ref="a74a095efbf1f414a0707532cb51f78ca" args="(const ScatteringPower &amp;scatt1, const ScatteringPower &amp;scatt2, const REAL dist, const bool allowMerge)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#a74a095efbf1f414a0707532cb51f78ca">SetBumpMergeDistance</a> (const <a class="el" href="a00090.html">ScatteringPower</a> &amp;scatt1, const <a class="el" href="a00090.html">ScatteringPower</a> &amp;scatt2, const REAL dist, const bool allowMerge)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the Anti-bumping distance between two scattering types. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac098ff50897a0afdec066d5f3872a5a1"></a><!-- doxytag: member="ObjCryst::Crystal::RemoveBumpMergeDistance" ref="ac098ff50897a0afdec066d5f3872a5a1" args="(const ScatteringPower &amp;scatt1, const ScatteringPower &amp;scatt2)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#ac098ff50897a0afdec066d5f3872a5a1">RemoveBumpMergeDistance</a> (const <a class="el" href="a00090.html">ScatteringPower</a> &amp;scatt1, const <a class="el" href="a00090.html">ScatteringPower</a> &amp;scatt2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove an Anti-bumping distance between two scattering types. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0e1cfe79846330b06619619a51af34d6"></a><!-- doxytag: member="ObjCryst::Crystal::GetBumpMergeParList" ref="a0e1cfe79846330b06619619a51af34d6" args="() const " -->
const <a class="el" href="a00020.html#af57b44b799f164dbc86227f555a5eee5">VBumpMergePar</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>GetBumpMergeParList</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a454da6faa3699da08af3ed99f2193d9a"></a><!-- doxytag: member="ObjCryst::Crystal::GetBumpMergeParList" ref="a454da6faa3699da08af3ed99f2193d9a" args="()" -->
<a class="el" href="a00020.html#af57b44b799f164dbc86227f555a5eee5">VBumpMergePar</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>GetBumpMergeParList</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a656dd25b9a62224144142fff3eba1627"></a><!-- doxytag: member="ObjCryst::Crystal::GetClockScattererList" ref="a656dd25b9a62224144142fff3eba1627" args="() const " -->
const <a class="el" href="a00072.html">RefinableObjClock</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#a656dd25b9a62224144142fff3eba1627">GetClockScattererList</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">When was the list of scatterers last changed ? <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#a037f8ea8c5dceece1044ce73d542a0e4">XMLOutput</a> (ostream &amp;os, int indent=0) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Output to stream in well-formed XML.  <a href="#a037f8ea8c5dceece1044ce73d542a0e4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#accc77bfc6df977685c01a43d150a8ba7">XMLInput</a> (istream &amp;is, const <a class="el" href="a00151.html">XMLCrystTag</a> &amp;tag)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Input From stream.  <a href="#accc77bfc6df977685c01a43d150a8ba7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#ab6a8a2cc28f3b1cde012754a19c279de">GlobalOptRandomMove</a> (const REAL mutationAmplitude, const <a class="el" href="a00080.html">RefParType</a> *type=<a class="el" href="a00171.html#a92ed37a804903dfb302d70309b7bc474">gpRefParTypeObjCryst</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a random move of the current configuration.  <a href="#ab6a8a2cc28f3b1cde012754a19c279de"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#a6f10c5a30864b9699b313f90b646138f">GetLogLikelihood</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get -log(likelihood) of the current configuration for the object.  <a href="#a6f10c5a30864b9699b313f90b646138f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#a7ed712a9735043d4c7a279e9779d563a">CIFOutput</a> (ostream &amp;os) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">output <a class="el" href="a00020.html" title="Crystal class: Unit cell, spacegroup, scatterers.">Crystal</a> structure as a cif file (EXPERIMENTAL !)  <a href="#a7ed712a9735043d4c7a279e9779d563a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#afcef6e251265ddf23657fe10b0cd4912">GetGeneGroup</a> (const <a class="el" href="a00071.html">RefinableObj</a> &amp;obj, CrystVector_uint &amp;groupIndex, unsigned int &amp;firstGroup) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the gene group assigned to each parameter.  <a href="#afcef6e251265ddf23657fe10b0cd4912"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#afe25ea6d287d6dd9cd0a03aed3798525">BeginOptimization</a> (const bool allowApproximations=false, const bool enableRestraints=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This should be called by any optimization class at the begining of an optimization.  <a href="#afe25ea6d287d6dd9cd0a03aed3798525"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8b12fd9aae0c485bcdb17ac4fa4a17fc"></a><!-- doxytag: member="ObjCryst::Crystal::AddBondValenceRo" ref="a8b12fd9aae0c485bcdb17ac4fa4a17fc" args="(const ScatteringPower &amp;, const ScatteringPower &amp;, const REAL ro)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>AddBondValenceRo</b> (const <a class="el" href="a00090.html">ScatteringPower</a> &amp;, const <a class="el" href="a00090.html">ScatteringPower</a> &amp;, const REAL ro)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aca3dd86f521af211c6057c547fa907a6"></a><!-- doxytag: member="ObjCryst::Crystal::RemoveBondValenceRo" ref="aca3dd86f521af211c6057c547fa907a6" args="(const ScatteringPower &amp;, const ScatteringPower &amp;)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>RemoveBondValenceRo</b> (const <a class="el" href="a00090.html">ScatteringPower</a> &amp;, const <a class="el" href="a00090.html">ScatteringPower</a> &amp;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afb63f1cd68bef00efde221449a0471db"></a><!-- doxytag: member="ObjCryst::Crystal::GetBondValenceCost" ref="afb63f1cd68bef00efde221449a0471db" args="() const " -->
REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#afb63f1cd68bef00efde221449a0471db">GetBondValenceCost</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Bond-Valence cost function, which compares the expected valence to the one computed from Bond-Valence Ro parameters. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a98cd544cd8bdee0e2be4564eb74d43f3"></a><!-- doxytag: member="ObjCryst::Crystal::GetBondValenceRoList" ref="a98cd544cd8bdee0e2be4564eb74d43f3" args="()" -->
std::map&lt; pair&lt; const <br class="typebreak"/>
<a class="el" href="a00090.html">ScatteringPower</a> *, const <br class="typebreak"/>
<a class="el" href="a00090.html">ScatteringPower</a> * &gt;, REAL &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>GetBondValenceRoList</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af6fd92d99e5b95195fbfac86551f37b3"></a><!-- doxytag: member="ObjCryst::Crystal::GetBondValenceRoList" ref="af6fd92d99e5b95195fbfac86551f37b3" args="() const " -->
const std::map&lt; pair&lt; const <br class="typebreak"/>
<a class="el" href="a00090.html">ScatteringPower</a> *, const <br class="typebreak"/>
<a class="el" href="a00090.html">ScatteringPower</a> * &gt;, REAL &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>GetBondValenceRoList</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#aefcd0d1032e5b93de47b4b93d530ed5b">Init</a> (const REAL a, const REAL b, const REAL c, const REAL alpha, const REAL beta, const REAL gamma, const string &amp;SpaceGroupId, const string &amp;name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Init all <a class="el" href="a00020.html" title="Crystal class: Unit cell, spacegroup, scatterers.">Crystal</a> parameters.  <a href="#aefcd0d1032e5b93de47b4b93d530ed5b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#ae976f94ba642aa81cb7b23fcc1a56028">SetDeleteSubObjInDestructor</a> (const bool b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set whether to delete the Scatterers and ScatteringPowers in the destructor.  <a href="#ae976f94ba642aa81cb7b23fcc1a56028"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#a6f824ecc64553f3b3d15d0db9bf5982d">InitOptions</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Init options.  <a href="#a6f824ecc64553f3b3d15d0db9bf5982d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#a2e2b2c9b9bdf29de21fc885c8d25931a">FindScatterer</a> (const string &amp;scattName) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a scatterer (its index # in mpScatterrer[]) with a given name.  <a href="#a2e2b2c9b9bdf29de21fc885c8d25931a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#a1d59955724fb598fbba3ff4c0bd125e3">CalcDistTable</a> (const bool fast) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the distance Table (mDistTable) for all scattering components.  <a href="#a1d59955724fb598fbba3ff4c0bd125e3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9e38da0889a3509dda6ca1ad39f07106"></a><!-- doxytag: member="ObjCryst::Crystal::CalcBondValenceSum" ref="a9e38da0889a3509dda6ca1ad39f07106" args="() const " -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#a9e38da0889a3509dda6ca1ad39f07106">CalcBondValenceSum</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate all Bond Valences. <br/></td></tr>
<tr><td colspan="2"><h2><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a95b53923f17cc84cfdd2eab1c028b646"></a><!-- doxytag: member="ObjCryst::Crystal::mScattererRegistry" ref="a95b53923f17cc84cfdd2eab1c028b646" args="" -->
<a class="el" href="a00054.html">ObjRegistry</a>&lt; <a class="el" href="a00085.html">Scatterer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#a95b53923f17cc84cfdd2eab1c028b646">mScattererRegistry</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The registry of scatterers for this <a class="el" href="a00110.html" title="Unit Cell class: Unit cell with spacegroup information.">UnitCell</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a96fa4e0d7548e2da3aceae44223acb9a"></a><!-- doxytag: member="ObjCryst::Crystal::mvBumpMergePar" ref="a96fa4e0d7548e2da3aceae44223acb9a" args="" -->
<a class="el" href="a00020.html#af57b44b799f164dbc86227f555a5eee5">VBumpMergePar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#a96fa4e0d7548e2da3aceae44223acb9a">mvBumpMergePar</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Anti-bump parameters map. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa56df3d4cc3021b24e3d521de5fba508"></a><!-- doxytag: member="ObjCryst::Crystal::mBumpMergeParClock" ref="aa56df3d4cc3021b24e3d521de5fba508" args="" -->
<a class="el" href="a00072.html">RefinableObjClock</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#aa56df3d4cc3021b24e3d521de5fba508">mBumpMergeParClock</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Last Time Anti-bump parameters were changed. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a53766d304020a6eec3db2c789ff08cf5"></a><!-- doxytag: member="ObjCryst::Crystal::mBumpMergeCostClock" ref="a53766d304020a6eec3db2c789ff08cf5" args="" -->
<a class="el" href="a00072.html">RefinableObjClock</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#a53766d304020a6eec3db2c789ff08cf5">mBumpMergeCostClock</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Last Time Anti-bump parameters were changed. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad57883557f407dd8c7da778432217fb2"></a><!-- doxytag: member="ObjCryst::Crystal::mBumpMergeCost" ref="ad57883557f407dd8c7da778432217fb2" args="" -->
REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#ad57883557f407dd8c7da778432217fb2">mBumpMergeCost</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Current bump-merge cost. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aea7ce861440b7f71140d577532c8d8ee"></a><!-- doxytag: member="ObjCryst::Crystal::mBumpMergeScale" ref="aea7ce861440b7f71140d577532c8d8ee" args="" -->
REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#aea7ce861440b7f71140d577532c8d8ee">mBumpMergeScale</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Bump-merge scale factor. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="a00052.html">NeighbourHood</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#a91cbd823da6f8d82a693b24b5f4b42f0">mvDistTableSq</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Interatomic distance table for all unique atoms.  <a href="#a91cbd823da6f8d82a693b24b5f4b42f0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad76e9124e15045be67edd402e10769a7"></a><!-- doxytag: member="ObjCryst::Crystal::mDistTableClock" ref="ad76e9124e15045be67edd402e10769a7" args="" -->
<a class="el" href="a00072.html">RefinableObjClock</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#ad76e9124e15045be67edd402e10769a7">mDistTableClock</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The time when the distance table was last calculated. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a92bee4d000d1d634308d5686d8ae5f42"></a><!-- doxytag: member="ObjCryst::Crystal::mDistTableMaxDistance" ref="a92bee4d000d1d634308d5686d8ae5f42" args="" -->
REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#a92bee4d000d1d634308d5686d8ae5f42">mDistTableMaxDistance</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The distance up to which the distance table &amp; neighbours needs to be calculated. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2f45b59533a1a3114391aa04e7017bf8"></a><!-- doxytag: member="ObjCryst::Crystal::mScattCompList" ref="a2f45b59533a1a3114391aa04e7017bf8" args="" -->
<a class="el" href="a00087.html">ScatteringComponentList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#a2f45b59533a1a3114391aa04e7017bf8">mScattCompList</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The list of all scattering components in the crystal. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae46dd6f236625d70b696253bb81b75c5"></a><!-- doxytag: member="ObjCryst::Crystal::mLatticeClock" ref="ae46dd6f236625d70b696253bb81b75c5" args="" -->
<a class="el" href="a00072.html">RefinableObjClock</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#ae46dd6f236625d70b696253bb81b75c5">mLatticeClock</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Clock for lattice paramaters. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa75ade2fea9a50b3e6fb08773f607a13"></a><!-- doxytag: member="ObjCryst::Crystal::mUseDynPopCorr" ref="aa75ade2fea9a50b3e6fb08773f607a13" args="" -->
<a class="el" href="a00078.html">RefObjOpt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#aa75ade2fea9a50b3e6fb08773f607a13">mUseDynPopCorr</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Use Dynamical population correction (<a class="el" href="a00086.html#a33af12bb3f340af259a8b8450f837efd" title="Dynamical Population Correction.">ScatteringComponent::mDynPopCorr</a>) during Structure factor calculation ? <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a85f96fb904d5cd1f368c977f1653f509"></a><!-- doxytag: member="ObjCryst::Crystal::mScatteringPowerRegistry" ref="a85f96fb904d5cd1f368c977f1653f509" args="" -->
<a class="el" href="a00054.html">ObjRegistry</a>&lt; <a class="el" href="a00090.html">ScatteringPower</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#a85f96fb904d5cd1f368c977f1653f509">mScatteringPowerRegistry</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The registry of <a class="el" href="a00090.html" title="Abstract Base Class to describe the scattering power of any Scatterer component in a crystal...">ScatteringPower</a> for this <a class="el" href="a00020.html" title="Crystal class: Unit cell, spacegroup, scatterers.">Crystal</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8042bd11e0b5054f21d4e72bc1966e05"></a><!-- doxytag: member="ObjCryst::Crystal::mClockScattererList" ref="a8042bd11e0b5054f21d4e72bc1966e05" args="" -->
<a class="el" href="a00072.html">RefinableObjClock</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#a8042bd11e0b5054f21d4e72bc1966e05">mClockScattererList</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Last time the list of Scatterers was changed. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00072.html">RefinableObjClock</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#ac2a8728c253bf1a5f1f9dfa0b8fd1cc5">mClockScattCompList</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00072.html">RefinableObjClock</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#a87859e98018e0e7a0d71a8e69419d687">mClockNeighborTable</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00072.html">RefinableObjClock</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#a23a42c8aacd3c5525d92dfddf4dff73d">mClockDynPopCorr</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0c0317433ca0e745094835e165f4e5e7"></a><!-- doxytag: member="ObjCryst::Crystal::mMasterClockScatteringPower" ref="a0c0317433ca0e745094835e165f4e5e7" args="" -->
<a class="el" href="a00072.html">RefinableObjClock</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#a0c0317433ca0e745094835e165f4e5e7">mMasterClockScatteringPower</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">master clock recording every change in Scattering Powers <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00078.html">RefObjOpt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#ab0bedeb759e922842d3b2cd1eda9d688">mDisplayEnantiomer</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Display the enantiomeric (mirror along x) structure in 3D? This can be helpful for non-centrosymmetric structure which have been solved using powder diffraction (which only gives the relative configuration).  <a href="#ab0bedeb759e922842d3b2cd1eda9d688"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a861db7aad30d32436ff7f7d41efef5c5"></a><!-- doxytag: member="ObjCryst::Crystal::mvBondValenceRo" ref="a861db7aad30d32436ff7f7d41efef5c5" args="" -->
map&lt; pair&lt; const <br class="typebreak"/>
<a class="el" href="a00090.html">ScatteringPower</a> *, const <br class="typebreak"/>
<a class="el" href="a00090.html">ScatteringPower</a> * &gt;, REAL &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#a861db7aad30d32436ff7f7d41efef5c5">mvBondValenceRo</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Map of Bond Valence "Ro" parameters for each couple of <a class="el" href="a00090.html" title="Abstract Base Class to describe the scattering power of any Scatterer component in a crystal...">ScatteringPower</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a30556d5f1daeff997ff562f7bd70298e"></a><!-- doxytag: member="ObjCryst::Crystal::mBondValenceParClock" ref="a30556d5f1daeff997ff562f7bd70298e" args="" -->
<a class="el" href="a00072.html">RefinableObjClock</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#a30556d5f1daeff997ff562f7bd70298e">mBondValenceParClock</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Last Time Bond Valence parameters were changed. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a31d557a0f85089e9bc978b2d22c66fe6"></a><!-- doxytag: member="ObjCryst::Crystal::mBondValenceCalcClock" ref="a31d557a0f85089e9bc978b2d22c66fe6" args="" -->
<a class="el" href="a00072.html">RefinableObjClock</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#a31d557a0f85089e9bc978b2d22c66fe6">mBondValenceCalcClock</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Last time Bond Valences were calculated. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae83ac26a84c2e72d6e088b80ea134079"></a><!-- doxytag: member="ObjCryst::Crystal::mBondValenceCostClock" ref="ae83ac26a84c2e72d6e088b80ea134079" args="" -->
<a class="el" href="a00072.html">RefinableObjClock</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#ae83ac26a84c2e72d6e088b80ea134079">mBondValenceCostClock</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Last time the Bond Valence cost was calculated. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afcec48187cc76f08f1d925540268a648"></a><!-- doxytag: member="ObjCryst::Crystal::mBondValenceCost" ref="afcec48187cc76f08f1d925540268a648" args="" -->
REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#afcec48187cc76f08f1d925540268a648">mBondValenceCost</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Current Bond Valence cost. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a310b5fa7d00c874c84d4d72a03b147a0"></a><!-- doxytag: member="ObjCryst::Crystal::mBondValenceCostScale" ref="a310b5fa7d00c874c84d4d72a03b147a0" args="" -->
REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#a310b5fa7d00c874c84d4d72a03b147a0">mBondValenceCostScale</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Bond Valence cost scale factor. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::map&lt; long, REAL &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#a4be1212d5e9145c9e16cb8e4b9f3501a">mvBondValenceCalc</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">List of calculated bond valences, as a map, the key being the index of the atom in <a class="el" href="a00020.html#a2f45b59533a1a3114391aa04e7017bf8" title="The list of all scattering components in the crystal.">Crystal::mScattCompList</a>.  <a href="#a4be1212d5e9145c9e16cb8e4b9f3501a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a721474f86d405f3cef5eb6756ae3bb36"></a><!-- doxytag: member="ObjCryst::Crystal::mDeleteSubObjInDestructor" ref="a721474f86d405f3cef5eb6756ae3bb36" args="" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>mDeleteSubObjInDestructor</b></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p><a class="el" href="a00020.html" title="Crystal class: Unit cell, spacegroup, scatterers.">Crystal</a> class: Unit cell, spacegroup, scatterers. </p>
<p>A <a class="el" href="a00020.html" title="Crystal class: Unit cell, spacegroup, scatterers.">Crystal</a> object has several main characteristics : (1) a unit cell, (2) a Spacegroup and (3) a list of <a class="el" href="a00085.html" title="Generic type of scatterer: can be an atom, or a more complex assembly of atoms.">Scatterer</a>. Also stored in the <a class="el" href="a00020.html" title="Crystal class: Unit cell, spacegroup, scatterers.">Crystal</a> is a list of the ScttaringPower used by all the scatterers of this crystal.</p>
<p>The crystal is capable of giving a list of all scattering components (ie the list of all unique scattering 'points' (<a class="el" href="a00086.html" title="A scattering position in a crystal, associated with the corresponding occupancy and a pointer to the ...">ScatteringComponent</a>, ie atoms) in the unit cell, each associated to a <a class="el" href="a00090.html" title="Abstract Base Class to describe the scattering power of any Scatterer component in a crystal...">ScatteringPower</a>).</p>
<p>When those scattering components are on a special position or overlapping with another component of the same type, it is possible to correct dynamically the occupancy of this/these components to effectively have only one component instead of several due to the overlapping. This method is interesting for global optimization where atoms must not be "locked" on a special position. If this "Dynamical Occupancy Correction" is used then no occupancy should be corrected for special positions, since this will be done dynamically.</p>
<p>A crystal structure can be viewed in 3D using OpenGL.</p>
<dl class="todo"><dt><b><a class="el" href="a00222.html#_todo000001">Todo:</a></b></dt><dd>exporting (and importing) crystal structures to/from other files format than <a class="el" href="a00171.html" title="The namespace which includes all objects (crystallographic and algorithmic) in ObjCryst++.">ObjCryst</a>'s XML (eg <a class="el" href="a00017.html" title="Main CIF class - parses the stream and separates data blocks, comments, items, loops.">CIF</a>, and format used by refinement software)</dd></dl>
<p>Currently only 3D crystal structures can be handled, with no magnetic structure (that may be done later) and no incommensurate structure. </p>
</div><hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="af57b44b799f164dbc86227f555a5eee5"></a><!-- doxytag: member="ObjCryst::Crystal::VBumpMergePar" ref="af57b44b799f164dbc86227f555a5eee5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;pair&lt;const <a class="el" href="a00090.html">ScatteringPower</a>*, const <a class="el" href="a00090.html">ScatteringPower</a>*&gt;,<a class="el" href="a00009.html">Crystal::BumpMergePar</a> &gt; <a class="el" href="a00020.html#af57b44b799f164dbc86227f555a5eee5">ObjCryst::Crystal::VBumpMergePar</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Anti-bump parameters. </p>
<p>Each atom type (<a class="el" href="a00090.html" title="Abstract Base Class to describe the scattering power of any Scatterer component in a crystal...">ScatteringPower</a> is referenced using a reference number) </p>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="af4476f2fa29985667c19dc14dcc1efc9"></a><!-- doxytag: member="ObjCryst::Crystal::Crystal" ref="af4476f2fa29985667c19dc14dcc1efc9" args="(const REAL a, const REAL b, const REAL c, const string &amp;SpaceGroupId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00020.html#a4d9c152db2dfcea3c849d0a7ae547a2e">ObjCryst::Crystal::Crystal</a> </td>
          <td>(</td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>SpaceGroupId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="a00020.html" title="Crystal class: Unit cell, spacegroup, scatterers.">Crystal</a> Constructor (orthorombic) </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">a,b,c</td><td>: unit cell dimension, in angstroems </td></tr>
    <tr><td class="paramname">SpaceGroupId,:</td><td>space group symbol or number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5bb224d9b91463fb5748d76a2bcd6949"></a><!-- doxytag: member="ObjCryst::Crystal::Crystal" ref="a5bb224d9b91463fb5748d76a2bcd6949" args="(const REAL a, const REAL b, const REAL c, const REAL alpha, const REAL beta, const REAL gamma, const string &amp;SpaceGroupId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00020.html#a4d9c152db2dfcea3c849d0a7ae547a2e">ObjCryst::Crystal::Crystal</a> </td>
          <td>(</td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>gamma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>SpaceGroupId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="a00020.html" title="Crystal class: Unit cell, spacegroup, scatterers.">Crystal</a> Constructor (triclinic) </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">a,b,c</td><td>: unit cell dimension, in angstroems </td></tr>
    <tr><td class="paramname">alpha,beta,gamma</td><td>: unit cell angles, in radians. </td></tr>
    <tr><td class="paramname">SpaceGroupId,:</td><td>space group symbol or number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="acee480ad824aa0eedf78a4fa414cf347"></a><!-- doxytag: member="ObjCryst::Crystal::AddScatterer" ref="acee480ad824aa0eedf78a4fa414cf347" args="(Scatterer *scatt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00020.html#acee480ad824aa0eedf78a4fa414cf347">ObjCryst::Crystal::AddScatterer</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00085.html">Scatterer</a> *&#160;</td>
          <td class="paramname"><em>scatt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a scatterer to the crystal. </p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>the scatterer <em>must</em> be allocated in the heap, since the scatterer will <em>not</em> be copied but used directly. A <a class="el" href="a00085.html" title="Generic type of scatterer: can be an atom, or a more complex assembly of atoms.">Scatterer</a> can only belong to one <a class="el" href="a00020.html" title="Crystal class: Unit cell, spacegroup, scatterers.">Crystal</a>. It will be detroyed when removed or when the <a class="el" href="a00020.html" title="Crystal class: Unit cell, spacegroup, scatterers.">Crystal</a> is destroyed. </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">scatt</td><td>: the address of the scatterer to be included in the crystal scatterer names <b>must</b> be unique in a given crystal. </td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>that the <a class="el" href="a00090.html" title="Abstract Base Class to describe the scattering power of any Scatterer component in a crystal...">ScatteringPower</a> used in the <a class="el" href="a00085.html" title="Generic type of scatterer: can be an atom, or a more complex assembly of atoms.">Scatterer</a> should be one of the <a class="el" href="a00020.html" title="Crystal class: Unit cell, spacegroup, scatterers.">Crystal</a> (see <a class="el" href="a00020.html#a76d2d19234fbc5733f5c565a4bf9a1c7" title="Add a ScatteringPower for this Crystal.">Crystal::AddScatteringPower()</a>) </dd></dl>

</div>
</div>
<a class="anchor" id="a76d2d19234fbc5733f5c565a4bf9a1c7"></a><!-- doxytag: member="ObjCryst::Crystal::AddScatteringPower" ref="a76d2d19234fbc5733f5c565a4bf9a1c7" args="(ScatteringPower *scattPow)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00020.html#a76d2d19234fbc5733f5c565a4bf9a1c7">ObjCryst::Crystal::AddScatteringPower</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00090.html">ScatteringPower</a> *&#160;</td>
          <td class="paramname"><em>scattPow</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a <a class="el" href="a00090.html" title="Abstract Base Class to describe the scattering power of any Scatterer component in a crystal...">ScatteringPower</a> for this <a class="el" href="a00020.html" title="Crystal class: Unit cell, spacegroup, scatterers.">Crystal</a>. </p>
<p>It must be allocated in the heap, and not used by any other <a class="el" href="a00020.html" title="Crystal class: Unit cell, spacegroup, scatterers.">Crystal</a>. </p>

</div>
</div>
<a class="anchor" id="afe25ea6d287d6dd9cd0a03aed3798525"></a><!-- doxytag: member="ObjCryst::Crystal::BeginOptimization" ref="afe25ea6d287d6dd9cd0a03aed3798525" args="(const bool allowApproximations=false, const bool enableRestraints=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="a00020.html#afe25ea6d287d6dd9cd0a03aed3798525">ObjCryst::Crystal::BeginOptimization</a> </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>allowApproximations</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>enableRestraints</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This should be called by any optimization class at the begining of an optimization. </p>
<p>This will also check that everything is ready, eg call the <a class="el" href="a00071.html#a48d11671e7f8699f7bc24077585c5e0f">RefinableObj::Prepare()</a> function. This also affects all sub-objects. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>this may be called several time for some objects which are used by several other objects, or for nested optimizations (e.g. least-squares optimizations inside a global one).</dd>
<dd>
<a class="el" href="a00071.html#ab0035f6164cb24ace67b51b11993a851" title="This should be called by any optimization class at the end of an optimization.">EndOptimization()</a> must be called at the end of the optimization, the same number of time <a class="el" href="a00020.html#afe25ea6d287d6dd9cd0a03aed3798525" title="This should be called by any optimization class at the begining of an optimization.">BeginOptimization()</a> was called !</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">allowApproximations,:</td><td>if true, then the object can use faster but less precise functions during the optimization. This is useful for global optimization not using derivatives. </td></tr>
    <tr><td class="paramname">enableRestraints:\xrefitem</td><td>deprecated 28. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="a00071.html#ababd8f2916e41a20d2c1b21f6ffefe96">ObjCryst::RefinableObj</a>.</p>

</div>
</div>
<a class="anchor" id="a1d59955724fb598fbba3ff4c0bd125e3"></a><!-- doxytag: member="ObjCryst::Crystal::CalcDistTable" ref="a1d59955724fb598fbba3ff4c0bd125e3" args="(const bool fast) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00020.html#a1d59955724fb598fbba3ff4c0bd125e3">ObjCryst::Crystal::CalcDistTable</a> </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>fast</em></td><td>)</td>
          <td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the distance Table (mDistTable) for all scattering components. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">fast</td><td>: if true, the distance calculations will be made using integers, thus with a lower precision but faster. Less atoms will also be involved (using the <a class="el" href="a00007.html" title="The basic description of spacegroup asymmetric unit.">AsymmetricUnit</a> and mDistTableMaxDistance2) to make it even faster.</td></tr>
  </table>
  </dd>
</dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd><a class="el" href="a00020.html#a748d335480c372c5ef6cdf8716d9dd1a" title="Get the list of all scattering components.">Crystal::GetScatteringComponentList()</a> <b>must</b> be called beforehand, since this will not be done here.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>see Crystal::mDistTableSq and Crystal::mDistTableIndex </dd></dl>
<dl class="todo"><dt><b><a class="el" href="a00222.html#_todo000003">Todo:</a></b></dt><dd>sanitize the result distance table in a more usable structure than the currently used Crystal::mDistTableSq and Crystal::mDistTableIndex. </dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd><em>not</em> using the fast option has not been very much tested... </dd></dl>
<dl class="todo"><dt><b><a class="el" href="a00222.html#_todo000004">Todo:</a></b></dt><dd>optimize again. Test if recomputation is needed using Clocks. Use a global option instead of asymUnitMargin. </dd></dl>

</div>
</div>
<a class="anchor" id="a69975008974c9603ebb794bb6bb20fe8"></a><!-- doxytag: member="ObjCryst::Crystal::CalcDynPopCorr" ref="a69975008974c9603ebb794bb6bb20fe8" args="(const REAL overlapDist=1., const REAL mergeDist=.0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00020.html#a69975008974c9603ebb794bb6bb20fe8">ObjCryst::Crystal::CalcDynPopCorr</a> </td>
          <td>(</td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>overlapDist</em> = <code>1.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>mergeDist</em> = <code>.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the 'Dynamical population correction for all atoms. Atoms which are considered "equivalent" (ie currently with the same Z number) and which are overlapping see their Dynamical occupancy changed so that when they fully overlap, they are equivalent to 1 atom. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">overlapDist</td><td>: distance below which atoms (ScatteringComponents, to be more precise) are considered overlapping and should be corrected. The correction changes the dynamical occupancy from 1 to 1/nbAtomOverlapping, progressively as the distance falls from <em>overlapDist</em> to <em>mergeDist</em>. </td></tr>
    <tr><td class="paramname">mergeDist</td><td>: distance below which atoms are considered fully overlapping. If 3 atoms are 'fully' overlapping, then all have a dynamical population correction equal to 1/3</td></tr>
  </table>
  </dd>
</dl>
<p>This is const since <a class="el" href="a00086.html#a33af12bb3f340af259a8b8450f837efd" title="Dynamical Population Correction.">ScatteringComponent::mDynPopCorr</a> is mutable.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>. Do not call this function, which will turn private. This is called by <em>only</em> <a class="el" href="a00020.html#a748d335480c372c5ef6cdf8716d9dd1a" title="Get the list of all scattering components.">Crystal::GetScatteringComponentList()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7ed712a9735043d4c7a279e9779d563a"></a><!-- doxytag: member="ObjCryst::Crystal::CIFOutput" ref="a7ed712a9735043d4c7a279e9779d563a" args="(ostream &amp;os) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="a00020.html#a7ed712a9735043d4c7a279e9779d563a">ObjCryst::Crystal::CIFOutput</a> </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>output <a class="el" href="a00020.html" title="Crystal class: Unit cell, spacegroup, scatterers.">Crystal</a> structure as a cif file (EXPERIMENTAL !) </p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>This is very crude and EXPERIMENTAL so far: only isotropic scattering power are supported, and there is not much information beside atom positions... </dd></dl>

</div>
</div>
<a class="anchor" id="a2e2b2c9b9bdf29de21fc885c8d25931a"></a><!-- doxytag: member="ObjCryst::Crystal::FindScatterer" ref="a2e2b2c9b9bdf29de21fc885c8d25931a" args="(const string &amp;scattName) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="a00020.html#a2e2b2c9b9bdf29de21fc885c8d25931a">ObjCryst::Crystal::FindScatterer</a> </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>scattName</em></td><td>)</td>
          <td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find a scatterer (its index # in mpScatterrer[]) with a given name. </p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>There should be no duplicate names !!! :TODO: test in <a class="el" href="a00020.html#acee480ad824aa0eedf78a4fa414cf347" title="Add a scatterer to the crystal.">AddScatterer()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4206c09ce323f74534fec77eb29dc246"></a><!-- doxytag: member="ObjCryst::Crystal::GetBumpMergeCost" ref="a4206c09ce323f74534fec77eb29dc246" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">REAL <a class="el" href="a00020.html#a4206c09ce323f74534fec77eb29dc246">ObjCryst::Crystal::GetBumpMergeCost</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the Anti-bumping/pro-Merging cost function. </p>
<p>Only works (ie returnes a non-null value) if you have added antibump distances using <a class="el" href="a00020.html#ad77bfe72588a64e306a5514535ed7404" title="Set the Anti-bumping distance between two scattering types.">Crystal::SetBumpMergeDistance()</a>. </p>

</div>
</div>
<a class="anchor" id="ad1f69a5fb8981a2cf0eeb6245728af6d"></a><!-- doxytag: member="ObjCryst::Crystal::GetClassName" ref="ad1f69a5fb8981a2cf0eeb6245728af6d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const string&amp; <a class="el" href="a00020.html#ad1f69a5fb8981a2cf0eeb6245728af6d">ObjCryst::Crystal::GetClassName</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Name for this class ("RefinableObj", "Crystal",...). </p>
<p>This is only useful to distinguish different classes when picking up objects from the <a class="el" href="a00071.html" title="Generic Refinable Object.">RefinableObj</a> Global Registry </p>

<p>Reimplemented from <a class="el" href="a00110.html#ac3b3c2e007083bf6f329eb11a6b610d1">ObjCryst::UnitCell</a>.</p>

</div>
</div>
<a class="anchor" id="afcef6e251265ddf23657fe10b0cd4912"></a><!-- doxytag: member="ObjCryst::Crystal::GetGeneGroup" ref="afcef6e251265ddf23657fe10b0cd4912" args="(const RefinableObj &amp;obj, CrystVector_uint &amp;groupIndex, unsigned int &amp;firstGroup) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="a00020.html#afcef6e251265ddf23657fe10b0cd4912">ObjCryst::Crystal::GetGeneGroup</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00071.html">RefinableObj</a> &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CrystVector_uint &amp;&#160;</td>
          <td class="paramname"><em>groupIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>firstGroup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the gene group assigned to each parameter. </p>
<p>Each parameter (a <em>gene</em> in terms of genetic algorithms) can be assigned to a gene group. Thus when mating two configurations, genes will be exchanged by groups. By default (in the base RefinabeObj class), each parameter is alone in its group. Derived classes can group genes for a better s** life.</p>
<p>The number identifying a gene group only has a meaning in a given object. It can also change on subsequent calls, and thus is not unique.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>the , supplied by an algorithm class (<a class="el" href="a00055.html" title="Base object for Optimization methods.">OptimizationObj</a>,..), which contains a list of parameters, some of which (but possibly all or none) are parameters belonging to this object. </td></tr>
    <tr><td class="paramname">groupIndex</td><td>a vector of unsigned integers, one for each parameter in the input object, giving an unsigned integer value as gene group index. At the beginning this vector should contain only zeros (no group assigned). </td></tr>
    <tr><td class="paramname">firstGroup</td><td>this is the number of groups which have already been assigned, plus one. The gene groups returned by this object will start from this value, and increment <b>firstGroup</b> for each gene group used, so that different <a class="el" href="a00071.html" title="Generic Refinable Object.">RefinableObj</a> cannot share a gene group. </td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>this function is not optimized, and should only be called at the beginning of a refinement. </dd></dl>

<p>Reimplemented from <a class="el" href="a00071.html#ad59c8ad2b0d7ee59fa3f399a54f05e54">ObjCryst::RefinableObj</a>.</p>

</div>
</div>
<a class="anchor" id="a6f10c5a30864b9699b313f90b646138f"></a><!-- doxytag: member="ObjCryst::Crystal::GetLogLikelihood" ref="a6f10c5a30864b9699b313f90b646138f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual REAL <a class="el" href="a00020.html#a6f10c5a30864b9699b313f90b646138f">ObjCryst::Crystal::GetLogLikelihood</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get -log(likelihood) of the current configuration for the object. </p>
<p>By default (no likelihood evaluation available), this is equal to 0.</p>
<p>This call should not be recursive, it is the task of the algorithm to get the sum of likelihoods for all objects invlolved.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>contrary to the old "Cost Function" approach, with log(Likelihood) there is no 'choice' of cost function, so that it is the task of the object to give the optimized likelihood (possibly with user options).</dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>: this is in under heavy development, so expect changes... </dd></dl>

<p>Reimplemented from <a class="el" href="a00071.html#a9a9a5ea2b997cd36b44ed35c2bab3245">ObjCryst::RefinableObj</a>.</p>

</div>
</div>
<a class="anchor" id="ae9f3f6ba4945942bda42af5150ed2948"></a><!-- doxytag: member="ObjCryst::Crystal::GetMinDistanceTable" ref="ae9f3f6ba4945942bda42af5150ed2948" args="(const REAL minDistance=0.1) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CrystMatrix_REAL <a class="el" href="a00020.html#ae9f3f6ba4945942bda42af5150ed2948">ObjCryst::Crystal::GetMinDistanceTable</a> </td>
          <td>(</td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>minDistance</em> = <code>0.1</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Minimum interatomic distance between all scattering components (atoms) in the crystal. </p>
<p>This will return a symmetrical matrix with NbComp rows and cols, where NbComp is the number of independent scattering components in the unit cell. All distances are given in Angstroems.</p>
<p>Note that the distance of a given atom with 'itself' is not generally equal to 0 (except full special position), but equal to the min distance with its symmetrics.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">minDistance</td><td>: atoms who are less distant than (minDistance,in Angstroems) are considered equivalent. So the smallest distance between any atoms will be at least minDistance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a19bb22e923b0155d6de0f7585d467e51"></a><!-- doxytag: member="ObjCryst::Crystal::GetScatt" ref="a19bb22e923b0155d6de0f7585d467e51" args="(const string &amp;scattName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00085.html">Scatterer</a>&amp; <a class="el" href="a00020.html#a19bb22e923b0155d6de0f7585d467e51">ObjCryst::Crystal::GetScatt</a> </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>scattName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Provides an access to the scatterers. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">scattName</td><td>the name of the scatterer to access </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaf80c4ddd329baf30d4391e37e8b40f5"></a><!-- doxytag: member="ObjCryst::Crystal::GetScatt" ref="aaf80c4ddd329baf30d4391e37e8b40f5" args="(const string &amp;scattName) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a00085.html">Scatterer</a>&amp; <a class="el" href="a00020.html#a19bb22e923b0155d6de0f7585d467e51">ObjCryst::Crystal::GetScatt</a> </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>scattName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Provides a const access to the scatterers. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">scattName</td><td>the name of the scatterer to access </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4cebd2f318d525d2850c713a43d4dc4d"></a><!-- doxytag: member="ObjCryst::Crystal::GetScatt" ref="a4cebd2f318d525d2850c713a43d4dc4d" args="(const long scattIndex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00085.html">Scatterer</a>&amp; <a class="el" href="a00020.html#a19bb22e923b0155d6de0f7585d467e51">ObjCryst::Crystal::GetScatt</a> </td>
          <td>(</td>
          <td class="paramtype">const long&#160;</td>
          <td class="paramname"><em>scattIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Provides an access to the scatterers. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">scattIndex</td><td>the number of the scatterer to access </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2c5648ab7734b0d865869ea2ee3a8256"></a><!-- doxytag: member="ObjCryst::Crystal::GetScatt" ref="a2c5648ab7734b0d865869ea2ee3a8256" args="(const long scattIndex) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a00085.html">Scatterer</a>&amp; <a class="el" href="a00020.html#a19bb22e923b0155d6de0f7585d467e51">ObjCryst::Crystal::GetScatt</a> </td>
          <td>(</td>
          <td class="paramtype">const long&#160;</td>
          <td class="paramname"><em>scattIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Provides a const access to the scatterers. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">scattIndex</td><td>the number of the scatterer to access </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af63e9925212657a2912d59c2f8c2d34c"></a><!-- doxytag: member="ObjCryst::Crystal::GLInitDisplayList" ref="af63e9925212657a2912d59c2f8c2d34c" args="(const bool onlyIndependentAtoms=false, const REAL xMin=&#45;.1, const REAL xMax=1.1, const REAL yMin=&#45;.1, const REAL yMax=1.1, const REAL zMin=&#45;.1, const REAL zMax=1.1, const bool displayNames=false) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="a00020.html#af63e9925212657a2912d59c2f8c2d34c">ObjCryst::Crystal::GLInitDisplayList</a> </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>onlyIndependentAtoms</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>xMin</em> = <code>-.1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>xMax</em> = <code>1.1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>yMin</em> = <code>-.1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>yMax</em> = <code>1.1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>zMin</em> = <code>-.1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>zMax</em> = <code>1.1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>displayNames</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create an OpenGL DisplayList of the crystal. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">onlyIndependentAtoms</td><td>if false (the default), then all symmetrics are displayed within the given limits \ param xMin,xMax,yMin,yMax,zMin,zMax: in fractionnal coordinates, the region in which we want scaterrers to be displayed. The test is made on the center of the scatterer (eg a <a class="el" href="a00156.html" title="ZScatterer: the basic type of complex scatterers, where atom positions are defined using a standard &quot;...">ZScatterer</a> (molecule) will not be 'cut' on the border). </td></tr>
    <tr><td class="paramname">displayNames,:</td><td>if true, only the names of the scatterers will be displayed, at the position of the scatterers (to actually see them, they will have to be translated with respect to the drawing of the scatterers). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab6a8a2cc28f3b1cde012754a19c279de"></a><!-- doxytag: member="ObjCryst::Crystal::GlobalOptRandomMove" ref="ab6a8a2cc28f3b1cde012754a19c279de" args="(const REAL mutationAmplitude, const RefParType *type=gpRefParTypeObjCryst)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="a00020.html#ab6a8a2cc28f3b1cde012754a19c279de">ObjCryst::Crystal::GlobalOptRandomMove</a> </td>
          <td>(</td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>mutationAmplitude</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00080.html">RefParType</a> *&#160;</td>
          <td class="paramname"><em>type</em> = <code><a class="el" href="a00171.html#a92ed37a804903dfb302d70309b7bc474">gpRefParTypeObjCryst</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Make a random move of the current configuration. </p>
<p>This is for global optimization algorithms. the moves for each parameter are less than their global optimization step, multiplied by the mutation amplitude.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>: this makes a random move for the parameter declared for this object, and it is the duty of the object to decide whether the included objects should be moved and how. (eg an algorithm should only call for a move with the top object, and this object decides how he and his sub-objects moves). By default (<a class="el" href="a00071.html" title="Generic Refinable Object.">RefinableObj</a> implementation) all included objects are moved recursively.</dd></dl>
<p><a class="el" href="a00071.html" title="Generic Refinable Object.">RefinableObj</a>:: </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mutationAmplitude,:</td><td>multiplier for the maximum move amplitude, for all parameters </td></tr>
    <tr><td class="paramname">type,:</td><td>restrain the change exclusively to parameters of a given type (same type or descendant from this <a class="el" href="a00080.html" title="class of refinable parameter types.">RefParType</a>). </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="a00071.html#a18375c8525ae38c481ba77e9cf9d67c1">ObjCryst::RefinableObj</a>.</p>

</div>
</div>
<a class="anchor" id="aefcd0d1032e5b93de47b4b93d530ed5b"></a><!-- doxytag: member="ObjCryst::Crystal::Init" ref="aefcd0d1032e5b93de47b4b93d530ed5b" args="(const REAL a, const REAL b, const REAL c, const REAL alpha, const REAL beta, const REAL gamma, const string &amp;SpaceGroupId, const string &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00020.html#aefcd0d1032e5b93de47b4b93d530ed5b">ObjCryst::Crystal::Init</a> </td>
          <td>(</td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>gamma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>SpaceGroupId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Init all <a class="el" href="a00020.html" title="Crystal class: Unit cell, spacegroup, scatterers.">Crystal</a> parameters. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">a,b,c</td><td>: unit cell dimension, in angstroems </td></tr>
    <tr><td class="paramname">alpha,beta,gamma</td><td>: unit cell angles </td></tr>
    <tr><td class="paramname">SpcGroup,:</td><td>space group number (1..230) </td></tr>
    <tr><td class="paramname">name,:</td><td>name for the crystal, : '(TaSe4)2I' </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="a00110.html#a6a98cc147e6b4471d30ff6b736c95e42">ObjCryst::UnitCell</a>.</p>

</div>
</div>
<a class="anchor" id="a6f824ecc64553f3b3d15d0db9bf5982d"></a><!-- doxytag: member="ObjCryst::Crystal::InitOptions" ref="a6f824ecc64553f3b3d15d0db9bf5982d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00020.html#a6f824ecc64553f3b3d15d0db9bf5982d">ObjCryst::Crystal::InitOptions</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [private, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Init options. </p>
<p>Need only be done once per <a class="el" href="a00020.html" title="Crystal class: Unit cell, spacegroup, scatterers.">Crystal</a>. </p>

<p>Reimplemented from <a class="el" href="a00110.html#a12460955ce7bb73812c3f3f798d8bfd8">ObjCryst::UnitCell</a>.</p>

</div>
</div>
<a class="anchor" id="a925f91bd3da4c189bc288047454bb864"></a><!-- doxytag: member="ObjCryst::Crystal::POVRayDescription" ref="a925f91bd3da4c189bc288047454bb864" args="(ostream &amp;os, const CrystalPOVRayOptions &amp;options) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ostream&amp; <a class="el" href="a00020.html#a925f91bd3da4c189bc288047454bb864">ObjCryst::Crystal::POVRayDescription</a> </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00021.html">CrystalPOVRayOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>XMLOutput POV-Ray Description for this <a class="el" href="a00020.html" title="Crystal class: Unit cell, spacegroup, scatterers.">Crystal</a>. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">onlyIndependentAtoms</td><td>if false, all symmetrics are showed in the drawing.</td></tr>
  </table>
  </dd>
</dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>This currently needs some fixing (<a class="el" href="a00156.html" title="ZScatterer: the basic type of complex scatterers, where atom positions are defined using a standard &quot;...">ZScatterer</a> does not work ?) Use rather the OpenGL 3D display which is more useful.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>the stream to which the information is outputed (default=cout) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac4a7086d3757be4bbe2484f549a1b0fc"></a><!-- doxytag: member="ObjCryst::Crystal::Print" ref="ac4a7086d3757be4bbe2484f549a1b0fc" args="(ostream &amp;os=cout) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00020.html#ac4a7086d3757be4bbe2484f549a1b0fc">ObjCryst::Crystal::Print</a> </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em> = <code>cout</code></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prints some info about the crystal. </p>
<dl class="todo"><dt><b><a class="el" href="a00222.html#_todo000002">Todo:</a></b></dt><dd>one function to print on one line and a PrintLong() function </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>the stream to which the information is outputed (default=cout) </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="a00110.html#adf564cd9521473be30d073d1660fa3ee">ObjCryst::UnitCell</a>.</p>

</div>
</div>
<a class="anchor" id="a152d60cb30353b9a54ad34e291f4b6f3"></a><!-- doxytag: member="ObjCryst::Crystal::PrintMinDistanceTable" ref="a152d60cb30353b9a54ad34e291f4b6f3" args="(const REAL minDistance=0.1, ostream &amp;os=cout) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00020.html#a152d60cb30353b9a54ad34e291f4b6f3">ObjCryst::Crystal::PrintMinDistanceTable</a> </td>
          <td>(</td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>minDistance</em> = <code>0.1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em> = <code>cout</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Print the minimum distance table between all scattering centers (atoms) in the crystal. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>the stream to which the information is outputed (default=cout) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aba839003a614634d7d6d9217379ae692"></a><!-- doxytag: member="ObjCryst::Crystal::RemoveScatteringPower" ref="aba839003a614634d7d6d9217379ae692" args="(ScatteringPower *scattPow, const bool del=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00020.html#aba839003a614634d7d6d9217379ae692">ObjCryst::Crystal::RemoveScatteringPower</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00090.html">ScatteringPower</a> *&#160;</td>
          <td class="paramname"><em>scattPow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>del</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove a <a class="el" href="a00090.html" title="Abstract Base Class to describe the scattering power of any Scatterer component in a crystal...">ScatteringPower</a> for this <a class="el" href="a00020.html" title="Crystal class: Unit cell, spacegroup, scatterers.">Crystal</a>. </p>
<p>(the Scattering power is deleted unless del=false). This function should check that it is not used any more before removing it. </p>

</div>
</div>
<a class="anchor" id="ad77bfe72588a64e306a5514535ed7404"></a><!-- doxytag: member="ObjCryst::Crystal::SetBumpMergeDistance" ref="ad77bfe72588a64e306a5514535ed7404" args="(const ScatteringPower &amp;scatt1, const ScatteringPower &amp;scatt2, const REAL dist=1.5)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00020.html#ad77bfe72588a64e306a5514535ed7404">ObjCryst::Crystal::SetBumpMergeDistance</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00090.html">ScatteringPower</a> &amp;&#160;</td>
          <td class="paramname"><em>scatt1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00090.html">ScatteringPower</a> &amp;&#160;</td>
          <td class="paramname"><em>scatt2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>dist</em> = <code>1.5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the Anti-bumping distance between two scattering types. </p>

</div>
</div>
<a class="anchor" id="ae976f94ba642aa81cb7b23fcc1a56028"></a><!-- doxytag: member="ObjCryst::Crystal::SetDeleteSubObjInDestructor" ref="ae976f94ba642aa81cb7b23fcc1a56028" args="(const bool b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00020.html#ae976f94ba642aa81cb7b23fcc1a56028">ObjCryst::Crystal::SetDeleteSubObjInDestructor</a> </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set whether to delete the Scatterers and ScatteringPowers in the destructor. </p>
<p>By default these sub-objects are deleted. </p>

</div>
</div>
<a class="anchor" id="a511c3fcea43446634232eb6df345db9d"></a><!-- doxytag: member="ObjCryst::Crystal::SetUseDynPopCorr" ref="a511c3fcea43446634232eb6df345db9d" args="(const int use)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00020.html#a511c3fcea43446634232eb6df345db9d">ObjCryst::Crystal::SetUseDynPopCorr</a> </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>use</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the use of dynamical population correction (<a class="el" href="a00020.html#aa75ade2fea9a50b3e6fb08773f607a13" title="Use Dynamical population correction (ScatteringComponent::mDynPopCorr) during Structure factor calcul...">Crystal::mUseDynPopCorr</a>). </p>
<p>Atoms which are considered "equivalent" (ie currently with the same Z number) and which are overlapping see their Dynamical occupancy changed so that when they fully overlap, they are equivalent to 1 atom.</p>
<p>The Dynamical Occupancy correction will be performed in <a class="el" href="a00020.html#a748d335480c372c5ef6cdf8716d9dd1a" title="Get the list of all scattering components.">Crystal::GetScatteringComponentList()</a> automatically.</p>
<p>This <em>seriously</em> affects the speed of the calculation, since computing interatomic distances is lenghty. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">use</td><td>set to 1 to use, 0 not to use it. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="accc77bfc6df977685c01a43d150a8ba7"></a><!-- doxytag: member="ObjCryst::Crystal::XMLInput" ref="accc77bfc6df977685c01a43d150a8ba7" args="(istream &amp;is, const XMLCrystTag &amp;tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="a00020.html#accc77bfc6df977685c01a43d150a8ba7">ObjCryst::Crystal::XMLInput</a> </td>
          <td>(</td>
          <td class="paramtype">istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00151.html">XMLCrystTag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Input From stream. </p>
<dl class="todo"><dt><b><a class="el" href="a00222.html#_todo000027">Todo:</a></b></dt><dd>Add an bool XMLInputTag(is,tag) function to recognize all the tags from the stream. So that each inherited class can use the XMLInputTag function from its parent (ie take advantage of inheritance). The children class would first try to interpret the tag, then if unsuccessful would pass it to its parent (thus allowing overloading), etc... </dd></dl>

<p>Reimplemented from <a class="el" href="a00071.html#ac13a4045c3f187879443c8615c38d623">ObjCryst::RefinableObj</a>.</p>

</div>
</div>
<a class="anchor" id="a037f8ea8c5dceece1044ce73d542a0e4"></a><!-- doxytag: member="ObjCryst::Crystal::XMLOutput" ref="a037f8ea8c5dceece1044ce73d542a0e4" args="(ostream &amp;os, int indent=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="a00020.html#a037f8ea8c5dceece1044ce73d542a0e4">ObjCryst::Crystal::XMLOutput</a> </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>indent</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Output to stream in well-formed XML. </p>
<dl class="todo"><dt><b><a class="el" href="a00222.html#_todo000026">Todo:</a></b></dt><dd>Use inheritance.. as for XMLInputTag()... </dd></dl>

<p>Reimplemented from <a class="el" href="a00071.html#a7b9b6ed0f8dcf753d398c35e073de973">ObjCryst::RefinableObj</a>.</p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a23a42c8aacd3c5525d92dfddf4dff73d"></a><!-- doxytag: member="ObjCryst::Crystal::mClockDynPopCorr" ref="a23a42c8aacd3c5525d92dfddf4dff73d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00072.html">RefinableObjClock</a> <a class="el" href="a00020.html#a23a42c8aacd3c5525d92dfddf4dff73d">ObjCryst::Crystal::mClockDynPopCorr</a><code> [mutable, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Last time the dynamical population correction was computed </p>

</div>
</div>
<a class="anchor" id="a87859e98018e0e7a0d71a8e69419d687"></a><!-- doxytag: member="ObjCryst::Crystal::mClockNeighborTable" ref="a87859e98018e0e7a0d71a8e69419d687" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00072.html">RefinableObjClock</a> <a class="el" href="a00020.html#a87859e98018e0e7a0d71a8e69419d687">ObjCryst::Crystal::mClockNeighborTable</a><code> [mutable, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Last time the Neighbor Table was generated </p>

</div>
</div>
<a class="anchor" id="ac2a8728c253bf1a5f1f9dfa0b8fd1cc5"></a><!-- doxytag: member="ObjCryst::Crystal::mClockScattCompList" ref="ac2a8728c253bf1a5f1f9dfa0b8fd1cc5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00072.html">RefinableObjClock</a> <a class="el" href="a00020.html#ac2a8728c253bf1a5f1f9dfa0b8fd1cc5">ObjCryst::Crystal::mClockScattCompList</a><code> [mutable, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Last time the <a class="el" href="a00087.html" title="list of scattering positions in a crystal, associated with the corresponding occupancy and a pointer ...">ScatteringComponentList</a> was generated </p>

</div>
</div>
<a class="anchor" id="ab0bedeb759e922842d3b2cd1eda9d688"></a><!-- doxytag: member="ObjCryst::Crystal::mDisplayEnantiomer" ref="ab0bedeb759e922842d3b2cd1eda9d688" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00078.html">RefObjOpt</a> <a class="el" href="a00020.html#ab0bedeb759e922842d3b2cd1eda9d688">ObjCryst::Crystal::mDisplayEnantiomer</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Display the enantiomeric (mirror along x) structure in 3D? This can be helpful for non-centrosymmetric structure which have been solved using powder diffraction (which only gives the relative configuration). </p>

</div>
</div>
<a class="anchor" id="a4be1212d5e9145c9e16cb8e4b9f3501a"></a><!-- doxytag: member="ObjCryst::Crystal::mvBondValenceCalc" ref="a4be1212d5e9145c9e16cb8e4b9f3501a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;long, REAL&gt; <a class="el" href="a00020.html#a4be1212d5e9145c9e16cb8e4b9f3501a">ObjCryst::Crystal::mvBondValenceCalc</a><code> [mutable, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>List of calculated bond valences, as a map, the key being the index of the atom in <a class="el" href="a00020.html#a2f45b59533a1a3114391aa04e7017bf8" title="The list of all scattering components in the crystal.">Crystal::mScattCompList</a>. </p>

</div>
</div>
<a class="anchor" id="a91cbd823da6f8d82a693b24b5f4b42f0"></a><!-- doxytag: member="ObjCryst::Crystal::mvDistTableSq" ref="a91cbd823da6f8d82a693b24b5f4b42f0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="a00052.html">NeighbourHood</a>&gt; <a class="el" href="a00020.html#a91cbd823da6f8d82a693b24b5f4b42f0">ObjCryst::Crystal::mvDistTableSq</a><code> [mutable, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Interatomic distance table for all unique atoms. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>Crystal.h</li>
</ul>
</div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Sat Jan 28 2012 12:38:51 for ObjCryst++ by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
